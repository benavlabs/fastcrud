{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"FastCRUD","text":"<p> Powerful CRUD methods and automatic endpoint creation for FastAPI. </p> <p> </p> <p> FastCRUD is a Python package for FastAPI, offering robust async CRUD operations and flexible endpoint creation utilities, streamlined through advanced features like auto-detected join conditions, dynamic sorting, and offset and cursor pagination. </p>"},{"location":"#features","title":"Features","text":"<ul> <li>Fully Async: Leverages Python's async capabilities for non-blocking database operations.</li> <li>SQLAlchemy 2.0: Works with the latest SQLAlchemy version for robust database interactions.</li> <li>SQLModel Support: You can optionally use SQLModel 0.14 or newer instead of SQLAlchemy.</li> <li>Powerful CRUD Functionality: Full suite of efficient CRUD operations with support for joins.</li> <li>Dynamic Query Building: Supports building complex queries dynamically, including filtering, sorting, and pagination.</li> <li>Advanced Join Operations: Facilitates performing SQL joins with other models with automatic join condition detection.</li> <li>Built-in Offset Pagination: Comes with ready-to-use offset pagination.</li> <li>Cursor-based Pagination: Implements efficient pagination for large datasets, ideal for infinite scrolling interfaces.</li> <li>Modular and Extensible: Designed for easy extension and customization to fit your requirements.</li> <li>Auto-generated Endpoints: Streamlines the process of adding CRUD endpoints with custom dependencies and configurations.</li> <li>Clean Architecture: Built with a six-level dependency hierarchy that prevents circular dependencies and supports future extensibility.</li> </ul>"},{"location":"#quick-start","title":"Quick Start","text":"<p>Using SQLModel?</p> <p>Since SQLModel combines SQLAlchemy and Pydantic, you can replace the separate model and schema definitions below with SQLModel classes. Wherever you see SQLAlchemy models or Pydantic schemas in the documentation, just use SQLModel instead - it works seamlessly with FastCRUD.</p>"},{"location":"#1-define-your-model-and-schema","title":"1. Define Your Model and Schema","text":"models.py<pre><code>import datetime\nfrom sqlalchemy import Column, DateTime, Integer, Numeric, String, func\nfrom sqlalchemy.orm import DeclarativeBase, sessionmaker\nfrom sqlalchemy.ext.asyncio import AsyncSession, create_async_engine\nfrom pydantic import BaseModel\n\nclass Base(DeclarativeBase):\n    pass\n\n# SQLAlchemy Model\nclass Item(Base):\n    __tablename__ = \"items\"\n    id = Column(Integer, primary_key=True)\n    name = Column(String)\n    description = Column(String)\n    category = Column(String)\n    price = Column(Numeric)\n    last_sold = Column(DateTime)\n    created_at = Column(DateTime, default=func.now())\n\n\n\n# Pydantic Schema\nclass ItemSchema(BaseModel):\n    name: str | None = None\n    description: str | None = None\n    category: str | None = None\n    price: float | None = None\n    last_sold: datetime.datetime | None = None\n\n\n\n# Database connection\nDATABASE_URL = \"sqlite+aiosqlite:///./test.db\"\nengine = create_async_engine(DATABASE_URL, echo=True)\nasync_session = sessionmaker(engine, class_=AsyncSession, expire_on_commit=False)\n</code></pre>"},{"location":"#2-set-up-fastapi-with-fastcrud","title":"2. Set Up FastAPI with FastCRUD","text":"main.py<pre><code>from typing import AsyncGenerator\nfrom fastapi import FastAPI\nfrom sqlalchemy.ext.asyncio import AsyncSession\nfrom fastcrud import crud_router\n\n# Database session dependency\nasync def get_session() -&gt; AsyncGenerator[AsyncSession, None]:\n    async with async_session() as session:\n        yield session\n\n# Create tables before app start\nasync def lifespan(app: FastAPI):\n    async with engine.begin() as conn:\n        await conn.run_sync(Base.metadata.create_all)\n    yield\n\n# FastAPI app\napp = FastAPI(lifespan=lifespan)\n\n# Create CRUD router\nitem_router = crud_router(\n    session=get_session,\n    model=Item,\n    create_schema=ItemSchema,\n    update_schema=ItemSchema,\n    path=\"/items\",\n    tags=[\"Items\"]\n)\n\napp.include_router(item_router)\n</code></pre>"},{"location":"#3-thats-it","title":"3. That's It!","text":"<p>Start your FastAPI application and visit <code>/docs</code> - your CRUD endpoints are automatically created and documented!</p>"},{"location":"#requirements","title":"Requirements","text":"<p>Before installing FastCRUD, ensure you have the following prerequisites:</p> <ul> <li>Python: Version 3.9 or newer.</li> <li>FastAPI: FastCRUD is built to work with FastAPI, so having FastAPI in your project is essential.</li> <li>SQLAlchemy or SQLModel: FastCRUD uses SQLAlchemy 2.0 for database operations, so you need SQLAlchemy 2.0 or newer or SQLModel 0.14 or newer.</li> <li>Pydantic V2 or SQLModel: FastCRUD leverages Pydantic models for data validation and serialization, so you need Pydantic 2.0 or newer or SQLModel 0.14 or newer.</li> </ul>"},{"location":"#installing","title":"Installing","text":"<p>To install, just run:</p> <pre><code>pip install fastcrud\n</code></pre> <p>Or, if using UV:</p> <pre><code>uv add fastcrud\n</code></pre>"},{"location":"#usage","title":"Usage","text":"<p>FastCRUD offers two primary ways to use its functionalities:</p> <ol> <li>By using <code>crud_router</code> for automatic endpoint creation.</li> <li>By integrating <code>FastCRUD</code> directly into your FastAPI endpoints for more control.</li> </ol> <p>Below are examples demonstrating both approaches:</p>"},{"location":"#using-crud_router-for-automatic-endpoint-creation","title":"Using <code>crud_router</code> for Automatic Endpoint Creation","text":"<p>Here's a quick example to get you started:</p>"},{"location":"#define-your-model-and-schemas","title":"Define Your Model and Schemas","text":"item/model.py<pre><code>from sqlalchemy import Column, DateTime, Integer, Numeric, String, func\nfrom sqlalchemy.orm import DeclarativeBase\n\n\nclass Base(DeclarativeBase):\n    pass\n\n\nclass Item(Base):\n    __tablename__ = \"items\"\n    id = Column(Integer, primary_key=True)\n    name = Column(String)\n    description = Column(String)\n    category = Column(String)\n    price = Column(Numeric)\n    last_sold = Column(DateTime)\n    created_at = Column(DateTime, default=func.now())\n</code></pre> item/schemas.py<pre><code>import datetime\n\nfrom pydantic import BaseModel\n\n\nclass CreateItemSchema(BaseModel):\n    name: str | None = None\n    description: str | None = None\n    category: str | None = None\n    price: float | None = None\n    last_sold: datetime.datetime | None = None\n\n\nclass UpdateItemSchema(BaseModel):\n    name: str | None = None\n    description: str | None = None\n    category: str | None = None\n    price: float | None = None\n    last_sold: datetime.datetime | None = None\n</code></pre>"},{"location":"#set-up-fastapi-and-fastcrud","title":"Set Up FastAPI and FastCRUD","text":"main.py<pre><code>from typing import AsyncGenerator\n\nfrom fastapi import FastAPI\nfrom fastcrud import crud_router\nfrom fastcrud import FastCRUD\nfrom sqlalchemy.ext.asyncio import AsyncSession, create_async_engine\nfrom sqlalchemy.orm import sessionmaker\n\nfrom .item.model import Base, Item\nfrom .item.schemas import CreateItemSchema, UpdateItemSchema\n\n# Database setup (Async SQLAlchemy)\nDATABASE_URL = \"sqlite+aiosqlite:///./test.db\"\nengine = create_async_engine(DATABASE_URL, echo=True)\nasync_session = sessionmaker(engine, class_=AsyncSession, expire_on_commit=False)\n\n# Database session dependency\nasync def get_session() -&gt; AsyncGenerator[AsyncSession, None]:\n    async with async_session() as session:\n        yield session\n\n# Create tables before the app start\nasync def lifespan(app: FastAPI):\n    async with engine.begin() as conn:\n        await conn.run_sync(Base.metadata.create_all)\n    yield\n\n# FastAPI app\napp = FastAPI(lifespan=lifespan)\n\n# CRUD operations setup\nitem_crud = FastCRUD(Item)\n\n# CRUD router setup\nitem_router = crud_router(\n    session=get_session,\n    model=Item,\n    create_schema=CreateItemSchema,\n    update_schema=UpdateItemSchema,\n    crud=item_crud,\n    path=\"/items\",\n    tags=[\"Items\"],\n)\n\napp.include_router(item_router)\n</code></pre>"},{"location":"#using-fastcrud-in-user-defined-fastapi-endpoints","title":"Using FastCRUD in User-Defined FastAPI Endpoints","text":"<p>For more control over your endpoints, you can use FastCRUD directly within your custom FastAPI route functions. Here's an example:</p> api/v1/items.py<pre><code>from fastapi import FastAPI, Depends, HTTPException\nfrom sqlalchemy.ext.asyncio import AsyncSession\nfrom fastcrud import FastCRUD\n\nfrom .item.model import Item\nfrom .item.schemas import CreateItemSchema, UpdateItemSchema\n\n# Assume async_session is already set up as per the previous example\n\n# Instantiate FastCRUD with your model\nitem_crud = FastCRUD(Item)\n\n@app.post(\"/custom/items/\")\nasync def create_item(item_data: CreateItemSchema, db: AsyncSession = Depends(get_session)):\n    return await item_crud.create(db, item_data)\n\n@app.get(\"/custom/items/{item_id}\")\nasync def read_item(item_id: int, db: AsyncSession = Depends(get_session)):\n    item = await item_crud.get(db, id=item_id)\n    if not item:\n        raise HTTPException(status_code=404, detail=\"Item not found\")\n    return item\n\n# You can add more routes for update and delete operations in a similar fashion\n</code></pre>"},{"location":"#license","title":"License","text":"<p><code>MIT</code></p>          Why Choose FastCRUD? \u2192"},{"location":"changelog/","title":"FastCRUD Changelog","text":""},{"location":"changelog/#introduction","title":"Introduction","text":"<p>The Changelog documents all notable changes made to FastCRUD. This includes new features, bug fixes, and improvements. It's organized by version and date, providing a clear history of the library's development.</p>"},{"location":"changelog/#0190-nov-7-2025","title":"[0.19.0] - Nov 7, 2025","text":""},{"location":"changelog/#added","title":"Added","text":"<ul> <li>Complete Architectural Overhaul by @igorbenav</li> <li>Six-layer protocol-based architecture replacing helper-based design</li> <li>8 new Protocol interfaces eliminating circular dependencies and enabling clean testing</li> <li>15+ specialized core modules with strategic caching and performance optimizations</li> <li>Enhanced type safety with method overloads and <code>return_as_model</code> parameter across 7 methods</li> <li>New Configuration Classes by @igorbenav</li> <li><code>CreateConfig</code>, <code>UpdateConfig</code>, <code>DeleteConfig</code> for server-side field injection and security</li> <li>Auto field injection with dependency support and schema exclusion capabilities</li> <li>All configuration classes available from main <code>fastcrud</code> import</li> <li>Enhanced Type System by @igorbenav</li> <li>New precise types: <code>FilterValueType</code>, <code>FilterValue</code>, <code>FilterValueSequence</code></li> <li>Response types: <code>GetMultiResponseDict</code>, <code>GetMultiResponseModel</code>, <code>UpsertMultiResponseDict</code>, <code>UpsertMultiResponseModel</code></li> <li>Full type safety with proper type guards and isinstance checks</li> </ul>"},{"location":"changelog/#fixed","title":"Fixed","text":"<ul> <li>Cartesian Product in Complex Joins by @igorbenav</li> <li>Fixed duplicate results in <code>get_joined</code> with multiple one-to-many joins and <code>nest_joins=True</code></li> <li>Enhanced join processing with proper deduplication for complex relationship scenarios</li> </ul>"},{"location":"changelog/#improved","title":"Improved","text":"<ul> <li>Performance Optimizations by @igorbenav</li> <li>Instance-level caching for SQLAlchemy introspection operations</li> <li>Multi-level caching implementation for query building and schema modifications</li> <li>Pure function architecture patterns for data transformation</li> <li>Enhanced Import Structure by @igorbenav</li> <li>All utilities now available from main <code>fastcrud</code> import</li> <li>Deprecated <code>fastcrud.paginated</code> module with proper warning system</li> <li>Centralized configuration and utility exports</li> </ul>"},{"location":"changelog/#breaking-changes","title":"Breaking Changes","text":"<p>\u26a0\ufe0f None - This release maintains full backward compatibility with 0.18.x</p>"},{"location":"changelog/#deprecated","title":"Deprecated","text":"<ul> <li>fastcrud.paginated Module - Import pagination utilities directly from <code>fastcrud</code> instead</li> </ul>"},{"location":"changelog/#whats-changed","title":"What's Changed","text":"<ul> <li>Major refactor by @igorbenav in https://github.com/benavlabs/fastcrud/pull/275</li> <li>Get joined fix by @igorbenav in https://github.com/benavlabs/fastcrud/pull/276  </li> <li>FastCRUD refactor by @igorbenav in https://github.com/benavlabs/fastcrud/pull/277</li> <li>Architecture refactor by @igorbenav in https://github.com/benavlabs/fastcrud/pull/278</li> <li>Better typing by @igorbenav in https://github.com/benavlabs/fastcrud/pull/279</li> <li>Fix codecoverage by @igorbenav in https://github.com/benavlabs/fastcrud/pull/280</li> <li>Final preparations for 0.19.0 by @igorbenav in https://github.com/benavlabs/fastcrud/pull/281</li> </ul> <p>Full Changelog: https://github.com/benavlabs/fastcrud/compare/v0.18.1...v0.19.0</p>"},{"location":"changelog/#0181-nov-4-2025","title":"[0.18.1] - Nov 4, 2025","text":""},{"location":"changelog/#fixed_1","title":"Fixed","text":"<ul> <li>Composite Primary Key Deduplication Bug in Joins by @igorbenav</li> <li>Fixed critical bug where models with composite primary keys were incorrectly deduplicated in one-to-many relationships</li> <li>Enhanced primary key handling to support full composite key comparison instead of just the first key</li> <li>Comprehensive refactoring of join helper functions for better maintainability and performance</li> <li>Added extensive test coverage for composite primary key scenarios</li> </ul>"},{"location":"changelog/#improved_1","title":"Improved","text":"<ul> <li>Join Processing Architecture by @igorbenav</li> <li>Major refactoring of <code>fastcrud/crud/helper.py</code> with improved code organization</li> <li>Enhanced column extraction and labeling logic for better join performance</li> <li>Improved error handling and validation for model attributes</li> <li>Better separation of concerns in join configuration processing</li> </ul>"},{"location":"changelog/#breaking-changes_1","title":"Breaking Changes","text":"<p>\u26a0\ufe0f None - This release maintains full backward compatibility with 0.18.0</p>"},{"location":"changelog/#whats-changed_1","title":"What's Changed","text":"<ul> <li>fix composite key bug in joins, refactor helper by @igorbenav</li> <li>change version by @igorbenav</li> </ul> <p>Full Changelog: https://github.com/benavlabs/fastcrud/compare/v0.18.0...v0.18.1</p>"},{"location":"changelog/#0180-nov-4-2025","title":"[0.18.0] - Nov 4, 2025","text":""},{"location":"changelog/#added_1","title":"Added","text":"<ul> <li>CountConfig for Related Object Counting by @doubledare704</li> <li>New configuration class for efficiently counting related objects in joined queries</li> <li>Supports many-to-many and one-to-many relationship counting via scalar subqueries</li> <li>Comprehensive support for composite primary keys and complex joins</li> <li>Seamless integration with <code>get_multi_joined</code> method</li> <li>PaginatedRequestQuery Schema by @doubledare704</li> <li>Reusable Pydantic schema for standardizing pagination query parameters</li> <li>Supports both page-based and offset-based pagination modes</li> <li>Enhanced OpenAPI documentation with proper field descriptions</li> <li>Backward-compatible implementation with existing endpoints</li> <li>Server-Side Field Injection (Pre-Processor Functions) by @LucasQR</li> <li>Automatic field injection for create, update, and delete operations</li> <li>CreateConfig, UpdateConfig, and DeleteConfig for comprehensive endpoint configuration</li> <li>Support for dependency injection with FastAPI's Depends system</li> <li>Security-focused field exclusion from API schemas and documentation</li> </ul>"},{"location":"changelog/#fixed_2","title":"Fixed","text":"<ul> <li>return_as_model Join Prefix Compatibility by @igorbenav</li> <li>Resolved silent failure when join_prefix doesn't match Pydantic schema field names</li> <li>Added comprehensive validation with clear error messages for mismatched configurations</li> <li>Enhanced support for nested joins with proper field mapping</li> <li>Prevents data loss in joined relationships when using return_as_model=True</li> </ul>"},{"location":"changelog/#improved_2","title":"Improved","text":"<ul> <li>Documentation and Community by @emiliano-gandini-outeda, @LucasQR, @igorbenav</li> <li>Added DeepWiki badge and documentation links to README</li> <li>Fixed Discord invite to use permanent link instead of temporary</li> <li>Enhanced join documentation with compatibility warnings and examples</li> <li>Community features and improved project accessibility</li> </ul>"},{"location":"changelog/#breaking-changes_2","title":"Breaking Changes","text":"<p>\u26a0\ufe0f None - This release maintains full backward compatibility with 0.17.x</p> <p>Full Changelog: https://github.com/benavlabs/fastcrud/compare/v0.17.1...v0.18.0</p>"},{"location":"changelog/#0171-oct-8-2025","title":"[0.17.1] - Oct 8, 2025","text":""},{"location":"changelog/#added_2","title":"Added","text":"<ul> <li>Multiple Values Support for OR/NOT Filters by @igorbenav</li> <li>Enhanced <code>__or</code> and <code>__not</code> operators to accept lists of values for the same operator</li> <li>Enables multiple LIKE patterns, equality checks, and other operators in single filter conditions</li> <li>Syntax: <code>name__or={\"like\": [\"Alice%\", \"Frank%\"]}</code></li> <li>Fully backward compatible with existing filter syntax</li> <li>Comprehensive test coverage for both SQLAlchemy and SQLModel</li> </ul>"},{"location":"changelog/#fixed_3","title":"Fixed","text":"<ul> <li>Dictionary Key Duplication in Tests by @igorbenav</li> <li>Fixed invalid Python syntax in test files where dictionary keys were duplicated</li> <li>Updated existing tests to use new list syntax for multiple values</li> <li>Resolved ruff linting errors in test suite</li> </ul>"},{"location":"changelog/#improved_3","title":"Improved","text":"<ul> <li>Filter Documentation Enhancement by @igorbenav</li> <li>Updated advanced filters documentation with new list syntax examples</li> <li>Added comprehensive usage patterns for multiple value filtering</li> <li>Enhanced examples showing mixed list and single value usage</li> </ul>"},{"location":"changelog/#breaking-changes_3","title":"Breaking Changes","text":"<p>\u26a0\ufe0f None - This release maintains full backward compatibility with 0.17.x</p>"},{"location":"changelog/#whats-changed_2","title":"What's Changed","text":"<ul> <li>feat: support multiple values for same operator in OR/NOT filters by @igorbenav</li> <li>fix: resolve duplicate dictionary keys in test files by @igorbenav</li> <li>docs: enhance filtering documentation with list syntax examples by @igorbenav</li> <li>test: add comprehensive coverage for multiple value filtering by @igorbenav</li> </ul> <p>Full Changelog: https://github.com/benavlabs/fastcrud/compare/v0.17.0...v0.17.1</p>"},{"location":"changelog/#0170-sep-25-2025","title":"[0.17.0] - Sep 25, 2025","text":""},{"location":"changelog/#fixed_4","title":"Fixed","text":"<ul> <li>Pydantic Relationship Fields Issue by @doubledare704</li> <li>Fixed <code>get_multi</code> returning boolean values for Pydantic relationship fields when select schema is provided</li> <li>Resolved cartesian product issues when including relationship fields in schemas</li> <li>Enhanced test coverage with comprehensive SQL verification</li> <li>Delete Methods Filtering &amp; Typing by @doubledare704</li> <li>Added missing filter support for delete operations</li> <li>Improved type annotations for delete methods</li> <li>Enhanced type safety for delete operations</li> <li>Dynamic Filter Parsing by @luminosoda</li> <li>Fixed parsing issue with filter operators containing double underscores</li> <li>Correctly handles complex filter operations like <code>field__gte</code>, <code>field__lt</code></li> <li>Improved robustness of dynamic filter processing</li> </ul>"},{"location":"changelog/#added_3","title":"Added","text":"<ul> <li>Joined Model Filtering for Automatic Endpoints by @doubledare704</li> <li>Support for dot notation in filter configurations (e.g., <code>company.name</code>)</li> <li>Automatic detection and handling of relationship-based filters</li> <li>Enhanced FilterConfig to validate and parse joined model filters</li> <li>Comprehensive filtering across related models in CRUD endpoints</li> </ul>"},{"location":"changelog/#improved_4","title":"Improved","text":"<ul> <li>Test Infrastructure Enhancement by @doubledare704</li> <li>Refactored test suite to eliminate pytest warnings</li> <li>Enhanced test coverage with SQL-level verification</li> <li>Better integration with existing test patterns</li> <li>More descriptive test naming conventions</li> </ul>"},{"location":"changelog/#documentation-updates","title":"Documentation Updates","text":"<ul> <li>Joined Model Filtering Guide with comprehensive examples and usage patterns</li> <li>Enhanced Endpoint Documentation with detailed filtering examples</li> <li>Improved Test Documentation with better patterns and conventions</li> </ul>"},{"location":"changelog/#breaking-changes_4","title":"Breaking Changes","text":"<p>\u26a0\ufe0f None - This release maintains full backward compatibility with 0.16.x</p>"},{"location":"changelog/#whats-changed_3","title":"What's Changed","text":"<ul> <li>add analytics to mkdocs by @igorbenav in #250</li> <li>\ud83d\udd27Fix for get_multi returns boolean values for pydantic relationship fields, if a select schema is provided #199 by @doubledare704 in #245</li> <li>fix: add delete filters and type annotation for delete methods. #147 by @doubledare704 in #244</li> <li>feat: implement joined model filtering for automatic endpoints by @doubledare704 in #246</li> <li>Fix #248 by @luminosoda in #249</li> <li>update pyproject by @igorbenav in #252</li> </ul>"},{"location":"changelog/#new-contributors","title":"New Contributors","text":"<ul> <li>@luminosoda made their first contribution in #249</li> </ul> <p>Full Changelog: https://github.com/benavlabs/fastcrud/compare/v0.16.0...v0.17.0</p>"},{"location":"changelog/#0160-aug-25-2025","title":"[0.16.0] - Aug 25, 2025","text":""},{"location":"changelog/#added_4","title":"Added","text":"<ul> <li>Enhanced Create Method by @igorbenav</li> <li>Added <code>schema_to_select</code> parameter for selecting specific columns</li> <li>Added <code>return_as_model</code> to return Pydantic models instead of SQLAlchemy instances</li> <li>Flexible data return methods for better API design</li> <li>Advanced Sorting Functionality by @igorbenav</li> <li>Multi-field sorting support with ascending/descending control</li> <li>Flexible sorting syntax like <code>field1,-field2</code></li> <li>Enhanced query performance and user experience</li> <li>Dependency-Based Filtering by @igorbenav</li> <li>Runtime filtering using FastAPI dependencies</li> <li>Supports row-level access control</li> <li>Seamless authentication system integration</li> </ul>"},{"location":"changelog/#improved_5","title":"Improved","text":"<ul> <li>Enhanced Documentation with comprehensive examples and usage patterns</li> <li>Better SQLAlchemy Support for non-native column types</li> <li>Type Safety Enhancements across the codebase</li> <li>Performance Optimizations for query handling</li> </ul>"},{"location":"changelog/#breaking-changes_5","title":"Breaking Changes","text":"<p>\u26a0\ufe0f None - This release maintains full backward compatibility with 0.15.x</p>"},{"location":"changelog/#whats-changed_4","title":"What's Changed","text":"<ul> <li>Enhanced create method with flexible return options by @igorbenav</li> <li>Advanced sorting functionality implementation by @igorbenav</li> <li>Dependency-based filtering for enhanced security by @igorbenav</li> <li>Documentation improvements and examples by @igorbenav</li> </ul> <p>Full Changelog: https://github.com/benavlabs/fastcrud/compare/v0.15.12...v0.16.0</p>"},{"location":"changelog/#01512-jun-9-2025","title":"[0.15.12] - Jun 9, 2025","text":""},{"location":"changelog/#added_5","title":"Added","text":"<ul> <li>Configurable Response Key by @igorbenav</li> <li>Added configurable response key for <code>get_multi</code> method</li> <li>Enhanced flexibility in API response structure</li> <li>Documentation Improvements by @igorbenav</li> <li>Moved documentation to new location</li> <li>Added banner and CRUDAdmin mention</li> </ul>"},{"location":"changelog/#improved_6","title":"Improved","text":"<ul> <li>Dependency Updates by @arab0v</li> <li>Updated SQLAlchemy-utils dependency to version 0.41.2</li> <li>Enhanced compatibility and security</li> </ul>"},{"location":"changelog/#whats-changed_5","title":"What's Changed","text":"<ul> <li>Added banner and CRUDAdmin mention by @igorbenav</li> <li>Updated SQLAlchemy-utils dependency to version 0.41.2 by @arab0v</li> <li>Added configurable response key for get_multi method by @igorbenav</li> <li>Moved documentation by @igorbenav</li> <li>Bumped project version by @igorbenav</li> </ul>"},{"location":"changelog/#new-contributors_1","title":"New Contributors","text":"<ul> <li>@arab0v made their first contribution</li> </ul> <p>Full Changelog: https://github.com/benavlabs/fastcrud/compare/v0.15.11...v0.15.12</p>"},{"location":"changelog/#01511-may-10-2025","title":"[0.15.11] - May 10, 2025","text":""},{"location":"changelog/#added_6","title":"Added","text":"<ul> <li>Multi-Field OR Filter Functionality by @doubledare704</li> <li>Implemented multi-field OR filter functionality</li> <li>Enhanced querying capabilities across multiple fields</li> <li>Improved filter flexibility for complex search scenarios</li> </ul>"},{"location":"changelog/#whats-changed_6","title":"What's Changed","text":"<ul> <li>Add multi-field OR filter functionality by @doubledare704</li> <li>Preparations for 0.15.11 by @igorbenav</li> </ul> <p>Full Changelog: https://github.com/benavlabs/fastcrud/compare/v0.15.10...v0.15.11</p>"},{"location":"changelog/#01510-may-9-2025","title":"[0.15.10] - May 9, 2025","text":""},{"location":"changelog/#fixed_5","title":"Fixed","text":"<ul> <li>Metadata Publishing Bug by @igorbenav</li> <li>Fixed bug in <code>pyproject.toml</code> that caused versions 0.15.8 and 0.15.9 to be published only with metadata</li> <li>Resolved packaging issues for proper distribution</li> </ul>"},{"location":"changelog/#notes","title":"Notes","text":"<p>Versions <code>0.15.8</code> and <code>0.15.9</code> were published only with metadata because of a bug in <code>pyproject.toml</code>. This version resolves the packaging issue.</p> <p>Full Changelog: https://github.com/benavlabs/fastcrud/compare/v0.15.9...v0.15.10</p>"},{"location":"changelog/#0159-may-9-2025","title":"[0.15.9] - May 9, 2025","text":""},{"location":"changelog/#notes_1","title":"Notes","text":"<p>This version was published only with metadata due to a bug in <code>pyproject.toml</code>. See version 0.15.10 for the fix.</p> <p>Full Changelog: https://github.com/benavlabs/fastcrud/compare/v0.15.8...v0.15.9</p>"},{"location":"changelog/#0158-may-9-2025","title":"[0.15.8] - May 9, 2025","text":""},{"location":"changelog/#added_7","title":"Added","text":"<ul> <li>New Documentation Page by @igorbenav</li> <li>Added comprehensive documentation page</li> <li>Enhanced project documentation structure</li> <li>UV Package Manager by @VDuchauffour</li> <li>Introduced UV as package manager</li> <li>Improved development workflow and dependency management</li> </ul>"},{"location":"changelog/#fixed_6","title":"Fixed","text":"<ul> <li>get_multi_joined Total Count by @igorbenav</li> <li>Fixed <code>get_multi_joined</code> total_count issue with join_model parameter</li> <li>Resolved counting inconsistencies in joined queries</li> <li>get_multi_by_cursor Bug by @igorbenav</li> <li>Fixed code issues in <code>get_multi_by_cursor</code> method</li> <li>Improved cursor-based pagination reliability</li> </ul>"},{"location":"changelog/#improved_7","title":"Improved","text":"<ul> <li>Code Optimizations by @igorbenav</li> <li>Performed code optimizations in fast_crud.py</li> <li>Enhanced performance and maintainability</li> <li>Sorting for Nested Fields by @igorbenav</li> <li>Implemented sorting functionality for nested fields</li> <li>Enhanced query capabilities for complex data structures</li> <li>Project Configuration by @igorbenav</li> <li>Updated pyproject.toml configuration</li> <li>Updated README.md with latest information</li> </ul>"},{"location":"changelog/#whats-changed_7","title":"What's Changed","text":"<ul> <li>Added new documentation page by @igorbenav</li> <li>Updated pyproject.toml by @igorbenav</li> <li>Fixed <code>get_multi_joined</code> total_count with join_model parameter by @igorbenav</li> <li>Code optimizations in fast_crud.py by @igorbenav</li> <li>Introduced UV as package manager by @VDuchauffour</li> <li>Fixed code in <code>get_multi_by_cursor</code> by @igorbenav</li> <li>Implemented sorting for nested fields by @igorbenav</li> <li>Updated README.md by @igorbenav</li> </ul>"},{"location":"changelog/#new-contributors_2","title":"New Contributors","text":"<ul> <li>@VDuchauffour made their first contribution</li> </ul> <p>Full Changelog: https://github.com/benavlabs/fastcrud/compare/v0.15.7...v0.15.8</p>"},{"location":"changelog/#0157-mar-25-2025","title":"[0.15.7] - Mar 25, 2025","text":""},{"location":"changelog/#added_8","title":"Added","text":"<ul> <li>Advanced filter configs by @doubledare704</li> <li>OR and NOT for filtering by @doubledare704</li> </ul>"},{"location":"changelog/#improved_8","title":"Improved","text":"<ul> <li>Remove redundant code by @suhanwu in #211</li> <li>Added pragma: no cover to relevant lines by @igorbenav in #212</li> </ul>"},{"location":"changelog/#whats-changed_8","title":"What's Changed","text":"<ul> <li>Implement advanced filter configs by @doubledare704 in #204</li> <li>Implement OR and NOT for filtering by @doubledare704 in #210</li> <li>Fix: Remove redundant code by @suhanwu in #211</li> <li>Added # pragma: no cover to relevant lines by @igorbenav in #212</li> </ul>"},{"location":"changelog/#new-contributors_3","title":"New Contributors","text":"<ul> <li>@suhanwu made their first contribution in #211</li> <li>@doubledare704 made their first contribution in #204</li> </ul> <p>Full Changelog: https://github.com/igorbenav/fastcrud/compare/v0.15.6...v0.15.7</p>"},{"location":"changelog/#0156-feb-19-2025","title":"[0.15.6] - Feb 19, 2025","text":""},{"location":"changelog/#added_9","title":"Added","text":"<ul> <li>Models and Schemas, Batch 5: Projects and Participants by @slaarti in #195</li> <li>Security.md by @igorbenav in #200</li> </ul>"},{"location":"changelog/#fixed_7","title":"Fixed","text":"<ul> <li>Cryptography Package Vulnerability updated to address OpenSSL vulnerability by @igorbenav in #202</li> </ul>"},{"location":"changelog/#documentation-updates_1","title":"Documentation Updates","text":"<ul> <li>Showcase by @igorbenav in #193</li> </ul>"},{"location":"changelog/#whats-changed_9","title":"What's Changed","text":"<ul> <li>Showcase by @igorbenav in #193</li> <li>Models and Schemas, Batch 5: Projects and Participants by @slaarti in #195</li> <li>Create SECURITY.md by @igorbenav in #200</li> <li>Bump cryptography to fix vulnerability by @igorbenav in #202</li> </ul> <p>Full Changelog: https://github.com/igorbenav/fastcrud/compare/v0.15.5...v0.15.6</p>"},{"location":"changelog/#0155-dec-25-2024","title":"[0.15.5] - Dec 25, 2024","text":""},{"location":"changelog/#fixed_8","title":"Fixed","text":"<ul> <li>Get multi with return_as_model is now properly typed</li> <li>Filter with a UUID that is not a primary key now working</li> <li>Update with not found record now raises error as previously defined by warning</li> <li>Response model working properly in swagger</li> </ul>"},{"location":"changelog/#whats-changed_10","title":"What's Changed","text":"<ul> <li>Some fixes by @igorbenav in #190</li> <li>Response model in swagger by @igorbenav in #191</li> <li>Change version in pyproject to 0.15.5 by @igorbenav in #192</li> </ul> <p>Full Changelog: https://github.com/igorbenav/fastcrud/compare/v0.15.4...v0.15.5</p>"},{"location":"changelog/#0154-dec-23-2024","title":"[0.15.4] - Dec 23, 2024","text":""},{"location":"changelog/#added_10","title":"Added","text":"<ul> <li>Implement select_schema on EndpointCreator and crud_router by @ljmc-github in #169</li> </ul>"},{"location":"changelog/#fixed_9","title":"Fixed","text":"<ul> <li>Custom name bug fix by @igorbenav in #187</li> <li>UUID support fix by @igorbenav in #188</li> </ul>"},{"location":"changelog/#whats-changed_11","title":"What's Changed","text":"<ul> <li>Implement select_schema on EndpointCreator and crud_router by @ljmc-github in #169</li> <li>Custom name bug fix by @igorbenav in #187</li> <li>UUID support fix by @igorbenav in #188</li> <li>Bump version to 0.15.4 by @igorbenav in #189</li> </ul>"},{"location":"changelog/#new-contributors_4","title":"New Contributors","text":"<ul> <li>@ljmc-github made their first contribution in #169</li> </ul> <p>Full Changelog: https://github.com/igorbenav/fastcrud/compare/v0.15.3...v0.15.4</p>"},{"location":"changelog/#0153-dec-23-2024","title":"[0.15.3] - Dec 23, 2024","text":""},{"location":"changelog/#fixed_10","title":"Fixed","text":"<ul> <li>Get multi joined issue with repetition and wrong count</li> </ul>"},{"location":"changelog/#whats-changed_12","title":"What's Changed","text":"<ul> <li>Bug fixes by @igorbenav in #186</li> </ul> <p>Full Changelog: https://github.com/igorbenav/fastcrud/compare/v0.15.2...v0.15.3</p>"},{"location":"changelog/#0152-dec-15-2024","title":"[0.15.2] - Dec 15, 2024","text":""},{"location":"changelog/#added_11","title":"Added","text":"<ul> <li>Add commit option to upsert_multi by @feluelle in #174</li> </ul>"},{"location":"changelog/#fixed_11","title":"Fixed","text":"<ul> <li>Add missing commit to update by @feluelle in #173</li> <li>Default page or items_per_page for when paginating using the get on list by @phguyss in #177</li> <li>Improve update method when item is not found by @julianaklulo in #176</li> </ul>"},{"location":"changelog/#improved_9","title":"Improved","text":"<ul> <li>Fix quick-start documentation by @EduardoTT in #178</li> <li>Bump actions to avoid node16 EOL issue by @Zatura in #180</li> <li>Changelog updated by @igorbenav in #167</li> </ul>"},{"location":"changelog/#whats-changed_13","title":"What's Changed","text":"<ul> <li>Changelog updated by @igorbenav in #167</li> <li>Add missing commit to update by @feluelle in #173</li> <li>Add commit option to upsert_multi by @feluelle in #174</li> <li>Fix: quick-start documentation by @EduardoTT in #178</li> <li>Improve update method when item is not found by @julianaklulo in #176</li> <li>Bump actions to avoid node16 EOL issue by @Zatura in #180</li> <li>Fix: default page or items_per_page for when paginating using the get on list by @phguyss in #177</li> </ul>"},{"location":"changelog/#new-contributors_5","title":"New Contributors","text":"<ul> <li>@EduardoTT made their first contribution in #178</li> <li>@julianaklulo made their first contribution in #176</li> <li>@Zatura made their first contribution in #180</li> <li>@phguyss made their first contribution in #177</li> </ul> <p>Full Changelog: https://github.com/igorbenav/fastcrud/compare/v0.15.1...v0.15.2</p>"},{"location":"changelog/#0151-sep-18-2024","title":"[0.15.1] - Sep 18, 2024","text":""},{"location":"changelog/#added_12","title":"Added","text":"<ul> <li>Support for fastapi &gt;=0.100</li> </ul>"},{"location":"changelog/#whats-changed_14","title":"What's Changed","text":"<ul> <li>now supporting fastapi &gt;= 0.100.0 by @igorbenav in https://github.com/igorbenav/fastcrud/pull/166</li> </ul> <p>Full Changelog: https://github.com/igorbenav/fastcrud/compare/v0.15.0...v0.15.1</p>"},{"location":"changelog/#0150-sep-18-2024","title":"[0.15.0] - Sep 18, 2024","text":""},{"location":"changelog/#added_13","title":"Added","text":"<ul> <li>Models and Schemas for Task Management (Batch 3) by @slaarti</li> <li>Models and Schemas for Articles, Authors, and Profiles (Batch 4) by @slaarti</li> <li><code>update_override</code> Argument to <code>upsert_multi</code> Method by @feluelle</li> <li>Configurable <code>is_deleted</code> Field in Soft Delete Logic by @gal-dahan</li> </ul>"},{"location":"changelog/#improved_10","title":"Improved","text":"<ul> <li>Fixed Complex Parameter Filter with <code>between</code> Operator by @wu-clan</li> <li>Fixed Cryptography Package Vulnerability</li> <li>Resolved Update Column Name Collision in Update Method</li> </ul>"},{"location":"changelog/#fixed_12","title":"Fixed","text":"<ul> <li>Vulnerability in <code>cryptography</code> Package updated to <code>cryptography = \"^43.0.1\"</code></li> <li>Update Column Name Collision in the <code>update</code> method</li> </ul>"},{"location":"changelog/#documentation-updates_2","title":"Documentation Updates","text":"<ul> <li>Added Documentation for New Models and Schemas by @slaarti</li> <li>Updated <code>upsert_multi</code> Method Documentation with <code>update_override</code> Usage by @feluelle</li> <li>Clarified Endpoint Simplification and Deprecation Notices</li> </ul>"},{"location":"changelog/#warnings","title":"Warnings","text":"<ul> <li>Deprecation Notice: The <code>_read_paginated</code> endpoint has been removed. Please transition to using <code>_read_items</code> with pagination parameters. Docs here.</li> <li>Deprecation Notice: Handling of <code>Depends</code> is now only callable within <code>_inject_depend</code>. Update your code accordingly.</li> <li>Configuration Change Alert: Endpoints are simplified by default. Adjust your configurations to align with the new defaults. Docs here.</li> </ul>"},{"location":"changelog/#detailed-changes","title":"Detailed Changes","text":""},{"location":"changelog/#endpoint-simplification-and-deprecation-of-_read_paginated","title":"Endpoint Simplification and Deprecation of <code>_read_paginated</code>","text":""},{"location":"changelog/#description","title":"Description","text":"<p>To streamline API endpoint configurations, endpoints with empty strings as names are now the standard. Additionally, the <code>_read_paginated</code> endpoint has been removed, with its functionality merged into <code>_read_items</code>.</p>"},{"location":"changelog/#changes","title":"Changes","text":"<ul> <li>Simplified Endpoint Configuration: Endpoints can now be defined with empty strings to create cleaner paths.</li> <li>Removed <code>_read_paginated</code> Endpoint: Pagination is now handled via optional parameters in <code>_read_items</code>.</li> </ul>"},{"location":"changelog/#usage-examples","title":"Usage Examples","text":"<p>Paginated Read Example:</p> <pre><code>curl -X 'GET' \\\n  'http://localhost:8000/items?page=2&amp;itemsPerPage=10' \\\n  -H 'accept: application/json'\n</code></pre> <p>Non-Paginated Read Example:</p> <pre><code>curl -X 'GET' \\\n  'http://localhost:8000/items?offset=0&amp;limit=100' \\\n  -H 'accept: application/json'\n</code></pre>"},{"location":"changelog/#warnings_1","title":"Warnings","text":"<p>Warning</p> <p>The <code>_read_paginated</code> endpoint is deprecated. Use <code>_read_items</code> with pagination parameters instead.</p> <p>Warning</p> <p>Default endpoint names are now empty strings. Adjust your configurations to match the new defaults.</p>"},{"location":"changelog/#update_override-argument-in-upsert_multi-method","title":"<code>update_override</code> Argument in <code>upsert_multi</code> Method","text":""},{"location":"changelog/#description_1","title":"Description","text":"<p>The <code>upsert_multi</code> method now includes an <code>update_override</code> argument, giving developers the ability to override the default update logic during upsert operations. This enhancement provides greater flexibility for custom update scenarios, such as utilizing SQL <code>CASE</code> statements or other complex expressions.</p>"},{"location":"changelog/#changes_1","title":"Changes","text":"<ul> <li><code>update_override</code> Argument: Allows custom update logic in <code>upsert_multi</code>.</li> <li>Dialect Support: Implemented for PostgreSQL, SQLite, and MySQL.</li> <li>Tests: Added comprehensive tests to ensure functionality across different SQL dialects.</li> </ul>"},{"location":"changelog/#usage-example","title":"Usage Example","text":"<pre><code>from fastcrud import FastCRUD\nfrom sqlalchemy import case\nfrom .models.item import Item\nfrom .database import session as db\n\ncrud_items = FastCRUD(Item)\n\nawait crud_items.upsert_multi(\n    db=db,\n    instances=[\n        ItemCreateSchema(id=1, name=\"Item A\", price=10),\n        ItemCreateSchema(id=2, name=\"Item B\", price=20),\n    ],\n    update_override={\n        \"price\": case(\n            (Item.price.is_(None), db.excluded.price),\n            else_=Item.price,\n        )\n    }\n)\n</code></pre>"},{"location":"changelog/#configurable-is_deleted-field-in-soft-delete-logic","title":"Configurable <code>is_deleted</code> Field in Soft Delete Logic","text":""},{"location":"changelog/#description_2","title":"Description","text":"<p>The <code>is_deleted</code> field in the soft delete logic is now optional and configurable. This change allows developers to customize the soft delete behavior per model, providing flexibility in how deletion states are handled.</p>"},{"location":"changelog/#new-contributors_6","title":"New Contributors","text":"<ul> <li>@wu-clan made their first contribution \ud83c\udf1f</li> <li>@gal-dahan made their first contribution \ud83c\udf1f</li> </ul> <p>Full Changelog: View the full changelog</p>"},{"location":"changelog/#0140-jul-29-2024","title":"[0.14.0] - Jul 29, 2024","text":""},{"location":"changelog/#added_14","title":"Added","text":"<ul> <li>Type-checking support for SQLModel types by @kdcokenny \ud83d\ude80</li> <li>Returning clause to update operations by @feluelle</li> <li>Upsert_multi functionality by @feluelle</li> <li>Simplified endpoint configurations by @JakNowy, streamlining path generation and merging pagination functionalities into a unified <code>_read_items</code> endpoint, promoting more efficient API structure and usage. Details in https://github.com/igorbenav/fastcrud/pull/105</li> </ul>"},{"location":"changelog/#improved_11","title":"Improved","text":"<ul> <li>Comprehensive tests for paginated retrieval of items, maintaining 100% coverage</li> <li>Docker client check before running tests that require Docker by @feluelle</li> </ul>"},{"location":"changelog/#fixed_13","title":"Fixed","text":"<ul> <li>Vulnerability associated with an outdated cryptography package</li> <li>Return type inconsistency in async session fixtures by @slaarti</li> </ul>"},{"location":"changelog/#documentation-updates_3","title":"Documentation Updates","text":"<ul> <li>Cleanup of documentation formatting by @slaarti</li> <li>Replacement of the Contributing section in docs with an include to file in repo root by @slaarti</li> <li>Correction of links to advanced filters in docstrings by @slaarti</li> <li>Backfill of docstring fixes across various modules by @slaarti</li> <li>Enhanced filter documentation with new AND and OR clause examples, making complex queries more accessible and understandable.</li> </ul>"},{"location":"changelog/#models-and-schemas-enhancements","title":"Models and Schemas Enhancements","text":"<ul> <li>Introduction of simple and one-off models (Batch 1) by @slaarti</li> <li>Expansion to include models and schemas for Customers, Products, and Orders (Batch 2) by @slaarti</li> </ul>"},{"location":"changelog/#code-refinements","title":"Code Refinements","text":"<ul> <li>Resolution of missing type specifications in kwargs by @slaarti</li> <li>Collapsed space adjustments for models/schemas in <code>fast_crud.py</code> by @slaarti</li> </ul>"},{"location":"changelog/#warnings_2","title":"Warnings","text":"<ul> <li>Deprecation Notice: <code>_read_paginated</code> endpoint is set to be deprecated and merged into <code>_read_items</code>. Users are encouraged to transition to the latter, utilizing optional pagination parameters. Full details and usage instructions provided to ensure a smooth transition.</li> <li>Future Changes Alert: Default endpoint names in <code>EndpointCreator</code> are anticipated to be set to empty strings in a forthcoming major release, aligning with simplification efforts. Refer to https://github.com/igorbenav/fastcrud/issues/67 for more information.</li> </ul>"},{"location":"changelog/#detailed-changes_1","title":"Detailed Changes","text":""},{"location":"changelog/#simplified-endpoint-configurations","title":"Simplified Endpoint Configurations","text":"<p>In an effort to streamline FastCRUD\u2019s API, we have reconfigured endpoint paths to avoid redundancy (great work by @JakNowy). This change allows developers to specify empty strings for endpoint names in the <code>crud_router</code> setup, which prevents the generation of unnecessary <code>//</code> in the paths. The following configurations illustrate how endpoints can now be defined more succinctly:</p> <pre><code>endpoint_names = {\n    \"create\": \"\",\n    \"read\": \"\",\n    \"update\": \"\",\n    \"delete\": \"\",\n    \"db_delete\": \"\",\n    \"read_multi\": \"\",\n    \"read_paginated\": \"get_paginated\",\n}\n</code></pre> <p>Moreover, the <code>_read_paginated</code> logic has been integrated into the <code>_read_items</code> endpoint. This integration means that pagination can now be controlled via <code>page</code> and <code>items_per_page</code> query parameters, offering a unified method for both paginated and non-paginated reads:</p> <ul> <li>Paginated read example:</li> </ul> <pre><code>curl -X 'GET' \\\n  'http://localhost:8000/users/get_multi?page=2&amp;itemsPerPage=10' \\\n  -H 'accept: application/json'\n</code></pre> <ul> <li>Non-paginated read example:</li> </ul> <pre><code>curl -X 'GET' \\\n  'http://localhost:8000/users/get_multi?offset=0&amp;limit=100' \\\n  -H 'accept: application/json'\n</code></pre>"},{"location":"changelog/#warnings_3","title":"Warnings","text":"<ul> <li>Deprecation Warning: The <code>_read_paginated</code> endpoint is slated for deprecation. Developers should transition to using <code>_read_items</code> with the relevant pagination parameters.</li> <li>Configuration Change Alert: In a future major release, default endpoint names in <code>EndpointCreator</code> will be empty strings by default, as discussed in Issue #67.</li> </ul>"},{"location":"changelog/#advanced-filters-documentation-update","title":"Advanced Filters Documentation Update","text":"<p>Documentation for advanced filters has been expanded to include comprehensive examples of AND and OR clauses, enhancing the utility and accessibility of complex query constructions.</p> <ul> <li>OR clause example:</li> </ul> <pre><code># Fetch items priced under $5 or above $20\nitems = await item_crud.get_multi(\n    db=db,\n    price__or={'lt': 5, 'gt': 20},\n)\n</code></pre> <ul> <li>AND clause example:</li> </ul> <pre><code># Fetch items priced under $20 and over 2 years of warranty\nitems = await item_crud.get_multi(\n    db=db,\n    price__lt=20,\n    warranty_years__gt=2,\n)\n</code></pre>"},{"location":"changelog/#returning-clauses-in-update-operations","title":"Returning Clauses in Update Operations","text":""},{"location":"changelog/#description_3","title":"Description","text":"<p>Users can now retrieve updated records immediately following an update operation. This feature streamlines the process, reducing the need for subsequent retrieval calls and increasing efficiency.</p>"},{"location":"changelog/#changes_2","title":"Changes","text":"<ul> <li>Return Columns: Specify the columns to be returned after the update via the <code>return_columns</code> argument.</li> <li>Schema Selection: Optionally select a Pydantic schema to format the returned data using the <code>schema_to_select</code> argument.</li> <li>Return as Model: Decide if the returned data should be converted into a model using the <code>return_as_model</code> argument.</li> <li>Single or None: Utilize the <code>one_or_none</code> argument to ensure that either a single record is returned or none, in case the conditions do not match any records.</li> </ul> <p>These additions are aligned with existing CRUD API functions, enhancing consistency across the library and making the new features intuitive for users.</p>"},{"location":"changelog/#usage-example_1","title":"Usage Example","text":""},{"location":"changelog/#returning-updated-fields","title":"Returning Updated Fields","text":"<pre><code>from fastcrud import FastCRUD\nfrom .models.item import Item\nfrom .database import session as db\n\ncrud_items = FastCRUD(Item)\nupdated_item = await crud_items.update(\n    db=db,\n    object={\"price\": 9.99},\n    price__lt=10,\n    return_columns=[\"price\"]\n)\n# This returns the updated price of the item directly.\n</code></pre>"},{"location":"changelog/#returning-data-as-a-model","title":"Returning Data as a Model","text":"<pre><code>from fastcrud import FastCRUD\nfrom .models.item import Item\nfrom .schemas.item import ItemSchema\nfrom .database import session as db\n\ncrud_items = FastCRUD(Item)\nupdated_item_schema = await crud_items.update(\n    db=db,\n    object={\"price\": 9.99},\n    price__lt=10,\n    schema_to_select=ItemSchema,\n    return_as_model=True\n)\n# This returns the updated item data formatted as an ItemSchema model.\n</code></pre>"},{"location":"changelog/#bulk-upsert-operations-with-upsert_multi","title":"Bulk Upsert Operations with <code>upsert_multi</code>","text":"<p>The <code>upsert_multi</code> method provides the ability to perform bulk upsert operations, which are optimized for different SQL dialects.</p>"},{"location":"changelog/#changes_3","title":"Changes","text":"<ul> <li>Dialect-Optimized SQL: Uses the most efficient SQL commands based on the database's SQL dialect.</li> <li>Support for Multiple Dialects: Includes custom implementations for PostgreSQL, SQLite, and MySQL, with appropriate handling for each's capabilities and limitations.</li> </ul>"},{"location":"changelog/#usage-example_2","title":"Usage Example","text":""},{"location":"changelog/#upserting-multiple-records","title":"Upserting Multiple Records","text":"<pre><code>from fastcrud import FastCRUD\nfrom .models.item import Item\nfrom .schemas.item import ItemCreateSchema, ItemSchema\nfrom .database import session as db\n\ncrud_items = FastCRUD(Item)\nitems = await crud_items.upsert_multi(\n    db=db,\n    instances=[\n        ItemCreateSchema(price=9.99),\n    ],\n    schema_to_select=ItemSchema,\n    return_as_model=True,\n)\n# This will return the upserted data in the form of ItemSchema.\n</code></pre>"},{"location":"changelog/#implementation-details","title":"Implementation Details","text":"<p><code>upsert_multi</code> handles different database dialects: - PostgreSQL: Uses <code>ON CONFLICT DO UPDATE</code>. - SQLite: Utilizes <code>ON CONFLICT DO UPDATE</code>. - MySQL: Implements <code>ON DUPLICATE KEY UPDATE</code>.</p>"},{"location":"changelog/#notes_2","title":"Notes","text":"<ul> <li>MySQL and MariaDB do not support certain advanced features used in other dialects, such as returning values directly after an insert or update operation. This limitation is clearly documented to prevent misuse.</li> </ul>"},{"location":"changelog/#new-contributors_7","title":"New Contributors","text":"<ul> <li>@kdcokenny made their first contribution \ud83c\udf1f</li> <li>@feluelle made their first contribution \ud83c\udf1f</li> </ul> <p>Full Changelog: View the full changelog</p>"},{"location":"changelog/#0131-jun-22-2024","title":"[0.13.1] - Jun 22, 2024","text":""},{"location":"changelog/#added_15","title":"Added","text":"<ul> <li>More Advanced Filters by @JakNowy \ud83c\udf89</li> </ul>"},{"location":"changelog/#fixed_14","title":"Fixed","text":"<ul> <li>Bug where objects with null primary key are returned with all fields set to None in nested joins #102</li> </ul>"},{"location":"changelog/#detailed-changes_2","title":"Detailed Changes","text":""},{"location":"changelog/#advanced-filters","title":"Advanced Filters","text":"<p>FastCRUD supports advanced filtering options, allowing you to query records using operators such as greater than (<code>__gt</code>), less than (<code>__lt</code>), and their inclusive counterparts (<code>__gte</code>, <code>__lte</code>). These filters can be used in any method that retrieves or operates on records, including <code>get</code>, <code>get_multi</code>, <code>exists</code>, <code>count</code>, <code>update</code>, and <code>delete</code>.</p>"},{"location":"changelog/#single-parameter-filters","title":"Single parameter filters","text":"<p>Most filter operators require a single string or integer value.</p> <pre><code># Fetch items priced above $5\nitems = await item_crud.get_multi(\n    db=db,\n    price__gte=5,\n)\n</code></pre> <p>Currently supported single parameter filters are: - __gt - greater than - __lt - less than - __gte - greater than or equal to - __lte - less than or equal to - __ne - not equal - __is - used to test True, False, and None identity - __is_not - negation of \"is\" - __like - SQL \"like\" search for specific text pattern - __notlike - negation of \"like\" - __ilike - case insensitive \"like\" - __notilike - case insensitive \"notlike\" - __startswith - text starts with given string - __endswith - text ends with given string - __contains - text contains given string - __match - database-specific match expression</p>"},{"location":"changelog/#complex-parameter-filters","title":"Complex parameter filters","text":"<p>Some operators require multiple values. They must be passed as a python tuple, list, or set.</p> <p><pre><code># Fetch items priced between $5 and $20\nitems = await item_crud.get_multi(\n    db=db,\n    price__between=(5, 20),\n)\n</code></pre> - __between - between 2 numeric values - __in - included in - __not_in - not included in</p>"},{"location":"changelog/#or-parameter-filters","title":"OR parameter filters","text":"<p>More complex OR filters are supported. They must be passed as a dictionary, where each key is a library-supported operator to be used in OR expression and values are what get's passed as the parameter.</p> <pre><code># Fetch items priced under $5 or above $20\nitems = await item_crud.get_multi(\n    db=db,\n    price__or={'lt': 5, 'gt': 20},\n)\n</code></pre>"},{"location":"changelog/#whats-changed_15","title":"What's Changed","text":"<ul> <li>Missing sqlalchemy operators by @JakNowy in https://github.com/igorbenav/fastcrud/pull/85</li> <li>Null primary key bug fixed in https://github.com/igorbenav/fastcrud/pull/107</li> </ul> <p>Full Changelog: https://github.com/igorbenav/fastcrud/compare/v0.13.0...v0.13.1</p>"},{"location":"changelog/#0130-may-28-2024","title":"[0.13.0] - May 28, 2024","text":""},{"location":"changelog/#added_16","title":"Added","text":"<ul> <li>Filters in Automatic Endpoints \ud83c\udf89</li> <li>One-to-many support in joins</li> <li>Upsert method in FastCRUD class by @dubusster</li> </ul>"},{"location":"changelog/#detailed-changes_3","title":"Detailed Changes","text":""},{"location":"changelog/#using-filters-in-fastcrud","title":"Using Filters in FastCRUD","text":"<p>FastCRUD provides filtering capabilities, allowing you to filter query results based on various conditions. Filters can be applied to <code>read_multi</code> and <code>read_paginated</code> endpoints. This section explains how to configure and use filters in FastCRUD.</p>"},{"location":"changelog/#defining-filters","title":"Defining Filters","text":"<p>Filters are either defined using the <code>FilterConfig</code> class or just passed as a dictionary. This class allows you to specify default filter values and validate filter types. Here's an example of how to define filters for a model:</p> <pre><code>from fastcrud import FilterConfig\n\n# Define filter configuration for a model\nfilter_config = FilterConfig(\n    tier_id=None,  # Default filter value for tier_id\n    name=None  # Default filter value for name\n)\n</code></pre> <p>And the same thing using a <code>dict</code>: <pre><code>filter_config = {\n    \"tier_id\": None,  # Default filter value for tier_id\n    \"name\": None,  # Default filter value for name\n}\n</code></pre></p> <p>By using <code>FilterConfig</code> you get better error messages.</p>"},{"location":"changelog/#applying-filters-to-endpoints","title":"Applying Filters to Endpoints","text":"<p>You can apply filters to your endpoints by passing the <code>filter_config</code> to the <code>crud_router</code> or <code>EndpointCreator</code>. Here's an example:</p> <pre><code>from fastcrud import crud_router\nfrom yourapp.models import YourModel\nfrom yourapp.schemas import CreateYourModelSchema, UpdateYourModelSchema\nfrom yourapp.database import async_session\n\n# Apply filters using crud_router\napp.include_router(\n    crud_router(\n        session=async_session,\n        model=YourModel,\n        create_schema=CreateYourModelSchema,\n        update_schema=UpdateYourModelSchema,\n        filter_config=filter_config,  # Apply the filter configuration\n        path=\"/yourmodel\",\n        tags=[\"YourModel\"]\n    )\n)\n</code></pre>"},{"location":"changelog/#using-filters-in-requests","title":"Using Filters in Requests","text":"<p>Once filters are configured, you can use them in your API requests. Filters are passed as query parameters. Here's an example of how to use filters in a request to a paginated endpoint:</p> <pre><code>GET /yourmodel/get_paginated?page=1&amp;itemsPerPage=3&amp;tier_id=1&amp;name=Alice\n</code></pre>"},{"location":"changelog/#custom-filter-validation","title":"Custom Filter Validation","text":"<p>The <code>FilterConfig</code> class includes a validator to check filter types. If an invalid filter type is provided, a <code>ValueError</code> is raised. You can customize the validation logic by extending the <code>FilterConfig</code> class:</p> <pre><code>from fastcrud import FilterConfig\nfrom pydantic import ValidationError\n\nclass CustomFilterConfig(FilterConfig):\n    @field_validator(\"filters\")\n    def check_filter_types(cls, filters: dict[str, Any]) -&gt; dict[str, Any]:\n        for key, value in filters.items():\n            if not isinstance(value, (type(None), str, int, float, bool)):\n                raise ValueError(f\"Invalid default value for '{key}': {value}\")\n        return filters\n\ntry:\n    # Example of invalid filter configuration\n    invalid_filter_config = CustomFilterConfig(invalid_field=[])\nexcept ValidationError as e:\n    print(e)\n</code></pre>"},{"location":"changelog/#handling-invalid-filter-columns","title":"Handling Invalid Filter Columns","text":"<p>FastCRUD ensures that filters are applied only to valid columns in your model. If an invalid filter column is specified, a <code>ValueError</code> is raised:</p> <pre><code>try:\n    # Example of invalid filter column\n    invalid_filter_config = FilterConfig(non_existent_column=None)\nexcept ValueError as e:\n    print(e)  # Output: Invalid filter column 'non_existent_column': not found in model\n</code></pre>"},{"location":"changelog/#handling-one-to-one-and-one-to-many-joins-in-fastcrud","title":"Handling One-to-One and One-to-Many Joins in FastCRUD","text":"<p>FastCRUD provides flexibility in handling one-to-one and one-to-many relationships through <code>get_joined</code> and <code>get_multi_joined</code> methods, along with the ability to specify how joined data should be structured using both the <code>relationship_type</code> (default <code>one-to-one</code>) and the <code>nest_joins</code> (default <code>False</code>) parameters.</p>"},{"location":"changelog/#one-to-one-relationships","title":"One-to-One Relationships","text":"<ul> <li><code>get_joined</code>: Fetch a single record and its directly associated record (e.g., a user and their profile).</li> <li><code>get_multi_joined</code> (with <code>nest_joins=False</code>): Retrieve multiple records, each linked to a single related record from another table (e.g., users and their profiles).</li> </ul> <p>Example</p> <p>Let's define two tables:</p> <pre><code>class User(Base):\n    __tablename__ = \"user\"\n    id = Column(Integer, primary_key=True)\n    name = Column(String)\n    tier_id = Column(Integer, ForeignKey(\"tier.id\"))\n\nclass Tier(Base):\n    __tablename__ = \"tier\"\n    id = Column(Integer, primary_key=True)\n    name = Column(String, unique=True)\n</code></pre> <p>Fetch a user and their tier:</p> <pre><code>user_tier = await user_crud.get_joined(\n    db=db,\n    join_model=Tier,\n    join_on=User.tier_id == Tier.id,\n    join_type=\"left\",\n    join_prefix=\"tier_\",\n    id=1\n)\n</code></pre> <p>The result will be:</p> <pre><code>{\n    \"id\": 1,\n    \"name\": \"Example\",\n    \"tier_id\": 1,\n    \"tier_name\": \"Free\"\n}\n</code></pre> <p>One-to-One Relationship with Nested Joins</p> <p>To get the joined data in a nested dictionary:</p> <pre><code>user_tier = await user_crud.get_joined(\n    db=db,\n    join_model=Tier,\n    join_on=User.tier_id == Tier.id,\n    join_type=\"left\",\n    join_prefix=\"tier_\",\n    nest_joins=True,\n    id=1\n)\n</code></pre> <p>The result will be:</p> <pre><code>{\n    \"id\": 1,\n    \"name\": \"Example\",\n    \"tier\": {\n        \"id\": 1,\n        \"name\": \"Free\"\n    }\n}\n</code></pre>"},{"location":"changelog/#one-to-many-relationships","title":"One-to-Many Relationships","text":"<ul> <li><code>get_joined</code> (with <code>nest_joins=True</code>): Retrieve a single record with all its related records nested within it (e.g., a user and all their blog posts).</li> <li><code>get_multi_joined</code> (with <code>nest_joins=True</code>): Fetch multiple primary records, each with their related records nested (e.g., multiple users and all their blog posts).</li> </ul> <p>Warning</p> <p>When using <code>nest_joins=True</code>, the performance will always be a bit worse than when using <code>nest_joins=False</code>. For cases where more performance is necessary, consider using <code>nest_joins=False</code> and remodeling your database.</p> <p>Example</p> <p>To demonstrate a one-to-many relationship, let's assume <code>User</code> and <code>Post</code> tables:</p> <pre><code>class User(Base):\n    __tablename__ = \"user\"\n    id = Column(Integer, primary key=True)\n    name = Column(String)\n\nclass Post(Base):\n    __tablename__ = \"post\"\n    id = Column(Integer, primary key=True)\n    user_id = Column(Integer, ForeignKey(\"user.id\"))\n    content = Column(String)\n</code></pre> <p>Fetch a user and all their posts:</p> <pre><code>user_posts = await user_crud.get_joined(\n    db=db,\n    join_model=Post,\n    join_on=User.id == Post.user_id,\n    join_type=\"left\",\n    join_prefix=\"post_\",\n    nest_joins=True,\n    id=1\n)\n</code></pre> <p>The result will be:</p> <pre><code>{\n    \"id\": 1,\n    \"name\": \"Example User\",\n    \"posts\": [\n        {\n            \"id\": 101,\n            \"user_id\": 1,\n            \"content\": \"First post content\"\n        },\n        {\n            \"id\": 102,\n            \"user_id\": 1,\n            \"content\": \"Second post content\"\n        }\n    ]\n}\n</code></pre>"},{"location":"changelog/#whats-changed_16","title":"What's Changed","text":"<ul> <li>feat: \u2728 add upsert method in FastCRUD class by @dubusster</li> <li>Filters in Automatic Endpoints</li> <li>One-to-many support in joins</li> <li>tests fixed by @igorbenav</li> <li>Using the same session for all tests</li> <li>warning added to docs</li> </ul> <p>Full Changelog: https://github.com/igorbenav/fastcrud/compare/v0.12.1...v0.13.0</p>"},{"location":"changelog/#0121-may-10-2024","title":"[0.12.1] - May 10, 2024","text":""},{"location":"changelog/#added_17","title":"Added","text":"<ul> <li>Deprecation Warning for dependency handling.</li> </ul>"},{"location":"changelog/#detailed-changes_4","title":"Detailed Changes","text":"<p>If you pass a sequence of <code>params.Depends</code> type variables to any <code>*_deps</code> parameter in <code>EndpointCreator</code> and <code>crud_router</code>, you'll get a warning. Support will be completely removed in 0.15.0.</p> <p>Full Changelog: https://github.com/igorbenav/fastcrud/compare/v0.12.0...v0.12.1</p>"},{"location":"changelog/#0120-may-8-2024","title":"[0.12.0] - May 8, 2024","text":""},{"location":"changelog/#added_18","title":"Added","text":"<ul> <li>Unpaginated versions of multi-row get methods by @slaarti in #62  \ud83c\udf89</li> <li>Nested Join bug fixes</li> <li>Dependency handling now working as docs say</li> <li>Option to Skip commit in some fastcrud methods</li> <li>Docstring example fixes</li> <li><code>__in</code> and <code>__not_in</code> filters by @JakNowy \ud83c\udf89</li> <li>Fastapi 0.111.0 support</li> </ul>"},{"location":"changelog/#detailed-changes_5","title":"Detailed Changes","text":""},{"location":"changelog/#unpaginated-versions-of-multi-row-get-methods","title":"Unpaginated versions of multi-row get methods","text":"<p>Now, if you pass <code>None</code> to <code>limit</code> in <code>get_multi</code> and <code>get_multi_joined</code>, you get the whole unpaginated set of data that matches the filters. Use this with caution.</p> <pre><code>from fastcrud import FastCRUD\nfrom .models.item import Item\nfrom .database import session as db\n\ncrud_items = FastCRUD(Item)\nitems = await crud_items.get_multi(db=db, limit=None)\n# this will return all items in the db\n</code></pre>"},{"location":"changelog/#dependency-handling-now-working-as-docs-say","title":"Dependency handling now working as docs say","text":"<p>Now, you may pass dependencies to <code>crud_router</code> or <code>EndpointCreator</code> as simple functions instead of needing to wrap them in <code>fastapi.Depends</code>.</p> <pre><code>from .dependencies import get_superuser\napp.include_router(\n    crud_router(\n        session=db,\n        model=Item,\n        create_schema=ItemCreate,\n        update_schema=ItemUpdate,\n        delete_schema=ItemDelete,\n        create_deps=[get_superuser],\n        update_deps=[get_superuser],\n        delete_deps=[get_superuser],\n        path=\"/item\",\n        tags=[\"item\"],\n    )\n)\n</code></pre>"},{"location":"changelog/#option-to-skip-commit-in-some-fastcrud-methods","title":"Option to Skip commit in some fastcrud methods","text":"<p>For <code>create</code>, <code>update</code>, <code>db_delete</code> and <code>delete</code> methods of <code>FastCRUD</code>, now you have the option of passing <code>commit=False</code> so you don't commit the operations immediately.</p> <pre><code>from fastcrud import FastCRUD\nfrom .models.item import Item\nfrom .database import session as db\n\ncrud_items = FastCRUD(Item)\n\nawait crud_items.delete(\n    db=db,\n    commit=False,\n    id=1\n)\n# this will not actually delete until you run a db.commit()\n</code></pre>"},{"location":"changelog/#__in-and-__not_in-filters","title":"<code>__in</code> and <code>__not_in</code> filters","text":"<p>You may now pass <code>__in</code> and <code>__not_in</code> to methods that accept advanced queries:</p> <ul> <li><code>__gt</code>: greater than,</li> <li><code>__lt</code>: less than,</li> <li><code>__gte</code>: greater than or equal to,</li> <li><code>__lte</code>: less than or equal to,</li> <li><code>__ne</code>: not equal,</li> <li><code>__in</code>: included in [tuple, list or set],</li> <li><code>__not_in</code>: not included in [tuple, list or set].</li> </ul>"},{"location":"changelog/#whats-changed_17","title":"What's Changed","text":"<ul> <li>Add unpaginated versions of multi-row get methods (w/tests) by @slaarti \ud83c\udf89</li> <li>Join fixes</li> <li>Dependencies</li> <li>Skip commit</li> <li>Docstring fix</li> <li>feat: filter __in by @JakNowy \ud83c\udf89</li> <li>python support for 0.111.0 added</li> <li>version bump in pyproject.toml for 0.12.0</li> </ul>"},{"location":"changelog/#new-contributors_8","title":"New Contributors","text":"<ul> <li>@slaarti made their first contribution in https://github.com/igorbenav/fastcrud/pull/62 \ud83c\udf89</li> </ul> <p>Full Changelog: https://github.com/igorbenav/fastcrud/compare/v0.11.1...v0.12.0</p>"},{"location":"changelog/#0111-apr-22-2024","title":"[0.11.1] - Apr 22, 2024","text":""},{"location":"changelog/#added_19","title":"Added","text":"<ul> <li><code>one_or_none</code> parameter to FastCRUD <code>get</code> method (default <code>False</code>)</li> <li><code>nest_joins</code> parameter to FastCRUD <code>get_joined</code> and <code>get_multi_joined</code> (default <code>False</code>)</li> </ul>"},{"location":"changelog/#detailed-changes_6","title":"Detailed Changes","text":""},{"location":"changelog/#get","title":"<code>get</code>","text":"<p>By default, the <code>get</code> method in <code>FastCRUD</code> returns the <code>first</code> object matching all the filters it finds.</p> <p>If you want to ensure the <code>one_or_none</code> behavior, you may pass the parameter as <code>True</code>:</p> <pre><code>crud.get(\n    async_session,\n    one_or_none=True,\n    category_id=1\n)\n</code></pre>"},{"location":"changelog/#get_joined-and-get_multi_joined","title":"<code>get_joined</code> and <code>get_multi_joined</code>","text":"<p>By default, <code>FastCRUD</code> joins all the data and returns it in a single dictionary. Let's define two tables: <pre><code>class User(Base):\n    __tablename__ = \"user\"\n    id = Column(Integer, primary_key=True)\n    name = Column(String)\n    tier_id = Column(Integer, ForeignKey(\"tier.id\"))\n\n\nclass Tier(Base):\n    __tablename__ = \"tier\"\n    id = Column(Integer, primary_key=True)\n    name = Column(String, unique=True)\n</code></pre></p> <p>And join them with <code>FastCRUD</code>:</p> <pre><code>user_tier = await user_crud.get_joined(\n    db=db,\n    model=Tier,\n    join_on=User.tier_id == Tier.id,\n    join_type=\"left\",\n    join_prefix=\"tier_\",,\n    id=1\n)\n</code></pre> <p>We'll get:</p> <pre><code>{\n    \"id\": 1,\n    \"name\": \"Example\",\n    \"tier_id\": 1,\n    \"tier_name\": \"Free\",\n}\n</code></pre> <p>Now, if you want the joined data in a nested dictionary instead, you may just pass <code>nest_joins=True</code>:</p> <pre><code>user_tier = await user_crud.get_joined(\n    db=db,\n    model=Tier,\n    join_on=User.tier_id == Tier.id,\n    join_type=\"left\",\n    join_prefix=\"tier_\",\n    nest_joins=True,\n    id=1,\n)\n</code></pre> <p>And you will get:</p> <pre><code>{\n    \"id\": 1,\n    \"name\": \"Example\",\n    \"tier\": {\n        \"id\": 1,\n        \"name\": \"Free\",\n    },\n}\n</code></pre> <p>This works for both <code>get_joined</code> and <code>get_multi_joined</code>.</p> <p>Warning</p> <p>Note that the final <code>\"_\"</code> in the passed <code>\"tier_\"</code> is stripped.</p>"},{"location":"changelog/#whats-changed_18","title":"What's Changed","text":"<ul> <li>Reuse of <code>select</code> method in <code>FastCRUD</code></li> <li>Skip count call when possible</li> <li>Add <code>one_or_none</code> parameter to FastCRUD <code>get</code> method</li> <li>Add <code>nest_joins</code> parameter to FastCRUD <code>get_joined</code> and <code>get_multi_joined</code></li> </ul>"},{"location":"changelog/#new-contributors_9","title":"New Contributors","text":"<ul> <li>@JakNowy made their first contribution in PR #51.</li> </ul> <p>Full Changelog: View the full changelog</p>"},{"location":"changelog/#0110-apr-7-2024","title":"[0.11.0] - Apr 7, 2024","text":""},{"location":"changelog/#added_20","title":"Added","text":"<ul> <li>Multiple primary keys support, a significant enhancement by @dubusster in #31 \ud83c\udf89.</li> <li>Option to disable the count in <code>get_multi</code> and <code>get_multi_joined</code> methods for performance optimization.</li> <li>Fixes for a validation bug when <code>return_as_model</code> is set to <code>True</code>.</li> <li>Resolution of a bug concerning incorrect handling of <code>db_row</code> in methods.</li> <li>Correction of the <code>valid_methods</code> bug, which previously raised the wrong error type.</li> <li>Upgrade of <code>FastAPI</code> dependency to version <code>0.111.0</code>, ensuring compatibility with the latest FastAPI features.</li> <li>Achievement of 100% test coverage, with the addition of a workflow and badge to showcase this milestone.</li> <li>Inclusion of the changelog within the project documentation, providing a comprehensive history of changes directly to users.</li> </ul>"},{"location":"changelog/#detailed-changes_7","title":"Detailed Changes","text":""},{"location":"changelog/#multiple-primary-keys-support","title":"Multiple Primary Keys Support","text":"<p>FastCRUD now accommodates models with multiple primary keys, facilitating more complex database designs. For models defined with more than one primary key, the endpoint creator automatically generates paths reflecting the primary keys' order. This feature extends support to primary keys named differently than <code>id</code>, enhancing the flexibility of FastCRUD's routing capabilities.</p>"},{"location":"changelog/#example","title":"Example:","text":"<p>For a model with multiple primary keys, FastCRUD generates specific endpoints such as <code>/multi_pk/get/{id}/{uuid}</code>, accommodating the unique identification needs of complex data models.</p>"},{"location":"changelog/#optional-count","title":"Optional Count","text":"<p>The <code>get_multi</code> and <code>get_multi_joined</code> methods now feature an <code>return_total_count=False</code> parameter, allowing users to opt-out of receiving the total count in responses. This option can enhance performance by skipping potentially expensive count operations.</p>"},{"location":"changelog/#behavior","title":"Behavior:","text":"<ul> <li>By default, <code>return_total_count=True</code> is assumed, returning both data and a total count.</li> <li>When set to <code>False</code>, responses contain only the data array, omitting the total count for efficiency.</li> </ul>"},{"location":"changelog/#whats-changed_19","title":"What's Changed","text":"<ul> <li>Implementation of multiple primary keys support, addressing a significant flexibility requirement for advanced use cases.</li> <li>Introduction of optional count retrieval in multi-get methods, optimizing performance by eliminating unnecessary database queries.</li> <li>Several critical bug fixes, improving the stability and reliability of FastCRUD.</li> <li>Documentation enhancements, including the addition of a changelog section, ensuring users have access to detailed release information.</li> <li>Update to FastAPI <code>0.111.0</code>, ensuring compatibility with the latest enhancements in the FastAPI ecosystem.</li> <li>Achievement of 100% test coverage, marking a significant milestone in the project's commitment to reliability and quality assurance.</li> </ul>"},{"location":"changelog/#relevant-contributors","title":"Relevant Contributors","text":"<ul> <li>@dubusster made a notable contribution with the implementation of multiple primary keys support in PR #31.</li> </ul> <p>Full Changelog: View the full changelog</p>"},{"location":"changelog/#0100-mar-30-2024","title":"[0.10.0] - Mar 30, 2024","text":""},{"location":"changelog/#added_21","title":"Added","text":"<ul> <li><code>select</code> statement functionality, thanks to @dubusster's contribution in PR #28 \ud83d\ude80.</li> <li>Support for joined models in the <code>count</code> method through the <code>joins_config</code> parameter.</li> <li>Filters for joined models via the <code>filters</code> parameter in <code>JoinConfig</code>.</li> <li>Type checking workflow integrated with <code>mypy</code> alongside fixes for typing issues.</li> <li>Linting workflow established with <code>ruff</code>.</li> </ul>"},{"location":"changelog/#detailed-changes_8","title":"Detailed Changes","text":""},{"location":"changelog/#select","title":"Select","text":"<p>The <code>select</code> method constructs a SQL Alchemy <code>Select</code> statement, offering flexibility in column selection, filtering, and sorting. It is designed to chain additional SQLAlchemy methods for complex queries. Docs here and here.</p>"},{"location":"changelog/#features","title":"Features:","text":"<ul> <li>Column Selection: Choose columns via a Pydantic schema.</li> <li>Sorting: Define columns and their order for sorting.</li> <li>Filtering: Directly apply filters through keyword arguments.</li> <li>Chaining: Allow for chaining with other SQLAlchemy methods for advanced query construction.</li> </ul>"},{"location":"changelog/#improved-joins","title":"Improved Joins","text":"<p><code>JoinConfig</code> enhances FastCRUD queries by detailing join operations between models, offering configurations like model joining, conditions, prefixes, column selection through schemas, join types, aliases, and direct filtering. Docs here.</p>"},{"location":"changelog/#applying-joins-in-fastcrud-methods","title":"Applying Joins in FastCRUD Methods","text":"<p>Detailed explanations and examples are provided for using joins in <code>count</code>, <code>get_joined</code>, and <code>get_multi_joined</code> methods to achieve complex data retrieval, including handling of many-to-many relationships.</p>"},{"location":"changelog/#whats-changed_20","title":"What's Changed","text":"<ul> <li>New <code>select</code> statement functionality added.</li> <li>Documentation and method improvements for select and joins.</li> <li>Integration of type checking and linting workflows.</li> <li>Version bump in pyproject.toml.</li> </ul>"},{"location":"changelog/#new-contributors_10","title":"New Contributors","text":"<ul> <li>@dubusster made their first contribution in PR #28.</li> </ul> <p>Full Changelog: View the full changelog</p>"},{"location":"changelog/#091-mar-19-2024","title":"[0.9.1] - Mar 19, 2024","text":""},{"location":"changelog/#added_22","title":"Added","text":"<ul> <li>Enhanced <code>get_joined</code> and <code>get_multi_joined</code> methods to support aliases, enabling multiple joins on the same model. This improvement addresses issue #27.</li> </ul>"},{"location":"changelog/#detailed-changes_9","title":"Detailed Changes","text":""},{"location":"changelog/#alias-support-for-complex-joins","title":"Alias Support for Complex Joins","text":"<p>With the introduction of alias support, <code>get_joined</code> and <code>get_multi_joined</code> methods now allow for more complex queries, particularly beneficial in scenarios requiring self-joins or multiple joins on the same table. Aliases help to avoid conflicts and ambiguity by providing unique identifiers for the same model in different join contexts. Docs here.</p>"},{"location":"changelog/#example-multiple-joins-with-aliases","title":"Example: Multiple Joins with Aliases","text":"<p>To demonstrate the use of aliases, consider a task management system where tasks are associated with both an owner and an assigned user from the same <code>UserModel</code>. Aliases enable joining the <code>UserModel</code> twice under different contexts - as an owner and an assigned user. This example showcases how to set up aliases using the <code>aliased</code> function and incorporate them into your <code>JoinConfig</code> for clear and conflict-free query construction. Docs here.</p>"},{"location":"changelog/#whats-changed_21","title":"What's Changed","text":"<ul> <li>Introduction of aliases in joins, improving query flexibility and expressiveness, as detailed by @igorbenav in PR #29.</li> </ul> <p>Full Changelog: View the full changelog</p>"},{"location":"changelog/#090-mar-14-2024","title":"[0.9.0] - Mar 14, 2024","text":""},{"location":"changelog/#added_23","title":"Added","text":"<ul> <li>Enhanced <code>get_joined</code> and <code>get_multi_joined</code> methods now support handling joins with multiple models.</li> </ul>"},{"location":"changelog/#detailed-changes_10","title":"Detailed Changes","text":""},{"location":"changelog/#multi-model-join-capabilities","title":"Multi-Model Join Capabilities","text":"<p>The <code>get_joined</code> and <code>get_multi_joined</code> methods have been upgraded to accommodate joins involving multiple models. This functionality is facilitated through the <code>joins_config</code> parameter, allowing for the specification of multiple <code>JoinConfig</code> instances. Each instance represents a unique join configuration, broadening the scope for complex data relationship management within FastCRUD. Docs here.</p>"},{"location":"changelog/#example-multi-model-join","title":"Example: Multi-Model Join","text":"<p>A practical example involves retrieving users alongside their corresponding tier and department details. By configuring <code>joins_config</code> with appropriate <code>JoinConfig</code> instances for the <code>Tier</code> and <code>Department</code> models, users can efficiently gather comprehensive data across related models, enhancing data retrieval operations' depth and flexibility.</p> <p>Warning</p> <p>An error will occur if both single join parameters and <code>joins_config</code> are used simultaneously. It's crucial to ensure that your join configurations are correctly set to avoid conflicts.</p>"},{"location":"changelog/#whats-changed_22","title":"What's Changed","text":"<ul> <li>Introduction of multi-model join support in <code>get_joined</code> and <code>get_multi_joined</code>, enabling more complex and detailed data retrieval strategies.</li> <li>Several minor updates and fixes, including package import corrections and <code>pyproject.toml</code> updates, to improve the library's usability and stability.</li> </ul>"},{"location":"changelog/#new-contributors_11","title":"New Contributors","text":"<ul> <li>@iridescentGray</li> </ul> <p>Full Changelog: View the full changelog</p>"},{"location":"changelog/#080-mar-4-2024","title":"[0.8.0] - Mar 4, 2024","text":""},{"location":"changelog/#added_24","title":"Added","text":"<ul> <li>Feature to customize names of auto-generated endpoints using the <code>endpoint_names</code> parameter, applicable in both <code>crud_router</code> function and <code>EndpointCreator</code>.</li> </ul>"},{"location":"changelog/#detailed-changes_11","title":"Detailed Changes","text":""},{"location":"changelog/#custom-endpoint-naming","title":"Custom Endpoint Naming","text":"<p>The introduction of the <code>endpoint_names</code> parameter offers flexibility in defining endpoint names for CRUD operations. This enhancement caters to the need for more descriptive or project-specific naming conventions, enabling developers to align the API's interface with their domain language or organizational standards.</p>"},{"location":"changelog/#example-customizing-endpoint-names-with-crud_router","title":"Example: Customizing Endpoint Names with <code>crud_router</code>","text":"<p>Customizing endpoint names is straightforward with the <code>crud_router</code> function. By providing a dictionary mapping CRUD operation names to desired endpoint names, developers can easily tailor their API's paths to fit their application's unique requirements.</p>"},{"location":"changelog/#example-customizing-endpoint-names-with-endpointcreator","title":"Example: Customizing Endpoint Names with <code>EndpointCreator</code>","text":"<p>Similarly, when using the <code>EndpointCreator</code>, the <code>endpoint_names</code> parameter allows for the same level of customization, ensuring consistency across different parts of the application or service.</p> <p>Tip</p> <p>It's not necessary to specify all endpoint names; only those you wish to change need to be included in the <code>endpoint_names</code> dictionary. This flexibility ensures minimal configuration effort for maximum impact.</p>"},{"location":"changelog/#whats-changed_23","title":"What's Changed","text":"<ul> <li>Enhanced endpoint customization capabilities through <code>endpoint_names</code> parameter, supporting a more tailored and intuitive API design.</li> <li>Documentation updates to guide users through the process of customizing endpoint names.</li> </ul>"},{"location":"changelog/#070-feb-20-2024","title":"[0.7.0] - Feb 20, 2024","text":""},{"location":"changelog/#added_25","title":"Added","text":"<ul> <li>The <code>get_paginated</code> endpoint for retrieving items with pagination support.</li> <li>The <code>paginated</code> module to offer utility functions for pagination.</li> </ul>"},{"location":"changelog/#detailed-changes_12","title":"Detailed Changes","text":""},{"location":"changelog/#get_paginated-endpoint","title":"<code>get_paginated</code> Endpoint","text":"<p>This new endpoint enhances data retrieval capabilities by introducing pagination, an essential feature for handling large datasets efficiently. It supports customizable query parameters for page number and items per page, facilitating flexible data access patterns. Docs here.</p>"},{"location":"changelog/#features_1","title":"Features:","text":"<ul> <li>Endpoint and Method: A <code>GET</code> request to <code>/get_paginated</code>.</li> <li>Query Parameters: Includes <code>page</code> for the page number and <code>itemsPerPage</code> for controlling the number of items per page.</li> <li>Example Usage: Demonstrated with a request for retrieving items with specified pagination settings.</li> </ul>"},{"location":"changelog/#paginated-module","title":"<code>paginated</code> Module","text":"<p>The introduction of the <code>paginated</code> module brings two key utility functions, <code>paginated_response</code> and <code>compute_offset</code>, which streamline the implementation of paginated responses in the application.</p>"},{"location":"changelog/#functions","title":"Functions:","text":"<ul> <li>paginated_response: Constructs a paginated response based on the input data, page number, and items per page.</li> <li>compute_offset: Calculates the offset for database queries, based on the current page number and the number of items per page.</li> </ul>"},{"location":"changelog/#whats-changed_24","title":"What's Changed","text":"<ul> <li>Deployment of pagination functionality, embodied in the <code>get_paginated</code> endpoint and the <code>paginated</code> module, to facilitate efficient data handling and retrieval.</li> </ul> <p>Full Changelog: View the full changelog</p>"},{"location":"changelog/#060-feb-11-2024","title":"[0.6.0] - Feb 11, 2024","text":""},{"location":"changelog/#added_26","title":"Added","text":"<ul> <li>The ability to use a custom <code>updated_at</code> column name in models.</li> <li>Making the passing of the <code>crud</code> parameter to <code>crud_router</code> and <code>EndpointCreator</code> optional.</li> <li>Inclusion of exceptions in the <code>http_exceptions</code> module within the broader <code>exceptions</code> module for better organization and accessibility.</li> </ul>"},{"location":"changelog/#detailed-changes_13","title":"Detailed Changes","text":""},{"location":"changelog/#custom-updated_at-column","title":"Custom <code>updated_at</code> Column","text":"<p>FastCRUD now supports the customization of the <code>updated_at</code> column name, providing flexibility for applications with different database schema conventions or naming practices. Docs here.</p>"},{"location":"changelog/#example-configuration","title":"Example Configuration:","text":"<p>The example demonstrates how to specify a custom column name for <code>updated_at</code> when setting up the router for an endpoint, allowing for seamless integration with existing database schemas.</p>"},{"location":"changelog/#whats-changed_25","title":"What's Changed","text":"<ul> <li>Introduction of features enhancing flexibility and usability, such as custom <code>updated_at</code> column names and the optional CRUD parameter in routing configurations.</li> </ul> <p>Full Changelog: View the full changelog</p>"},{"location":"changelog/#050-feb-3-2024","title":"[0.5.0] - Feb 3, 2024","text":""},{"location":"changelog/#added_27","title":"Added","text":"<ul> <li>Advanced filters inspired by Django ORM for enhanced querying capabilities.</li> <li>Optional bulk operations for update and delete methods.</li> <li>Custom soft delete mechanisms integrated into <code>FastCRUD</code>, <code>EndpointCreator</code>, and <code>crud_router</code>.</li> <li>Comprehensive test suite for the newly introduced features.</li> </ul>"},{"location":"changelog/#detailed-changes_14","title":"Detailed Changes","text":""},{"location":"changelog/#advanced-filters_1","title":"Advanced Filters","text":"<p>The advanced filtering system allows for sophisticated querying with support for operators like <code>__gt</code>, <code>__lt</code>, <code>__gte</code>, and <code>__lte</code>, applicable across various CRUD operations. This feature significantly enhances the flexibility and power of data retrieval and manipulation within FastCRUD. Docs here.</p>"},{"location":"changelog/#examples","title":"Examples:","text":"<ul> <li>Utilization of advanced filters for precise data fetching and aggregation.</li> <li>Implementation examples for fetching records within specific criteria and counting records based on date ranges.</li> </ul>"},{"location":"changelog/#custom-soft-delete-mechanisms","title":"Custom Soft Delete Mechanisms","text":"<p>FastCRUD's soft delete functionality now supports customization, allowing developers to specify alternative column names for <code>is_deleted</code> and <code>deleted_at</code> fields. This adaptation enables seamless integration with existing database schemas that employ different naming conventions for soft deletion tracking. Docs here.</p>"},{"location":"changelog/#example-configuration_1","title":"Example Configuration:","text":"<ul> <li>Setting up <code>crud_router</code> with custom soft delete column names, demonstrating the flexibility in adapting FastCRUD to various database schema requirements.</li> </ul>"},{"location":"changelog/#bulk-operations","title":"Bulk Operations","text":"<p>The introduction of optional bulk operations for updating and deleting records provides a more efficient way to handle large datasets, enabling mass modifications or removals with single method calls. This feature is particularly useful for applications that require frequent bulk data management tasks. Docs here.</p>"},{"location":"changelog/#examples_1","title":"Examples:","text":"<ul> <li>Demonstrating bulk update and delete operations, highlighting the capability to apply changes to multiple records based on specific criteria.</li> </ul>"},{"location":"changelog/#whats-changed_26","title":"What's Changed","text":"<ul> <li>Addition of advanced filters, bulk operations, and custom soft delete functionalities.</li> </ul>"},{"location":"changelog/#new-contributors_12","title":"New Contributors","text":"<ul> <li>@YuriiMotov</li> </ul> <p>Full Changelog: View the full changelog</p>"},{"location":"changelog/#040-jan-31-2024","title":"[0.4.0] - Jan 31, 2024","text":""},{"location":"changelog/#added_28","title":"Added","text":"<ul> <li>Documentation and tests for SQLModel support.</li> <li><code>py.typed</code> file for better typing support.</li> </ul>"},{"location":"changelog/#detailed","title":"Detailed","text":"<p>Check the docs for SQLModel support.</p>"},{"location":"changelog/#whats-changed_27","title":"What's Changed","text":"<ul> <li>SQLModel support.</li> </ul> <p>Full Changelog: View the full changelog</p>"},{"location":"changelog/#030-jan-28-2024","title":"[0.3.0] - Jan 28, 2024","text":""},{"location":"changelog/#added_29","title":"Added","text":"<ul> <li>The <code>CustomEndpointCreator</code> for advanced route creation and customization.</li> <li>The ability to selectively include or exclude CRUD operations in the <code>crud_router</code> using <code>included_methods</code> and <code>deleted_methods</code>.</li> <li>Comprehensive tests for the new features.</li> <li>Detailed documentation on utilizing the <code>CustomEndpointCreator</code> and selectively including or excluding endpoints.</li> </ul>"},{"location":"changelog/#customendpointcreator","title":"CustomEndpointCreator","text":"<p>This feature introduces the capability to extend the <code>EndpointCreator</code> class, enabling developers to define custom routes and incorporate complex logic into API endpoints. The documentation has been updated to include detailed examples and guidelines on implementing and using <code>CustomEndpointCreator</code> in projects. Docs here.</p>"},{"location":"changelog/#selective-crud-operations","title":"Selective CRUD Operations","text":"<p>The <code>crud_router</code> function has been enhanced with <code>included_methods</code> and <code>deleted_methods</code> parameters, offering developers precise control over which CRUD methods are included or excluded when configuring routers. This addition provides flexibility in API design, allowing for the creation of tailored endpoint setups that meet specific project requirements. Docs here.</p>"},{"location":"changelog/#detailed-changes_15","title":"Detailed Changes","text":""},{"location":"changelog/#extending-endpointcreator","title":"Extending EndpointCreator","text":"<p>Developers can now create a subclass of <code>EndpointCreator</code> to define custom routes or override existing methods, adding a layer of flexibility and customization to FastCRUD's routing capabilities.</p>"},{"location":"changelog/#creating-a-custom-endpointcreator","title":"Creating a Custom EndpointCreator","text":"<p>An example demonstrates how to subclass <code>EndpointCreator</code> and add custom routes or override existing methods, further illustrating how to incorporate custom endpoint logic and route configurations into the FastAPI application.</p>"},{"location":"changelog/#adding-custom-routes","title":"Adding Custom Routes","text":"<p>The process involves overriding the <code>add_routes_to_router</code> method to include both standard CRUD routes and custom routes, showcasing how developers can extend FastCRUD's functionality to suit their application's unique needs.</p>"},{"location":"changelog/#using-the-custom-endpointcreator","title":"Using the Custom EndpointCreator","text":"<p>An example highlights how to use the custom <code>EndpointCreator</code> with <code>crud_router</code>, specifying selective methods to be included in the router setup, thereby demonstrating the practical application of custom endpoint creation and selective method inclusion.</p>"},{"location":"changelog/#selective-crud-operations_1","title":"Selective CRUD Operations","text":"<p>Examples for using <code>included_methods</code> and <code>deleted_methods</code> illustrate how to specify exactly which CRUD methods should be included or excluded when setting up the router, offering developers precise control over their API's exposed functionality.</p> <p>Warning</p> <p>Providing both <code>included_methods</code> and <code>deleted_methods</code> will result in a ValueError.</p> <p>Full Changelog: View the full changelog</p>"},{"location":"changelog/#021-jan-27-2024","title":"[0.2.1] - Jan 27, 2024","text":""},{"location":"changelog/#whats-changed_28","title":"What's Changed","text":"<ul> <li>Improved type hints across the codebase, enhancing the clarity and reliability of type checking within FastCRUD.</li> <li>Documentation has been thoroughly updated and refined, including fixes for previous inaccuracies and the addition of more detailed explanations and examples.</li> <li>Descriptions have been added to automatically generated endpoints, making the API documentation more informative and user-friendly.</li> </ul> <p>Full Changelog: View the full changelog</p>"},{"location":"changelog/#020-jan-25-2024","title":"[0.2.0] - Jan 25, 2024","text":""},{"location":"changelog/#added_30","title":"Added","text":"<ul> <li>Docs Published!</li> </ul>"},{"location":"changelog/#015-jan-24-2024","title":"[0.1.5] - Jan 24, 2024","text":"<p>Readme updates, pyproject requirements</p>"},{"location":"changelog/#012-jan-23-2024","title":"[0.1.2] - Jan 23, 2024","text":"<p>First public release.</p>"},{"location":"community/","title":"Discord Community","text":"<p>Connect with fellow developers, get support, and stay updated on the latest FastCRUD developments in our Discord community.</p>"},{"location":"community/#join-the-server","title":"Join the Server","text":"<p>Join our Discord community where developers gather to discuss FastAPI, CRUD operations, and modern web development.</p> <p>Join the FastCRUD Discord Server</p>"},{"location":"community/#community-channels","title":"Community Channels","text":"<p>Our Discord server includes several channels to help you connect, learn, and share:</p>"},{"location":"community/#knowledge-sharing","title":"Knowledge Sharing","text":"<ul> <li>Get help with FastCRUD implementation</li> <li>Share best practices and tips</li> <li>Discuss FastAPI patterns and techniques</li> </ul>"},{"location":"community/#networking","title":"Networking","text":"<ul> <li>Connect with other FastAPI developers</li> <li>Find collaboration opportunities</li> <li>Build your professional network</li> </ul>"},{"location":"community/#project-showcase","title":"Project Showcase","text":"<ul> <li>Share your FastCRUD-powered projects</li> <li>Get feedback from the community</li> <li>Inspire others with your work</li> </ul>"},{"location":"community/#announcements","title":"Announcements","text":"<ul> <li>First to know about new releases</li> <li>Important updates and changes</li> <li>Community events and initiatives</li> </ul>"},{"location":"community/#general-discussion","title":"General Discussion","text":"<ul> <li>Casual conversations</li> <li>Off-topic discussions</li> <li>Community building</li> </ul>"},{"location":"community/#voice-channels","title":"Voice Channels","text":"<ul> <li>Real-time collaboration</li> <li>Community voice chats</li> <li>Live coding sessions</li> </ul>"},{"location":"community/#getting-started","title":"Getting Started","text":"<ol> <li>Join the Server: Click the Discord invite link above</li> <li>Read the Welcome: Check out the welcome message and server rules</li> <li>Introduce Yourself: Tell us about your background and interests</li> <li>Explore Channels: Browse the various channels to find your interests</li> <li>Ask Questions: Don't hesitate to ask for help or advice</li> </ol>"},{"location":"community/#community-benefits","title":"Community Benefits","text":"<ul> <li>Direct Support: Get help directly from the FastCRUD team and community experts</li> <li>Early Access: Be among the first to hear about new features and updates</li> <li>Networking: Connect with developers from around the world</li> <li>Learning: Learn from real-world use cases and implementations</li> <li>Contributing: Find opportunities to contribute to the project</li> </ul>"},{"location":"community/#quick-links","title":"Quick Links","text":"<ul> <li>Discord Server</li> <li>FastCRUD Documentation</li> <li>GitHub Repository</li> <li>Benav Labs</li> </ul> <p>We believe in building an inclusive, welcoming community where developers of all skill levels can learn, share, and grow together.</p>"},{"location":"showcase/","title":"Showcase","text":"<p>Categories</p> <p>Browse by type: Applications \u00b7 Tutorials</p>"},{"location":"showcase/#applications","title":"Applications","text":"<p>FastroAI</p> <p>By Benav Labs \u00b7 Product \u00b7 Documentation</p> <p>Complete AI stack: FastAPI + AstroJS + PydanticAI. Auth, payments, AI agents pre-built. Save months of development time building profitable AI applications with everything included: authentication, billing, AI infrastructure, and deployment ready components.</p> <p>Features: PydanticAI integration, JWT + OAuth 2.0, Stripe payments, tier-based access control, full-stack ready, production monitoring</p> <p><code>AI Applications</code> <code>PydanticAI</code> <code>Commercial</code> <code>Full Stack</code> <code>Revenue Ready</code></p>"},{"location":"showcase/#open-source","title":"Open Source","text":"<p>CRUDAdmin</p> <p>By Benav Labs \u00b7 Source \u00b7 Documentation</p> <p>Modern admin interface for FastAPI with built-in authentication, event tracking, and security features. Built with FastCRUD and HTMX, it helps you create production-ready admin panels with minimal configuration.</p> <p>Features: Multi-backend session management, CSRF protection, rate limiting, audit logs, auto-generated interface, advanced filtering, responsive UI</p> <p><code>Admin Interface</code> <code>Authentication</code> <code>Security</code> <code>HTMX</code> <code>Production Ready</code></p> <p>FastAPI Boilerplate</p> <p>By Benav Labs \u00b7 Source</p> <p>FastAPI boilerplate creates an extendable async API using FastAPI, Pydantic V2, SQLAlchemy 2.0 and PostgreSQL.</p> <p><code>Template</code> <code>FastAPI</code> <code>Boilerplate</code></p> <p>SQLModel Boilerplate</p> <p>By Benav Labs \u00b7 Source</p> <p>SQLModel boilerplate creates an extendable async API using FastAPI, SQLModel and PostgreSQL.</p> <p><code>Template</code> <code>SQLModel</code> <code>Boilerplate</code></p>"},{"location":"showcase/#tutorials","title":"Tutorials","text":"<p>Creating LLM Powered APIs with FastAPI</p> <p>By Benav Labs \u00b7 View Tutorial</p> <p>Learn the basics of creating LLM powered APIs with FastCRUD.</p> <p><code>FastAPI</code> <code>AI</code> <code>Beginner</code> <code>LLM</code></p> <p>Add Your Project</p> <p>Built something with FastCRUD? We'd love to showcase it!</p> <p>Submit Your Project</p>"},{"location":"why-fastcrud/","title":"Why FastCRUD?","text":"<p>When, how, and why to choose FastCRUD for your FastAPI applications.</p> <p>You've found FastCRUD. Maybe you're tired of writing the same CRUD code over and over. Maybe you want a clean repository pattern without the boilerplate. Maybe you're just curious what this library actually does.</p> <p>This is an honest discussion about the problems FastCRUD solves and when it makes sense for your project.</p>"},{"location":"why-fastcrud/#the-problems-we-actually-face","title":"The Problems We Actually Face","text":"<p>Building APIs with FastAPI and SQLAlchemy is powerful, but it comes with two distinct pain points that hit different developers at different times:</p>"},{"location":"why-fastcrud/#problem-1-the-boilerplate-explosion","title":"Problem 1: The Boilerplate Explosion","text":"<p>Every model needs the same operations. Every endpoint follows the same pattern. Here's what you need to write for get, get_multi, create, update, delete - for each model:</p> Without FastCRUDWith FastCRUD <pre><code>@app.get(\"/users\")\nasync def get_users(\n    db: AsyncSession = Depends(get_session),\n    skip: int = 0,\n    limit: int = 100,\n    name: Optional[str] = None,\n    email: Optional[str] = None,\n    created_after: Optional[datetime] = None,\n    sort_by: str = \"created_at\",\n    sort_order: str = \"desc\"\n):\n    query = select(User)\n\n    # Manual filtering\n    if name:\n        query = query.where(User.name.ilike(f\"%{name}%\"))\n    if email:\n        query = query.where(User.email == email)\n    if created_after:\n        query = query.where(User.created_at &gt;= created_after)\n\n    # Manual sorting\n    if sort_order == \"desc\":\n        query = query.order_by(desc(getattr(User, sort_by)))\n    else:\n        query = query.order_by(getattr(User, sort_by))\n\n    # Manual pagination\n    query = query.offset(skip).limit(limit)\n\n    result = await db.execute(query)\n    users = result.scalars().all()\n\n    return [UserResponse.model_validate(user) for user in users]\n\n@app.post(\"/users\")\nasync def create_user():\n    # ... another 15-20 lines of manual validation and creation\n\n@app.get(\"/users/{user_id}\")\nasync def get_user():\n    # ... another 10-15 lines\n\n@app.patch(\"/users/{user_id}\")\nasync def update_user():\n    # ... another 20-25 lines\n\n@app.delete(\"/users/{user_id}\")\nasync def delete_user():\n    # ... another 10-15 lines\n</code></pre> <pre><code>user_router = crud_router(\n    session=get_session,\n    model=User,\n    create_schema=CreateUserSchema,\n    update_schema=UpdateUserSchema,\n    path=\"/users\",\n    tags=[\"Users\"]\n)\napp.include_router(user_router)\n</code></pre> <p>The FastCRUD version gives you filtering, sorting, pagination, and all CRUD operations automatically. Not everyone needs automatic endpoints, though.</p>"},{"location":"why-fastcrud/#problem-2-the-repository-pattern-overhead","title":"Problem 2: The Repository Pattern Overhead","text":"<p>Maybe you don't want automatic endpoints. Maybe you have complex business logic. You still need a clean way to access your data without writing the same queries repeatedly.</p> <p>Traditional repository pattern means writing interfaces and implementations for every model:</p> Traditional RepositoryFastCRUD Repository <pre><code># The interface\nclass IUserRepository(ABC):\n    @abstractmethod\n    async def get_by_email(self, email: str) -&gt; Optional[User]: ...\n\n    @abstractmethod\n    async def get_active_users(self, limit: int) -&gt; List[User]: ...\n\n    @abstractmethod\n    async def search_users(self, name: str) -&gt; List[User]: ...\n\n# The implementation\nclass UserRepository(IUserRepository):\n    def __init__(self, db: AsyncSession):\n        self.db = db\n\n    async def get_by_email(self, email: str) -&gt; Optional[User]:\n        result = await self.db.execute(select(User).where(User.email == email))\n        return result.scalar_one_or_none()\n\n    async def get_active_users(self, limit: int) -&gt; List[User]:\n        result = await self.db.execute(\n            select(User).where(User.is_active == True).limit(limit)\n        )\n        return result.scalars().all()\n\n    async def search_users(self, name: str) -&gt; List[User]:\n        result = await self.db.execute(\n            select(User).where(User.name.ilike(f\"%{name}%\"))\n        )\n        return result.scalars().all()\n</code></pre> <pre><code># You automatically get get_multi, get, create, update, delete, etc.\ncrud_users = FastCRUD(User)\n</code></pre> <p>FastCRUD gives you a pre-built repository with advanced features like filtering operators (<code>name__icontains</code>), joins, and pagination. You focus on domain-specific methods, not query construction.</p>"},{"location":"why-fastcrud/#what-fastcrud-actually-gives-you","title":"What FastCRUD Actually Gives You","text":"<p>Beyond eliminating boilerplate, FastCRUD gives you features you don't even know you'll need - thoroughly tested and maintained. Here are three that take a lot of time and effort to keep reimplementing and maintaining across different codebases:</p> <p>Advanced filtering with 20+ operators. Instead of writing manual <code>WHERE</code> clauses for every search field, you get Django-style filtering that works across relationships:</p> <pre><code>users = await user_crud.get_multi(\n    db,\n    created_at__gte=last_week,        # Greater than or equal\n    tier__name__in=[\"pro\", \"enterprise\"],  # Joined model filtering\n    email__icontains=\"@company.com\",  # Case-insensitive search\n    is_active=True                    # Simple equality\n)\n</code></pre> <p>Automatic joins with proper nesting. No more writing complex join logic or dealing with flat, denormalized results. FastCRUD detects relationships and gives you properly nested objects:</p> <pre><code>users = await user_crud.get_multi_joined(\n    db,\n    joins_config=[\n        JoinConfig(model=Profile, join_prefix=\"profile_\"),\n        JoinConfig(model=Order, join_prefix=\"orders_\", relationship_type=\"one-to-many\")\n    ],\n    nest_joins=True\n)\n# Returns: [{\"id\": 1, \"name\": \"John\", \"profile\": {...}, \"orders\": [{...}, {...}]}]\n</code></pre> <p>Cursor-based pagination for large datasets. Offset pagination falls apart after page 1000 - it gets slower and slower. Cursor pagination stays fast regardless of dataset size, which is crucial for infinite scroll interfaces:</p> <pre><code>result = await user_crud.get_multi_by_cursor(\n    db,\n    cursor=last_seen_id,\n    limit=50,\n    sort_columns=[\"created_at\"]\n)\n</code></pre> <p>These features come with built-in optimizations - no N+1 queries, protection against SQL injection, and performance that stays consistent even with large datasets.</p> <p>Most teams start with <code>crud_router</code> for basic models - users, products, categories - to get automatic endpoints quickly. As the application grows, they replace specific endpoints with custom business logic while keeping the standard operations automated.</p> <p>A typical e-commerce API might use FastCRUD for product catalog management and user administration, but write custom SQLAlchemy for complex inventory calculations or recommendation algorithms. The accounting system uses automatic CRUD for managing vendors and invoices, but implements custom logic for financial reporting and tax calculations.</p> <p>This mixed approach works because you're not forced to choose one pattern for everything. FastCRUD handles the repetitive database access while you focus on the domain-specific complexity that actually matters for your business.</p>"},{"location":"why-fastcrud/#how-fastcrud-actually-works","title":"How FastCRUD Actually Works","text":"<p>FastCRUD gives you three levels of abstraction that work together:</p> <pre><code>graph TB\n    A[crud_router] --&gt; B[FastCRUD Class]\n    B --&gt; C[SQLAlchemy]\n\n    A --&gt; D[\"Automatic Endpoints&lt;br/&gt;Zero Code\"]\n    B --&gt; E[\"Repository Pattern&lt;br/&gt;Custom Logic\"]\n    C --&gt; F[\"Raw Queries&lt;br/&gt;Maximum Control\"]\n</code></pre> <p>You can use any combination. Most projects end up using all three for different scenarios.</p> Scenario Use This Why Admin panels, internal tools <code>crud_router</code> Need full CRUD quickly, minimal customization Standard API endpoints <code>crud_router</code> Consistent patterns, automatic documentation Custom business logic <code>FastCRUD</code> class Need validation, workflows, but want advanced features Complex domain operations <code>FastCRUD</code> + custom code Mix repository pattern with specialized queries Performance-critical queries Raw SQLAlchemy Hand-optimized for specific requirements Complex aggregations Raw SQLAlchemy Reporting queries that don't fit CRUD patterns <p>Most applications use a mix. <code>crud_router</code> for simple models, <code>FastCRUD</code> class for business logic, raw SQLAlchemy for complex queries.</p>"},{"location":"why-fastcrud/#when-fastcrud-isnt-the-right-tool","title":"When FastCRUD Isn't the Right Tool","text":"<p>Not every project is a good fit for FastCRUD. Adding it comes with real trade-offs. The Django-style filtering syntax (<code>__gt</code>, <code>__in</code>, <code>__between</code>) is different from raw SQLAlchemy - your team needs time to learn it. There's an abstraction layer between your code and the database, which usually doesn't matter for performance but adds complexity when debugging query issues. You're also adding a dependency with its own update cycle.</p> <p>But most teams find these trade-offs acceptable for the productivity gains, especially since you can always drop down to raw SQLAlchemy when you need complete control. The key is thinking through your specific situation systematically:</p> <pre><code>graph TD\n    A[Your Project] --&gt; B{Mostly standard CRUD?}\n    B --&gt;|Yes| C[Great fit - use crud_router]\n    B --&gt;|Mixed| D{Performance critical?}\n    B --&gt;|No| E[Poor fit - use selectively]\n\n    D --&gt;|Yes| F[Use selectively for non-critical parts]\n    D --&gt;|No| G[Good fit - start with FastCRUD]\n\n    C --&gt; H[Expand gradually as needed]\n    G --&gt; H\n    F --&gt; I[FastCRUD for admin, custom SQL for core]\n    E --&gt; I\n\n    H --&gt; J[Drop to custom code when FastCRUD doesn't fit]\n    I --&gt; J</code></pre> <p>Start small and expand gradually. Pick a simple model - users, products, categories - and implement it with <code>crud_router</code>. See how it feels. Check the generated OpenAPI docs. Run some queries and see if performance is acceptable.</p> <p>Think like an engineer. Even if your application seems like a poor fit overall, FastCRUD might help with parts of it. That analytics platform still needs user management. The performance-critical trading system probably has configuration tables. Use the right tool for each specific problem.</p>"},{"location":"why-fastcrud/#project-fit-analysis","title":"Project Fit Analysis","text":"<p>Different project types benefit differently from FastCRUD. Here's what we've seen work well and what doesn't:</p> Project Type FastCRUD Fit Why Modular monoliths Excellent Consistent patterns across modules, shared infrastructure Admin dashboards Excellent Standard CRUD with filtering, minimal custom logic REST APIs Very good Consistent endpoints, pagination, OpenAPI docs Microservices Very good Each service has focused CRUD operations Analytics platforms Mixed Good for user/config management, poor for reporting queries Workflow engines Poor State transitions, complex business rules High-frequency trading Poor Hand-optimized queries, microsecond performance <p>Most applications fall somewhere in the middle. You have standard user management, product catalogs, order processing alongside specialized business logic. FastCRUD handles the standard parts while you write custom code for the complex domain-specific operations.</p> <p>When to rethink FastCRUD</p> <p>Analytics Applications - Complex aggregations don't fit CRUD patterns, but user/config management does</p> <p>Performance-Critical Systems - Core queries need optimization, but admin interfaces can use FastCRUD</p> <p>Explicit-Everything Teams - May prefer custom code, but can use FastCRUD for rapid prototyping</p> <p>Domain-Driven Design - Complex aggregates need custom code, but simple entities work fine</p> <p>Non-CRUD APIs - Main workflows don't benefit, but supporting data operations do</p> <p>Even in these scenarios, FastCRUD might still help with parts of your application. That analytics platform still needs user management. The performance-critical trading system probably has configuration tables. Think like an engineer - use the right tool for each specific problem, not an all-or-nothing approach.</p>"},{"location":"why-fastcrud/#growing-with-your-project","title":"Growing With Your Project","text":"<p>You don't have to architect everything perfectly from day one. FastCRUD lets you start simple and evolve your approach as requirements become clearer.</p>"},{"location":"why-fastcrud/#start-simple-get-it-working","title":"Start Simple: Get It Working","text":"<p>When you're building an MVP or just getting started, use <code>crud_router</code> for everything. Your entire API becomes a few lines of code:</p> <pre><code># Three files get you a complete API\n# models.py - Your SQLAlchemy models\n# schemas.py - Your Pydantic schemas  \n# main.py - Everything else\n\nuser_router = crud_router(session=get_session, model=User, ...)\nproduct_router = crud_router(session=get_session, model=Product, ...)\norder_router = crud_router(session=get_session, model=Order, ...)\n\napp.include_router(user_router)\napp.include_router(product_router)\napp.include_router(order_router)\n</code></pre> <p>This gets you automatic CRUD endpoints, filtering, pagination, and OpenAPI documentation. Great for validating your idea quickly.</p>"},{"location":"why-fastcrud/#add-business-logic-when-you-need-it","title":"Add Business Logic When You Need It","text":"<p>As your application grows, business requirements emerge that don't fit standard CRUD patterns. Maybe order creation needs inventory validation and confirmation emails. Instead of replacing everything, you just add custom endpoints while keeping the automatic ones:</p> <pre><code>@app.post(\"/orders/\")\nasync def create_order(order_data: OrderCreateSchema, db: AsyncSession = Depends(get_session)):\n    order_crud = FastCRUD(Order)\n\n    # Custom business logic\n    if not await validate_inventory(order_data.items):\n        raise HTTPException(400, \"Insufficient inventory\")\n\n    # Still use FastCRUD for reliable database operations\n    order = await order_crud.create(db, order_data)\n\n    # More custom logic\n    await send_order_confirmation(order)\n\n    return order\n</code></pre> <p>Your simple endpoints like user management keep working unchanged. You only customize what needs custom behavior.</p>"},{"location":"why-fastcrud/#extract-services-for-complex-logic","title":"Extract Services for Complex Logic","text":"<p>When your custom endpoints start getting complicated, move the business logic to service classes. FastCRUD stays as your data access layer:</p> <pre><code>class OrderService:\n    def __init__(self):\n        self.order_crud = FastCRUD(Order)\n        self.inventory_service = InventoryService()\n\n    async def create_order(self, db: AsyncSession, order_data: OrderCreateSchema):\n        await self.inventory_service.reserve_items(order_data.items)\n        order = await self.order_crud.create(db, order_data)\n        await self.send_confirmation_email(order)\n        return order\n\n# Your endpoints stay clean\n@app.post(\"/orders/\")\nasync def create_order(order_data: OrderCreateSchema, db: AsyncSession = Depends(get_session)):\n    service = OrderService()\n    return await service.create_order(db, order_data)\n</code></pre> <p>This gives you clean separation - business logic in services, data access through FastCRUD, HTTP handling in endpoints.</p>"},{"location":"why-fastcrud/#add-domain-repositories-for-complex-queries","title":"Add Domain Repositories for Complex Queries","text":"<p>For sophisticated domains, wrap FastCRUD in repositories that expose domain-specific operations:</p> <pre><code>class UserRepository:\n    def __init__(self):\n        self.crud = FastCRUD(User)\n\n    async def find_enterprise_admins(self, db: AsyncSession) -&gt; List[User]:\n        return await self.crud.get_multi_joined(\n            db,\n            joins_config=[JoinConfig(model=Company, join_prefix=\"company_\")],\n            role=\"admin\",\n            company__tier=\"enterprise\"\n        )\n</code></pre> <p>Each step builds naturally on the previous one. You start with automatic endpoints, add custom logic where needed, organize complex behavior into services, and create domain-specific interfaces for sophisticated queries. You never throw away working code - you just add layers when they provide value.</p> <p>Ready to see it in action? </p>          Get Started with FastCRUD \u2192"},{"location":"advanced/crud/","title":"Advanced Use of FastCRUD","text":"<p>FastCRUD offers a flexible and powerful approach to handling CRUD operations in FastAPI applications, leveraging the SQLAlchemy ORM. Beyond basic CRUD functionality, FastCRUD provides advanced features like <code>allow_multiple</code> for updates and deletes, and support for advanced filters (e.g., less than, greater than). These features enable more complex and fine-grained data manipulation and querying capabilities.</p>"},{"location":"advanced/crud/#typing-options-for-fastcrud","title":"Typing Options for <code>FastCRUD</code>","text":"<p>Note that when initializing <code>FastCRUD</code>, assuming you have a model like:</p> Simplified <code>user/model.py</code> <pre><code>from sqlalchemy import (\n    Boolean,\n    Column,\n    DateTime,\n    ForeignKey,\n    Integer,\n    String,\n    func,\n)\nfrom sqlalchemy.orm import DeclarativeBase\n\n\nclass Base(DeclarativeBase):\n    pass\n\n\nclass User(Base):\n    __tablename__ = \"user\"\n    id = Column(Integer, primary_key=True)\n    name = Column(String)\n</code></pre> <p>Warning</p> <p>Note that naive <code>datetime</code> such as <code>datetime.utcnow</code> is not supported by <code>FastCRUD</code> as it was deprecated.</p> <p>Use timezone aware <code>datetime</code>, such as <code>datetime.now(UTC)</code> instead.</p> <p>You could just pass it to <code>FastCRUD</code>:</p> <pre><code>from fastcrud import FastCRUD\n\nuser_crud = FastCRUD(User)\n</code></pre> <p>But you also may want a more robust typing, for that purpose, you may also pass the relevant pydantic schemas in the following way:</p> Simplified <code>user/schemas.py</code> <pre><code>import datetime\n\nfrom pydantic import BaseModel\n\n\nclass CreateUserSchema(BaseModel):\n    name: str | None = None\n\n\nclass ReadUserSchema(BaseModel):\n    id: int\n    name: str | None = None\n\n\nclass UpdateUserSchema(BaseModel):\n    name: str | None = None\n\n\nclass DeleteUserSchema(BaseModel):\n    pass\n</code></pre> <pre><code>from .user.model import User\nfrom .user.schemas import CreateUserSchema, ReadUserSchema, UpdateUserSchema, DeleteUserSchema\n\n# Just pass None if you don't have one of the schemas\nUserCRUD = FastCRUD[User, CreateUserSchema, UpdateUserSchema, None, DeleteUserSchema]\n</code></pre> <p>Then you can initialize <code>UserCRUD</code> like you would any <code>FastCRUD</code> instance, but with the relevant types:</p> <pre><code>from .user.model import User\n\nuser_crud = UserCRUD(User)\n</code></pre>"},{"location":"advanced/crud/#allow-multiple-updates-and-deletes","title":"Allow Multiple Updates and Deletes","text":"<p>One of FastCRUD's advanced features is the ability to update or delete multiple records at once based on specified conditions. This is particularly useful for batch operations where you need to modify or remove several records that match certain criteria.</p>"},{"location":"advanced/crud/#updating-multiple-records","title":"Updating Multiple Records","text":"<p>To update multiple records, you can set the <code>allow_multiple=True</code> parameter in the <code>update</code> method. This allows FastCRUD to apply the update to all records matching the given filters.</p> <pre><code># Assuming setup for FastCRUD instance `item_crud` and SQLAlchemy async session `db`\n\n# Update all items priced below $10 to a new price\nawait item_crud.update(\n    db=db,\n    object={\"price\": 9.99},\n    allow_multiple=True,\n    price__lt=10,\n)\n</code></pre>"},{"location":"advanced/crud/#deleting-multiple-records","title":"Deleting Multiple Records","text":"<p>Similarly, you can delete multiple records by using the <code>allow_multiple=True</code> parameter in the <code>delete</code> or <code>db_delete</code> method, depending on whether you're performing a soft or hard delete.</p> <pre><code># Soft delete all items not sold in the last year\nawait item_crud.delete(\n    db=db,\n    allow_multiple=True,\n    last_sold__lt=datetime.datetime.now() - datetime.timedelta(days=365),\n)\n</code></pre>"},{"location":"advanced/crud/#advanced-filters","title":"Advanced Filters","text":"<p>FastCRUD supports advanced filtering options, allowing you to query records using operators such as greater than (<code>__gt</code>), less than (<code>__lt</code>), and their inclusive counterparts (<code>__gte</code>, <code>__lte</code>). These filters can be used in any method that retrieves or operates on records, including <code>get</code>, <code>get_multi</code>, <code>exists</code>, <code>count</code>, <code>update</code>, and <code>delete</code>.</p>"},{"location":"advanced/crud/#single-parameter-filters","title":"Single parameter filters","text":"<p>Most filter operators require a single string or integer value.</p> <pre><code># Fetch items priced between above $5\nitems = await item_crud.get_multi(\n    db=db,\n    price__gte=5,\n)\n</code></pre> <p>Currently supported single parameter filters are:</p> <ul> <li><code>__gt</code> - greater than</li> <li><code>__lt</code> - less than</li> <li><code>__gte</code> - greater than or equal to</li> <li><code>__lte</code> - less than or equal to</li> <li><code>__ne</code> - not equal</li> <li><code>__is</code> - used to test True, False and None identity</li> <li><code>__is_not</code> - negation of \"is\"</li> <li><code>__like</code> - SQL \"like\" search for specific text pattern</li> <li><code>__notlike</code> - negation of \"like\"</li> <li><code>__ilike</code> - case insensitive \"like\"</li> <li><code>__notilike</code> - case insensitive \"notlike\"</li> <li><code>__startswith</code> - text starts with given string</li> <li><code>__endswith</code> - text ends with given string</li> <li><code>__contains</code> - text contains given string</li> <li><code>__match</code> - database-specific match expression</li> </ul>"},{"location":"advanced/crud/#complex-parameter-filters","title":"Complex parameter filters","text":"<p>Some operators require multiple values. They must be passed as a python tuple, list or set.</p> <pre><code># Fetch items priced between $5 and $20\nitems = await item_crud.get_multi(\n    db=db,\n    price__between=(5, 20),\n)\n</code></pre> <ul> <li><code>__between</code> - between 2 numeric values</li> <li><code>__in</code> - included in</li> <li><code>__not_in</code> - not included in</li> </ul>"},{"location":"advanced/crud/#or-clauses","title":"OR clauses","text":"<p>More complex OR filters are supported. They must be passed as dictionary, where each key is a library-supported operator to be used in OR expression and values is what get's passed as the parameter.</p> <pre><code># Fetch items priced under $5 or above $20\nitems = await item_crud.get_multi(\n    db=db,\n    price__or={'lt': 5, 'gt': 20},\n)\n</code></pre>"},{"location":"advanced/crud/#and-clauses","title":"AND clauses","text":"<p>AND clauses can be achieved by chaining multiple filters together.</p> <pre><code># Fetch items priced under $20 and over 2 years of warranty.\nitems = await item_crud.get_multi(\n    db=db,\n    price__lt=20,\n    warranty_years__gt=2,\n)\n</code></pre>"},{"location":"advanced/crud/#counting-records","title":"Counting Records","text":"<pre><code># Count items created in the last month\nitem_count = await item_crud.count(\n    db=db,\n    created_at__gte=datetime.datetime.now() - datetime.timedelta(days=30),\n)\n</code></pre>"},{"location":"advanced/crud/#skipping-database-commit","title":"Skipping Database Commit","text":"<p>For <code>create</code>, <code>update</code>, <code>db_delete</code> and <code>delete</code> methods of <code>FastCRUD</code>, you have the option of passing <code>commit=False</code> so you don't commit the operations immediately.</p> <pre><code>from fastcrud import FastCRUD\n\nfrom .database import session as db\nfrom .item.model import Item\n\nitem_crud = FastCRUD(Item)\n\nawait item_crud.delete(\n    db=db, \n    commit=False, \n    id=1,\n)\n# this will not actually delete until you run a db.commit()\n</code></pre>"},{"location":"advanced/crud/#returning-clause-in-update","title":"Returning clause in <code>update</code>","text":"<p>In <code>update</code> method, you can pass <code>return_columns</code> parameter containing a list of columns you want to return after the update.</p> <pre><code>from fastcrud import FastCRUD\n\nfrom .database import session as db\nfrom .item.model import Item\n\nitem_crud = FastCRUD(Item)\n\nitem = await item_crud.update(\n    db=db,\n    object={\"price\": 9.99},\n    return_columns=[\"price\"],\n    price__lt=10,\n)\n# this will return the updated price\n</code></pre> <p>You can also pass <code>schema_to_select</code> parameter and <code>return_as_model</code> to return the updated data in the form of a Pydantic schema.</p> <pre><code>from fastcrud import FastCRUD\n\nfrom .database import session as db\nfrom .item.model import Base, Item\nfrom .item.schemas import ItemSchema\n\nitem_crud = FastCRUD(Item)\n\nitem = await item_crud.update(\n    db=db,\n    object={\"price\": 9.99},\n    schema_to_select=ItemSchema,\n    return_as_model=True,\n    price__lt=10,\n)\n# this will return the updated data in the form of ItemSchema\n</code></pre>"},{"location":"advanced/crud/#unpaginated-get_multi-and-get_multi_joined","title":"Unpaginated <code>get_multi</code> and <code>get_multi_joined</code>","text":"<p>If you pass <code>None</code> to <code>limit</code> in <code>get_multi</code> and <code>get_multi_joined</code>, you get the whole unpaginated set of data that matches the filters. Use this with caution.</p> <pre><code>from fastcrud import FastCRUD\n\nfrom .database import session as db\nfrom .item.model import Item\n\nitem_crud = FastCRUD(Item)\n\nitems = await item_crud.get_multi(db=db, limit=None)\n# this will return all items in the db\n</code></pre> <p>Caution</p> <p>Be cautious when returning all the data in your database, and you should almost never allow your user API to do this.</p>"},{"location":"advanced/crud/#using-get_joined-and-get_multi_joined-for-multiple-models","title":"Using <code>get_joined</code> and <code>get_multi_joined</code> for multiple models","text":"<p>To facilitate complex data relationships, <code>get_joined</code> and <code>get_multi_joined</code> can be configured to handle joins with multiple models. This is achieved using the <code>joins_config</code> parameter, where you can specify a list of <code>JoinConfig</code> instances, each representing a distinct join configuration.</p> <p>Additionally, <code>get_multi_joined</code> supports counting related objects using the <code>counts_config</code> parameter with <code>CountConfig</code> instances. This allows you to efficiently get counts of related objects (like counting participants per project) without fetching the actual related data.</p> <p>For detailed examples and usage patterns, see the joins documentation.</p>"},{"location":"advanced/crud/#upserting-multiple-records-using-upsert_multi","title":"Upserting multiple records using <code>upsert_multi</code>","text":"<p>FastCRUD provides an <code>upsert_multi</code> method to efficiently upsert multiple records in a single operation. This method is particularly useful when you need to insert new records or update existing ones based on a unique constraint.</p> <p>Return Types: - When <code>return_as_model=True</code> and <code>schema_to_select</code> is provided: <code>UpsertMultiResponseModel[SelectSchemaType]</code> (i.e., <code>Dict[str, List[SelectSchemaType]]</code>) - When <code>return_as_model=False</code>: <code>UpsertMultiResponseDict</code> (i.e., <code>Dict[str, List[Dict[str, Any]]]</code>)</p> <p>Usage Examples:</p> <p>Upsert multiple records and return as dictionaries: <pre><code>from fastcrud import FastCRUD\n\nfrom .database import session as db\nfrom .item.model import Item\nfrom .item.schemas import CreateItemSchema\n\nitem_crud = FastCRUD(Item)\nitems = await item_crud.upsert_multi(\n    db=db,\n    instances=[\n        CreateItemSchema(price=9.99),\n    ],\n)\n# Returns: {\"upserted\": [Dict[str, Any], ...]}\n</code></pre></p> <p>Upsert multiple records and return as typed Pydantic models: <pre><code>from fastcrud import FastCRUD\n\nfrom .database import session as db\nfrom .item.model import Item\nfrom .item.schemas import CreateItemSchema, ItemSchema\n\nitem_crud = FastCRUD(Item)\nitems = await item_crud.upsert_multi(\n    db=db,\n    instances=[\n        CreateItemSchema(price=9.99),\n    ],\n    schema_to_select=ItemSchema,\n    return_as_model=True,\n)\n# Returns: {\"upserted\": [ItemSchema, ...]}\n</code></pre></p>"},{"location":"advanced/crud/#customizing-the-update-logic","title":"Customizing the Update Logic","text":"<p>To allow more granular control over the SQL <code>UPDATE</code> operation during an upsert, <code>upsert_multi</code> can accept an <code>update_override</code> argument. This allows for the specification of custom update logic using SQL expressions, like the <code>case</code> statement, to handle complex conditions.</p> <pre><code>from sqlalchemy.sql import case\n\nupdate_override = {\n    \"name\": case(\n        (Item.name.is_(None), stmt.excluded.name),\n        else_=Item.name\n    )\n}\n\nitems = await item_crud.upsert_multi(\n    db=db,\n    instances=[\n        CreateItemSchema(name=\"Gadget\", price=15.99),\n    ],\n    update_override=update_override,\n    schema_to_select=ItemSchema,\n    return_as_model=True,\n)\n</code></pre> <p>In the example above, the <code>name</code> field of the <code>Item</code> model will be updated to the new value only if the existing <code>name</code> field is <code>None</code>. Otherwise, it retains the existing <code>name</code>.</p>"},{"location":"advanced/crud/#example-joining-user-tier-and-department-models","title":"Example: Joining <code>User</code>, <code>Tier</code>, and <code>Department</code> Models","text":"<p>Consider a scenario where you want to retrieve users along with their associated tier and department information. Here's how you can achieve this using <code>get_multi_joined</code>.</p> <p>Start by creating the models and schemas, followed by a description of how they're to be joined:</p> Models and Schemas <code>tier/model.py</code> <pre><code>from sqlalchemy import Column, Integer, String\nfrom sqlalchemy.orm import DeclarativeBase\n\n\nclass Base(DeclarativeBase):\n    pass\n\n\nclass Tier(Base):\n    __tablename__ = \"tier\"\n    id = Column(Integer, primary_key=True)\n    name = Column(String, unique=True)\n</code></pre> <code>tier/schemas.py</code> <pre><code>from pydantic import BaseModel\n\n\nclass ReadTierSchema(BaseModel):\n    id: int\n    name: str | None = None\n</code></pre> <code>department/model.py</code> <pre><code>from sqlalchemy import Column, Integer, String\nfrom sqlalchemy.orm import DeclarativeBase\n\n\nclass Base(DeclarativeBase):\n    pass\n\n\nclass Department(Base):\n    __tablename__ = \"department\"\n    id = Column(Integer, primary_key=True)\n    name = Column(String)\n</code></pre> <code>department/schemas.py</code> <pre><code>from pydantic import BaseModel\n\n\nclass ReadDepartmentSchema(BaseModel):\n    id: int\n    name: str | None = None\n</code></pre> <code>user/model.py</code> <pre><code>from sqlalchemy import (\n    Boolean,\n    Column,\n    DateTime,\n    ForeignKey,\n    Integer,\n    String,\n    func,\n)\nfrom sqlalchemy.orm import DeclarativeBase\n\n\nclass Base(DeclarativeBase):\n    pass\n\n\nclass User(Base):\n    __tablename__ = \"user\"\n    id = Column(Integer, primary_key=True)\n    name = Column(String)\n    username = Column(String)\n    email = Column(String)\n    age = Column(Integer)\n    role = Column(String)\n    tier_id = Column(Integer, ForeignKey(\"tier.id\"))\n    department_id = Column(Integer, ForeignKey(\"department.id\"))\n    manager_id = Column(Integer, ForeignKey(\"user.id\"))\n    is_active = Column(Boolean, default=True)\n    is_superuser = Column(Boolean, default=False)\n    registration_date = Column(DateTime, default=func.now())\n    archived = Column(Boolean, default=False)\n    archived_at = Column(DateTime)\n</code></pre> <code>user/schemas.py</code> <pre><code>import datetime\n\nfrom pydantic import BaseModel\n\n\nclass CreateUserSchema(BaseModel):\n    name: str | None = None\n    username: str | None = None\n    email: str | None = None\n    age: int | None = None\n    role: str | None = None\n    tier_id: int | None = None\n    department_id: int | None = None\n    manager_id: int | None = None\n    is_active: bool | None = None\n    is_superuser: bool | None = None\n\n\nclass ReadUserSchema(BaseModel):\n    id: int\n    name: str | None = None\n    username: str | None = None\n    email: str | None = None\n    age: int | None = None\n    role: str | None = None\n    tier_id: int | None = None\n    department_id: int | None = None\n    manager_id: int | None = None\n    is_active: bool\n    is_superuser: bool\n    registration_date: datetime.datetime\n    archived: bool\n    archived_at: datetime.datetime | None = None\n\n\nclass UpdateUserSchema(BaseModel):\n    name: str | None = None\n    username: str | None = None\n    email: str | None = None\n    age: int | None = None\n    role: str | None = None\n    tier_id: int | None = None\n    department_id: int | None = None\n    manager_id: int | None = None\n    is_active: bool | None = None\n    is_superuser: bool | None = None\n\n\nclass DeleteUserSchema(BaseModel):\n    pass\n</code></pre> <code>story/model.py</code> <pre><code>from sqlalchemy import Column, Integer, String\nfrom sqlalchemy.orm import DeclarativeBase\n\n\nclass Base(DeclarativeBase):\n    pass\n\n\nclass Story(Base):\n    __tablename__ = \"story\"\n    id = Column(Integer, primary_key=True)\n    name = Column(String)\n</code></pre> <code>story/schemas.py</code> <pre><code>from pydantic import BaseModel\n\n\nclass CreateStorySchema(BaseModel):\n    name: str | None = None\n\n\nclass ReadStorySchema(BaseModel):\n    id: int\n    name: str | None = None\n\n\nclass UpdateStorySchema(BaseModel):\n    name: str | None = None\n\n\nclass DeleteStorySchema(BaseModel):\n    pass\n</code></pre> <code>task/model.py</code> <pre><code>from sqlalchemy import Column, ForeignKey, Integer, String\nfrom sqlalchemy.orm import DeclarativeBase\n\n\nclass Base(DeclarativeBase):\n    pass\n\n\nclass Task(Base):\n    __tablename__ = \"task\"\n    id = Column(Integer, primary_key=True)\n    creator_id = Column(Integer, ForeignKey(\"user.id\"))\n    owner_id = Column(Integer, ForeignKey(\"user.id\"))\n    assigned_user_id = Column(Integer, ForeignKey(\"user.id\"))\n    story_id = Column(Integer, ForeignKey(\"story.id\"))\n    status = Column(String)\n    priority = Column(String)\n</code></pre> <code>task/schemas.py</code> <pre><code>from pydantic import BaseModel\n\n\nclass CreateTaskSchema(BaseModel):\n    creator_id: int | None = None\n    owner_id: int | None = None\n    assigned_user_id: int | None = None\n    story_id: int | None = None\n    status: str | None = None\n    priority: str | None = None\n\n\nclass ReadTaskSchema(BaseModel):\n    id: int\n    creator_id: int | None = None\n    owner_id: int | None = None\n    assigned_user_id: int | None = None\n    story_id: int | None = None\n    status: str | None = None\n    priority: str | None = None\n\n\nclass UpdateTaskSchema(BaseModel):\n    creator_id: int | None = None\n    owner_id: int | None = None\n    assigned_user_id: int | None = None\n    story_id: int | None = None\n    status: str | None = None\n    priority: str | None = None\n\n\nclass DeleteTaskSchema(BaseModel):\n    pass\n</code></pre> Join Configurations<pre><code>from fastcrud import JoinConfig\n\njoins_config = [\n    JoinConfig(\n        model=Tier,\n        join_on=User.tier_id == Tier.id,\n        join_prefix=\"tier_\",\n        schema_to_select=ReadTierSchema,\n        join_type=\"left\",\n    ),\n\n    JoinConfig(\n        model=Department,\n        join_on=User.department_id == Department.id,\n        join_prefix=\"dept_\",\n        schema_to_select=ReadDepartmentSchema,\n        join_type=\"inner\",\n    ),\n]\n\nusers = await user_crud.get_multi_joined(\n    db=session,\n    schema_to_select=ReadUserSchema,\n    return_as_model=True,\n    offset=0,\n    limit=10,\n    sort_columns='username',\n    sort_orders='asc',\n    joins_config=joins_config,\n)\n</code></pre> <p>Return Types for <code>get_multi_joined</code>: - When <code>return_as_model=True</code> and <code>schema_to_select</code> is provided: <code>GetMultiResponseModel[SelectSchemaType]</code> (i.e., <code>Dict[str, Union[List[SelectSchemaType], int]]</code>) - When <code>return_as_model=False</code>: <code>GetMultiResponseDict</code> (i.e., <code>Dict[str, Union[List[Dict[str, Any]], int]]</code>)</p> <p>Then just pass this list to <code>joins_config</code>:</p> Passing to get_multi_joined<pre><code>from fastcrud import JoinConfig\n\njoins_config = [\n    ...\n]\n\nusers = await user_crud.get_multi_joined(\n    db=session,\n    schema_to_select=ReadUserSchema,\n    offset=0,\n    limit=10,\n    sort_columns='username',\n    sort_orders='asc',\n    joins_config=joins_config,\n)\n</code></pre> <p>In this example, users are joined with the <code>Tier</code> and <code>Department</code> models. The <code>join_on</code> parameter specifies the condition for the join, <code>join_prefix</code> assigns a prefix to columns from the joined models (to avoid naming conflicts), and <code>join_type</code> determines whether it's a left or inner join.</p> <p>Warning</p> <p>If both single join parameters and <code>joins_config</code> are used simultaneously, an error will be raised.</p>"},{"location":"advanced/crud/#handling-one-to-one-and-one-to-many-joins-in-fastcrud","title":"Handling One-to-One and One-to-Many Joins in FastCRUD","text":"<p>FastCRUD provides flexibility in handling one-to-one and one-to-many relationships through its <code>get_joined</code> and <code>get_multi_joined</code> methods, along with the ability to specify how joined data should be structured using both the <code>relationship_type</code> (default <code>one-to-one</code>) and the <code>nest_joins</code> (default <code>False</code>) parameters.</p>"},{"location":"advanced/crud/#one-to-one-joins","title":"One-to-One Joins","text":"<p>One-to-one relationships can be efficiently managed using either <code>get_joined</code> or <code>get_multi_joined</code>. The <code>get_joined</code> method is typically used when you want to fetch a single record from the database along with its associated record from another table, such as a user and their corresponding profile details. If you're retrieving multiple records, <code>get_multi_joined</code> can also be used for one-to-one joins. The parameter that deals with it, <code>relationship_type</code>, defaults to <code>one-on-one</code>.</p>"},{"location":"advanced/crud/#one-to-many-joins","title":"One-to-Many Joins","text":"<p>For one-to-many relationships, where a single record can be associated with multiple records in another table, <code>get_joined</code> can be used with <code>nest_joins</code> set to <code>True</code>. This setup allows the primary record to include a nested list of associated records, making it suitable for scenarios such as retrieving a user and all their blog posts. Alternatively, <code>get_multi_joined</code> is also applicable here for fetching multiple primary records, each with their nested lists of related records.</p> <p>Warning</p> <p>When using <code>nested_joins=True</code>, the performance will always be a bit worse than when using <code>nested_joins=False</code>. For cases where more performance is necessary, consider using <code>nested_joins=False</code> and remodeling your database.</p>"},{"location":"advanced/crud/#one-to-one-relationships","title":"One-to-One Relationships","text":"<ul> <li><code>get_joined</code>: Fetch a single record and its directly associated record (e.g., a user and their profile).</li> <li><code>get_multi_joined</code> (with <code>nest_joins=False</code>): Retrieve multiple records, each linked to a single related record from another table (e.g., users and their profiles).</li> </ul>"},{"location":"advanced/crud/#one-to-many-relationships","title":"One-to-Many Relationships","text":"<ul> <li><code>get_joined</code> (with <code>nest_joins=True</code>): Retrieve a single record with all its related records nested within it (e.g., a user and all their blog posts).</li> <li><code>get_multi_joined</code> (with <code>nest_joins=True</code>): Fetch multiple primary records, each with their related records nested (e.g., multiple users and all their blog posts).</li> </ul> <p>For a more detailed explanation, you may check the joins docs.</p>"},{"location":"advanced/crud/#using-aliases","title":"Using aliases","text":"<p>In complex query scenarios, particularly when you need to join a table to itself or perform multiple joins on the same table for different purposes, aliasing becomes crucial. Aliasing allows you to refer to the same table in different contexts with unique identifiers, avoiding conflicts and ambiguity in your queries.</p> <p>For both <code>get_joined</code> and <code>get_multi_joined</code> methods, when you need to join the same model multiple times, you can utilize the <code>alias</code> parameter within your <code>JoinConfig</code> to differentiate between the joins. This parameter expects an instance of <code>AliasedClass</code>, which can be created using the <code>aliased</code> function from SQLAlchemy (also in FastCRUD for convenience).</p>"},{"location":"advanced/crud/#example-joining-the-same-model-multiple-times","title":"Example: Joining the Same Model Multiple Times","text":"<p>Consider a task management application where tasks have both an owner and an assigned user, represented by the same <code>User</code> model. To fetch tasks with details of both users, we use aliases to join the <code>User</code> model twice, distinguishing between owners and assigned users.</p> <p>Let's start by creating the aliases and passing them to the join configuration. Don't forget to use the alias for <code>join_on</code>:</p> Join Configurations with Aliases<pre><code>from fastcrud import FastCRUD, JoinConfig, aliased\n\n# Create aliases for User to distinguish between the owner and the assigned user\nowner_alias = aliased(User, name=\"owner\")\nassigned_user_alias = aliased(User, name=\"assigned_user\")\n\n# Configure joins with aliases\njoins_config = [\n    JoinConfig(\n        model=User,\n        join_on=Task.owner_id == owner_alias.id,\n        join_prefix=\"owner_\",\n        schema_to_select=ReadUserSchema,\n        join_type=\"inner\",\n        alias=owner_alias,  # Pass the aliased class instance\n    ),\n    JoinConfig(\n        model=User,\n        join_on=Task.assigned_user_id == assigned_user_alias.id,\n        join_prefix=\"assigned_\",\n        schema_to_select=ReadUserSchema,\n        join_type=\"inner\",\n        alias=assigned_user_alias,  # Pass the aliased class instance\n    ),\n]\n\n# Initialize your FastCRUD instance for Task\ntask_crud = FastCRUD(Task)\n\n# Fetch tasks with joined user details\ntasks = await task_crud.get_multi_joined(\n    db=session,\n    schema_to_select=ReadTaskSchema,\n    offset=0,\n    limit=10,\n    joins_config=joins_config,\n)\n</code></pre> <p>Then just pass this <code>joins_config</code> to <code>get_multi_joined</code>:</p> Passing joins_config to get_multi_joined<pre><code>from fastcrud import FastCRUD, JoinConfig, aliased\n\n...\n\n# Configure joins with aliases\njoins_config = [\n    ...\n]\n\n# Initialize your FastCRUD instance for Task\ntask_crud = FastCRUD(Task)\n\n# Fetch tasks with joined user details\ntasks = await task_crud.get_multi_joined(\n    db=session,\n    schema_to_select=ReadTaskSchema,\n    offset=0,\n    limit=10,\n    joins_config=joins_config,\n)\n</code></pre> <p>In this example, <code>owner_alias</code> and <code>assigned_user_alias</code> are created from <code>User</code> to distinguish between the task's owner and the assigned user within the task management system. By using aliases, you can join the same model multiple times for different purposes in your queries, enhancing expressiveness and eliminating ambiguity.</p>"},{"location":"advanced/crud/#many-to-many-relationships-with-get_multi_joined","title":"Many-to-Many Relationships with <code>get_multi_joined</code>","text":"<p>FastCRUD simplifies dealing with many-to-many relationships by allowing easy fetch operations with joined models. Here, we demonstrate using <code>get_multi_joined</code> to handle a many-to-many relationship between <code>Project</code> and <code>Participant</code> models, linked through an association table.</p> <p>Note on Handling Many-to-Many Relationships:</p> <p>When using <code>get_multi_joined</code> for many-to-many relationships, it's essential to maintain a specific order in your <code>joins_config</code>: </p> <ol> <li>First, specify the main table you're querying from.</li> <li>Next, include the association table that links your main table to the other table involved in the many-to-many relationship.</li> <li>Finally, specify the other table that is connected via the association table.</li> </ol> <p>This order ensures that the SQL joins are structured correctly to reflect the many-to-many relationship and retrieve the desired data accurately.</p> <p>Tip</p> <p>Note that the first one can be the model defined in <code>FastCRUD(Model)</code>.</p> Models <pre><code>class Project(Base):\n    __tablename__ = \"projects\"\n    id = Column(Integer, primary_key=True)\n    name = Column(String(32), nullable=False)\n    description = Column(String(32))\n    participants = relationship(\n        \"Participant\",\n        secondary=\"projects_participants_association\",\n        back_populates=\"projects\",\n    )\n\n\nclass Participant(Base):\n    __tablename__ = \"participants\"\n    id = Column(Integer, primary_key=True)\n    name = Column(String(32), nullable=False)\n    role = Column(String(32))\n    projects = relationship(\n        \"Project\",\n        secondary=\"projects_participants_association\",\n        back_populates=\"participants\",\n    )\n\n\nclass ProjectsParticipantsAssociation(Base):\n    __tablename__ = \"projects_participants_association\"\n    project_id = Column(Integer, ForeignKey(\"projects.id\"), primary_key=True)\n    participant_id = Column(Integer, ForeignKey(\"participants.id\"), primary_key=True)\n</code></pre> <pre><code># Fetch projects with their participants via a many-to-many relationship\njoins_config = [\n    JoinConfig(\n        model=ProjectsParticipantsAssociation,\n        join_on=Project.id == ProjectsParticipantsAssociation.project_id,\n        join_prefix=\"pp_\",\n        join_type=\"inner\",\n    ),\n    JoinConfig(\n        model=Participant,\n        join_on=ProjectsParticipantsAssociation.participant_id == Participant.id,\n        join_prefix=\"participant_\",\n        join_type=\"inner\",\n    ),\n]\n\nproject_crud = FastCRUD(Project)\n\nclass ReadProjectSchema(BaseModel):\n    id: int\n    name: str\n    description: Optional[str] = None\n\nprojects_with_participants = await project_crud.get_multi_joined(\n    db=db,\n    schema_to_select=ReadProjectSchema,\n    joins_config=joins_config,\n)\n</code></pre> <p>For a more detailed explanation, read this part of the docs.</p>"},{"location":"advanced/crud/#enhanced-query-capabilities-with-method-chaining","title":"Enhanced Query Capabilities with Method Chaining","text":"<p>The <code>select</code> method in FastCRUD is designed for flexibility, enabling you to build complex queries through method chaining.</p>"},{"location":"advanced/crud/#the-select-method","title":"The <code>select</code> Method","text":"<pre><code>async def select(\n    db: AsyncSession,\n    schema_to_select: Optional[type[BaseModel]] = None,\n    sort_columns: Optional[Union[str, list[str]]] = None,\n    sort_orders: Optional[Union[str, list[str]]] = None,\n    **kwargs: Any\n) -&gt; Selectable\n</code></pre> <p>This method constructs a SQL Alchemy <code>Select</code> statement, offering optional column selection, filtering, and sorting. It's designed for flexibility, allowing you to chain additional SQLAlchemy methods for even more complex queries.</p>"},{"location":"advanced/crud/#features","title":"Features:","text":"<ul> <li>Column Selection: Specify columns with a Pydantic schema.</li> <li>Sorting: Define one or more columns for sorting, along with their sort order.</li> <li>Filtering: Apply filters directly through keyword arguments.</li> <li>Chaining: Chain with other SQLAlchemy methods for advanced query construction.</li> </ul>"},{"location":"advanced/crud/#usage-example","title":"Usage Example:","text":"<pre><code>class ReadMyModelSchema(BaseModel):\n    id: int\n    name: str | None = None\n    archived: bool\n    archived_at: datetime.datetime\n    date_updated: datetime.datetime\n\n\nstmt = await my_model_crud.select(\n    schema_to_select=ReadMyModelSchema,\n    sort_columns='name',\n    name__like='%example%',\n)\nstmt = stmt.where(additional_conditions).limit(10)\nresults = await db.execute(stmt)\n</code></pre> <p>This example demonstrates selecting a subset of columns, applying a filter, and chaining additional conditions like <code>where</code> and <code>limit</code>. Note that <code>select</code> returns a <code>Select</code> object, allowing for further modifications before execution.</p>"},{"location":"advanced/crud/#conclusion","title":"Conclusion","text":"<p>The advanced features of FastCRUD, such as <code>allow_multiple</code> and support for advanced filters, empower developers to efficiently manage database records with complex conditions. By leveraging these capabilities, you can build more dynamic, robust, and scalable FastAPI applications that effectively interact with your data model.</p>"},{"location":"advanced/dependency_filtering/","title":"Dependency-Based Filtering","text":"<p>FastCRUD now supports dependency-based filtering, allowing you to automatically filter query results based on values from dependencies. This is particularly useful for implementing row-level access control, where users should only see data that belongs to their organization or tenant.</p>"},{"location":"advanced/dependency_filtering/#basic-usage","title":"Basic Usage","text":"<p>You can use dependency-based filtering by passing a callable (function or dependency) as a filter value in the <code>FilterConfig</code>:</p> <pre><code>from fastapi import Depends, FastAPI\nfrom fastcrud import crud_router, FilterConfig\n\nfrom .database import async_session\nfrom .models import ExternalProviderConfig\nfrom .schemas import ExternalProviderConfigSchema\n\n# Define a dependency that returns the user's organization ID\nasync def get_auth_user():\n    # Your authentication logic here\n    return UserInfo(organization_id=123)\n\nasync def get_org_id(auth: UserInfo = Depends(get_auth_user)):\n    return auth.organization_id\n\n# Create a router with dependency-based filtering\napp = FastAPI()\nepc_router = crud_router(\n    session=async_session,\n    model=ExternalProviderConfig,\n    create_schema=ExternalProviderConfigSchema,\n    update_schema=ExternalProviderConfigSchema,\n    path=\"/external_provider_configs\",\n    filter_config=FilterConfig(\n        organization_id=get_org_id,  # This will be resolved at runtime\n    ),\n    tags=[\"external_provider_configs\"],\n)\n\napp.include_router(epc_router)\n</code></pre> <p>In this example, the <code>get_org_id</code> dependency will be called for each request, and the returned value will be used to filter the results by <code>organization_id</code>.</p>"},{"location":"advanced/dependency_filtering/#how-it-works","title":"How It Works","text":"<p>When you provide a callable as a filter value, FastCRUD will:</p> <ol> <li>Use FastAPI's <code>Depends</code> to inject the dependency into the endpoint</li> <li>Call the dependency function at runtime to get the actual filter value</li> <li>Apply the filter to the query</li> </ol> <p>This means that the filter value can be dynamically determined based on the current request context, such as the authenticated user.</p>"},{"location":"advanced/dependency_filtering/#combining-static-and-dynamic-filters","title":"Combining Static and Dynamic Filters","text":"<p>You can combine dependency-based filters with static filters:</p> <pre><code>filter_config = FilterConfig(\n    organization_id=get_org_id,  # Dynamic filter from dependency\n    status=\"active\",             # Static filter\n    is_deleted=False,            # Static filter\n)\n</code></pre>"},{"location":"advanced/dependency_filtering/#advanced-usage-with-nested-dependencies","title":"Advanced Usage with Nested Dependencies","text":"<p>You can use nested dependencies to build more complex filtering logic:</p> <pre><code>async def get_auth_user():\n    # Your authentication logic here\n    return UserInfo(organization_id=123)\n\nasync def get_user_permissions(auth: UserInfo = Depends(get_auth_user)):\n    # Get user permissions\n    return UserPermissions(can_see_all=False)\n\nasync def get_org_filter(\n    auth: UserInfo = Depends(get_auth_user),\n    permissions: UserPermissions = Depends(get_user_permissions)\n):\n    # If user has special permissions, don't filter by organization\n    if permissions.can_see_all:\n        return None\n    return auth.organization_id\n\nfilter_config = FilterConfig(\n    organization_id=get_org_filter,  # This might return None for some users\n)\n</code></pre> <p>In this example, the <code>organization_id</code> filter will only be applied if the user doesn't have the <code>can_see_all</code> permission.</p>"},{"location":"advanced/dependency_filtering/#limitations","title":"Limitations","text":"<ul> <li>Dependency-based filters are only applied to the <code>read_multi</code> endpoint</li> <li>The dependency function must return a value that is compatible with the column type</li> <li>Complex filtering logic should be implemented in the dependency function, not in the filter configuration</li> </ul>"},{"location":"advanced/endpoint/","title":"Advanced Use of EndpointCreator","text":""},{"location":"advanced/endpoint/#available-automatic-endpoints","title":"Available Automatic Endpoints","text":"<p>FastCRUD automates the creation of CRUD (Create, Read, Update, Delete) endpoints for your FastAPI application. Here's an overview of the available automatic endpoints and how they work, based on the automatic endpoints we've generated before:</p>"},{"location":"advanced/endpoint/#create","title":"Create","text":"<ul> <li>Endpoint: <code>/{model}</code></li> <li>Method: <code>POST</code></li> <li>Description: Creates a new item in the database.</li> <li>Request Body: JSON object based on the <code>create_schema</code>.</li> <li>Example Request: <code>POST /items</code> with JSON body.</li> </ul>"},{"location":"advanced/endpoint/#read","title":"Read","text":"<ul> <li>Endpoint: <code>/{model}/{id}</code></li> <li>Method: <code>GET</code></li> <li>Description: Retrieves a single item by its ID.</li> <li>Path Parameters: <code>id</code> - The ID of the item to retrieve.</li> <li>Example Request: <code>GET /items/1</code>.</li> <li>Example Return: <pre><code>{\n    \"id\": 1,\n    \"name\": \"Item 1\",\n    \"description\": \"Description of item 1\",\n    \"category\": \"Movies\",\n    \"price\": 5.99,\n    \"last_sold\": null,\n    \"created_at\": \"2024-01-01 12:00:00\"\n}\n</code></pre></li> </ul>"},{"location":"advanced/endpoint/#read-multiple","title":"Read Multiple","text":"<ul> <li>Endpoint: <code>/{model}</code></li> <li>Method: <code>GET</code></li> <li>Description: Retrieves multiple items with optional pagination.</li> <li>Query Parameters:<ul> <li><code>offset</code> (optional): The offset from where to start fetching items.</li> <li><code>limit</code> (optional): The maximum number of items to return.</li> <li><code>page</code> (optional): The page number, starting from 1.</li> <li><code>itemsPerPage</code> (optional): The number of items per page.</li> <li><code>sort</code> (optional): Sort results by one or more fields. Format: <code>field1,-field2</code> where <code>-</code> prefix indicates descending order.</li> </ul> </li> <li>Example Requests:<ul> <li><code>GET /items?offset=3&amp;limit=4</code> (pagination)</li> <li><code>GET /items?sort=name</code> (sort by name ascending)</li> <li><code>GET /items?sort=-price,name</code> (sort by price descending, then name ascending)</li> </ul> </li> <li>Example Return: <pre><code>{\n  \"data\": [\n    {\n        \"id\": 4,\n        \"name\": \"Item 4\",\n        \"description\": \"Description of item 4\",\n        \"category\": \"Books\",\n        \"price\": 5.99,\n        \"last_sold\": null,\n        \"created_at\": \"2024-01-01 12:01:00\"\n    },\n    {\n        \"id\": 5,\n        \"name\": \"Item 5\",\n        \"description\": \"Description of item 5\",\n        \"category\": \"Music\",\n        \"price\": 5.99,\n        \"last_sold\": \"2024-04-01 00:00:00\",\n        \"created_at\": \"2024-01-01 12:10:00\"\n    },\n    {\n        \"id\": 6,\n        \"name\": \"Item 6\",\n        \"description\": \"Description of item 6\",\n        \"category\": \"TV\",\n        \"price\": 5.99,\n        \"last_sold\": null,\n        \"created_at\": \"2024-01-01 12:15:00\"\n    },\n    {\n        \"id\": 7,\n        \"name\": \"Item 7\",\n        \"description\": \"Description of item 7\",\n        \"category\": \"Books\",\n        \"price\": 5.99,\n        \"last_sold\": null,\n        \"created_at\": \"2024-01-01 13:00:30\"\n    }\n  ],\n  \"total_count\": 50\n}\n</code></pre></li> <li>Example Paginated Request: <code>GET /items?page=1&amp;itemsPerPage=3</code>.</li> <li>Example Paginated Return: <pre><code>{\n  \"data\": [\n    {\n        \"id\": 1,\n        \"name\": \"Item 1\",\n        \"description\": \"Description of item 1\",\n        \"category\": \"Movies\",\n        \"price\": 5.99,\n        \"last_sold\": null,\n        \"created_at\": \"2024-01-01 12:00:01\"\n    },\n    {\n        \"id\": 2,\n        \"name\": \"Item 2\",\n        \"description\": \"Description of item 2\",\n        \"category\": \"TV\",\n        \"price\": 19.99,\n        \"last_sold\": null,\n        \"created_at\": \"2024-01-01 12:00:15\"\n    },\n    {\n        \"id\": 3,\n        \"name\": \"Item 3\",\n        \"description\": \"Description of item 3\",\n        \"category\": \"Books\",\n        \"price\": 4.99,\n        \"last_sold\": null,\n        \"created_at\": \"2024-01-01 12:00:16\"\n    }\n  ],\n  \"total_count\": 50,\n  \"has_more\": true,\n  \"page\": 1,\n  \"items_per_page\": 3\n}\n</code></pre></li> </ul> <p>Note</p> <p><code>_read_paginated</code> endpoint was deprecated and mixed into <code>_read_items</code> in the release <code>0.15.0</code>. Simple <code>_read_items</code> behaviour persists with no breaking changes.</p> <p>Read items paginated: <pre><code>$ curl -X 'GET' \\\n  'http://localhost:8000/users?page=2&amp;itemsPerPage=10' \\\n  -H 'accept: application/json'\n</code></pre></p> <p>Read items unpaginated: <pre><code>$ curl -X 'GET' \\\n  'http://localhost:8000/users?offset=0&amp;limit=100' \\\n  -H 'accept: application/json'\n</code></pre></p>"},{"location":"advanced/endpoint/#update","title":"Update","text":"<ul> <li>Endpoint: <code>/{model}/{id}</code></li> <li>Method: <code>PATCH</code></li> <li>Description: Updates an existing item by its ID.</li> <li>Path Parameters: <code>id</code> - The ID of the item to update.</li> <li>Request Body: JSON object based on the <code>update_schema</code>.</li> <li>Example Request: <code>PATCH /items/1</code> with JSON body.</li> <li>Example Return: <code>None</code></li> <li>Note: If the target item is not found by ID, the generated endpoint returns a 404 Not Found with detail \"Item not found\".</li> </ul>"},{"location":"advanced/endpoint/#delete","title":"Delete","text":"<ul> <li>Endpoint: <code>/{model}/{id}</code></li> <li>Method: <code>DELETE</code></li> <li>Description: Deletes (soft delete if configured) an item by its ID.</li> <li>Path Parameters: <code>id</code> - The ID of the item to delete.</li> <li>Example Request: <code>DELETE /items/1</code>.</li> <li>Example Return: <code>None</code></li> <li>Note: If the target item is not found by ID, the generated endpoint returns a 404 Not Found with detail \"Item not found\".</li> </ul>"},{"location":"advanced/endpoint/#db-delete-hard-delete","title":"DB Delete (Hard Delete)","text":"<ul> <li>Endpoint: <code>/{model}/db_delete/{id}</code> (Available if a <code>delete_schema</code> is provided)</li> <li>Method: <code>DELETE</code></li> <li>Description: Permanently deletes an item by its ID, bypassing the soft delete mechanism.</li> <li>Path Parameters: <code>id</code> - The ID of the item to hard delete.</li> <li>Example Request: <code>DELETE /items/db_delete/1</code>.</li> <li>Example Return: <code>None</code></li> </ul>"},{"location":"advanced/endpoint/#selective-crud-operations","title":"Selective CRUD Operations","text":"<p>You can control which CRUD operations are exposed by using <code>included_methods</code> and <code>deleted_methods</code>. These parameters allow you to specify exactly which CRUD methods should be included or excluded when setting up the router. By default, all CRUD endpoints are included.</p> <code>mymodel/model.py</code> <pre><code>from sqlalchemy import Boolean, Column, DateTime, Integer, String\nfrom sqlalchemy.orm import DeclarativeBase\n\n\nclass Base(DeclarativeBase):\n    pass\n\n\nclass MyModel(Base):\n    __tablename__ = \"my_model\"\n    id = Column(Integer, primary_key=True)\n    name = Column(String)\n</code></pre> <code>mymodel/schemas.py</code> <pre><code>import datetime\n\nfrom pydantic import BaseModel\n\n\nclass CreateMyModelSchema(BaseModel):\n    name: str | None = None\n\n\nclass UpdateMyModelSchema(BaseModel):\n    name: str | None = None\n</code></pre>"},{"location":"advanced/endpoint/#using-included_methods","title":"Using <code>included_methods</code>","text":"<p>Using <code>included_methods</code> you may define exactly the methods you want to be included.</p> <pre><code># Using crud_router with selective CRUD methods\nmy_router = crud_router(\n    session=get_session,\n    model=MyModel,\n    create_schema=CreateMyModelSchema,\n    update_schema=UpdateMyModelSchema,\n    crud=FastCRUD(MyModel),\n    path=\"/mymodel\",\n    tags=[\"MyModel\"],\n    included_methods=[\"create\", \"read\", \"update\"],  # Only these methods will be included\n)\n\napp.include_router(my_router)\n</code></pre>"},{"location":"advanced/endpoint/#using-deleted_methods","title":"Using <code>deleted_methods</code>","text":"<p>Using <code>deleted_methods</code> you define the methods that will not be included.</p> <pre><code># Using crud_router with selective CRUD methods\nmy_router = crud_router(\n    session=get_session,\n    model=MyModel,\n    create_schema=CreateMyModelSchema,\n    update_schema=UpdateMyModelSchema,\n    crud=FastCRUD(MyModel),\n    path=\"/mymodel\",\n    tags=[\"MyModel\"],\n    deleted_methods=[\"update\", \"delete\"],  # All but these methods will be included\n)\n\napp.include_router(my_router)\n</code></pre> <p>Warning</p> <p>If <code>included_methods</code> and <code>deleted_methods</code> are both provided, a <code>ValueError</code> will be raised.</p>"},{"location":"advanced/endpoint/#customizing-endpoint-names","title":"Customizing Endpoint Names","text":"<p>You can customize the names of the auto generated endpoints by passing an <code>endpoint_names</code> dictionary when initializing the <code>EndpointCreator</code> or calling the <code>crud_router</code> function. This dictionary should map the CRUD operation names (<code>create</code>, <code>read</code>, <code>update</code>, <code>delete</code>, <code>db_delete</code>, <code>read_multi</code>) to your desired endpoint names.</p>"},{"location":"advanced/endpoint/#example-using-crud_router","title":"Example: Using <code>crud_router</code>","text":"<p>Here's how you can customize endpoint names using the <code>crud_router</code> function:</p> <pre><code>from fastapi import FastAPI\nfrom fastcrud import crud_router\n\nfrom .database import async_session\nfrom .mymodel.model import MyModel\nfrom .mymodel.schemas import CreateMyModelSchema, UpdateMyModelSchema\n\napp = FastAPI()\n\n# Custom endpoint names\ncustom_endpoint_names = {\n    \"create\": \"add\",\n    \"read\": \"fetch\",\n    \"update\": \"modify\",\n    \"delete\": \"remove\",\n    \"read_multi\": \"list\",\n}\n\n# Setup CRUD router with custom endpoint names\napp.include_router(crud_router(\n    session=async_session,\n    model=MyModel,\n    create_schema=CreateMyModelSchema,\n    update_schema=UpdateMyModelSchema,\n    path=\"/mymodel\",\n    tags=[\"MyModel\"],\n    endpoint_names=custom_endpoint_names,\n))\n</code></pre> <p>In this example, the standard CRUD endpoints will be replaced with <code>/add</code>, <code>/fetch/{id}</code>, <code>/modify/{id}</code>, <code>/remove/{id}</code>, <code>/list</code>, and <code>/paginate</code>.</p>"},{"location":"advanced/endpoint/#example-using-endpointcreator","title":"Example: Using <code>EndpointCreator</code>","text":"<p>If you are using <code>EndpointCreator</code>, you can also pass the <code>endpoint_names</code> dictionary to customize the endpoint names similarly:</p> <pre><code># Custom endpoint names\ncustom_endpoint_names = {\n    \"create\": \"add_new\",\n    \"read\": \"get_single\",\n    \"update\": \"change\",\n    \"delete\": \"erase\",\n    \"db_delete\": \"hard_erase\",\n    \"read_multi\": \"get_all\",\n    \"read_paginated\": \"get_page\",\n}\n\n# Initialize and use the custom EndpointCreator\nendpoint_creator = EndpointCreator(\n    session=async_session,\n    model=MyModel,\n    create_schema=CreateMyModelSchema,\n    update_schema=UpdateMyModelSchema,\n    path=\"/mymodel\",\n    tags=[\"MyModel\"],\n    endpoint_names=custom_endpoint_names,\n)\n\nendpoint_creator.add_routes_to_router()\napp.include_router(endpoint_creator.router)\n</code></pre> <p>Tip</p> <p>You only need to pass the names of the endpoints you want to change in the <code>endpoint_names</code> <code>dict</code>.</p> <p>Note</p> <p><code>default_endpoint_names</code> for <code>EndpointCreator</code> were changed to empty strings in <code>0.15.0</code>. See this issue for more details.</p>"},{"location":"advanced/endpoint/#joined-model-filtering","title":"Joined Model Filtering","text":"<p>FastCRUD supports filtering on related models using dot notation in filter configurations. This allows you to filter records based on attributes of joined models without manually writing complex queries.</p>"},{"location":"advanced/endpoint/#basic-joined-model-filtering","title":"Basic Joined Model Filtering","text":"<p>You can filter records based on attributes of related models by using dot notation in your filter configuration:</p> <pre><code>from fastapi import FastAPI\nfrom fastcrud import EndpointCreator, FilterConfig\n\n# Assuming you have User and Company models with a relationship\napp = FastAPI()\n\nendpoint_creator = EndpointCreator(\n    session=async_session,\n    model=User,\n    create_schema=CreateUserSchema,\n    update_schema=UpdateUserSchema,\n    filter_config=FilterConfig(\n        # Regular filters\n        name=None,\n        email=None,\n        # Joined model filters\n        **{\n            \"company.name\": None,           # Filter by company name\n            \"company.industry\": None,       # Filter by company industry\n            \"company.founded_year\": None,   # Filter by company founded year\n        }\n    ),\n)\n\nendpoint_creator.add_routes_to_router()\napp.include_router(endpoint_creator.router, prefix=\"/users\")\n</code></pre>"},{"location":"advanced/endpoint/#using-joined-model-filters","title":"Using Joined Model Filters","text":"<p>Once configured, you can use joined model filters in your API requests:</p> <pre><code># Filter users by company name\nGET /users?company.name=TechCorp\n\n# Filter users by company industry\nGET /users?company.industry=Technology\n\n# Combine regular and joined filters\nGET /users?name=John&amp;company.name=TechCorp\n\n# Use filter operators with joined models\nGET /users?company.founded_year__gte=2000\n</code></pre>"},{"location":"advanced/endpoint/#supported-filter-operators","title":"Supported Filter Operators","text":"<p>Joined model filters support all the same operators as regular filters:</p> <pre><code>filter_config=FilterConfig(**{\n    \"company.name__eq\": None,           # Exact match\n    \"company.name__ne\": None,           # Not equal\n    \"company.name__in\": None,           # In list\n    \"company.founded_year__gte\": None,  # Greater than or equal\n    \"company.founded_year__lt\": None,   # Less than\n    \"company.revenue__between\": None,   # Between values\n})\n</code></pre>"},{"location":"advanced/endpoint/#multi-level-relationships","title":"Multi-level Relationships","text":"<p>You can filter through multiple levels of relationships:</p> <pre><code># Assuming User -&gt; Company -&gt; Address relationship\nfilter_config=FilterConfig(**{\n    \"company.address.city\": None,\n    \"company.address.country\": None,\n})\n\n# Usage:\n# GET /users?company.address.city=San Francisco\n</code></pre>"},{"location":"advanced/endpoint/#how-it-works","title":"How It Works","text":"<p>When you use joined model filters, FastCRUD automatically:</p> <ol> <li>Detects joined filters: Identifies filter keys containing dot notation</li> <li>Validates relationships: Ensures the relationship path exists in your models</li> <li>Generates joins: Automatically creates the necessary SQL joins</li> <li>Applies filters: Adds WHERE clauses for the joined model attributes</li> </ol> <p>The system generates efficient SQL queries like:</p> <pre><code>SELECT user.id, user.name, user.email, user.company_id,\n       company.id AS company_id_1, company.name AS company_name, company.industry\nFROM user\nLEFT OUTER JOIN company ON user.company_id = company.id\nWHERE company.name = 'TechCorp'\n</code></pre>"},{"location":"advanced/endpoint/#limitations","title":"Limitations","text":"<ul> <li>Currently supports single-relationship joins (one level of relationship at a time)</li> <li>Complex many-to-many relationships may require custom implementation</li> <li>Performance considerations apply for deeply nested relationships</li> </ul>"},{"location":"advanced/endpoint/#example-models","title":"Example Models","text":"<p>Here's an example of models that work well with joined model filtering:</p> <pre><code>from sqlalchemy import Column, Integer, String, ForeignKey\nfrom sqlalchemy.orm import relationship\nfrom sqlalchemy.ext.declarative import declarative_base\n\nBase = declarative_base()\n\nclass Company(Base):\n    __tablename__ = \"company\"\n    id = Column(Integer, primary_key=True)\n    name = Column(String(100), nullable=False)\n    industry = Column(String(50))\n    users = relationship(\"User\", back_populates=\"company\")\n\nclass User(Base):\n    __tablename__ = \"user\"\n    id = Column(Integer, primary_key=True)\n    name = Column(String(100), nullable=False)\n    email = Column(String(100), unique=True)\n    company_id = Column(Integer, ForeignKey(\"company.id\"))\n    company = relationship(\"Company\", back_populates=\"users\")\n</code></pre>"},{"location":"advanced/endpoint/#extending-endpointcreator","title":"Extending <code>EndpointCreator</code>","text":"<p>You can create a subclass of <code>EndpointCreator</code> and override or add new methods to define custom routes. Here's an example:</p>"},{"location":"advanced/endpoint/#creating-a-custom-endpointcreator","title":"Creating a Custom <code>EndpointCreator</code>","text":"<pre><code>from fastcrud import EndpointCreator\n\n# Define the custom EndpointCreator\nclass MyCustomEndpointCreator(EndpointCreator):\n    # Add custom routes or override existing methods\n    def _custom_route(self):\n        async def custom_endpoint():\n            # Custom endpoint logic\n            return {\"message\": \"Custom route\"}\n\n        return custom_endpoint\n\n    # override add_routes_to_router to also add the custom routes\n    def add_routes_to_router(self, ...):\n        # First, add standard CRUD routes if you want them\n        super().add_routes_to_router(...)\n\n        # Now, add custom routes\n        self.router.add_api_route(\n            path=\"/custom\",\n            endpoint=self._custom_route(),\n            methods=[\"GET\"],\n            tags=self.tags,\n            # Other parameters as needed\n        )\n</code></pre>"},{"location":"advanced/endpoint/#adding-custom-routes","title":"Adding custom routes","text":"<pre><code>from fastcrud import EndpointCreator\n\n# Define the custom EndpointCreator\nclass MyCustomEndpointCreator(EndpointCreator):\n    # Add custom routes or override existing methods\n    def _custom_route(self):\n        async def custom_endpoint():\n            # Custom endpoint logic\n            return {\"message\": \"Custom route\"}\n\n        return custom_endpoint\n\n    # override add_routes_to_router to also add the custom routes\n    def add_routes_to_router(self, ...):\n        # First, add standard CRUD routes if you want them\n        super().add_routes_to_router(...)\n\n        # Now, add custom routes\n        self.router.add_api_route(\n            path=\"/custom\",\n            endpoint=self._custom_route(),\n            methods=[\"GET\"],\n            tags=self.tags,\n            # Other parameters as needed\n        )\n</code></pre>"},{"location":"advanced/endpoint/#overriding-add_routes_to_router","title":"Overriding <code>add_routes_to_router</code>","text":"<pre><code>from fastcrud import EndpointCreator\n\n# Define the custom EndpointCreator\nclass MyCustomEndpointCreator(EndpointCreator):\n    # Add custom routes or override existing methods\n    def _custom_route(self):\n        async def custom_endpoint():\n            # Custom endpoint logic\n            return {\"message\": \"Custom route\"}\n\n        return custom_endpoint\n\n    # override add_routes_to_router to also add the custom routes\n    def add_routes_to_router(self, ...):\n        # First, add standard CRUD routes if you want them\n        super().add_routes_to_router(...)\n\n        # Now, add custom routes\n        self.router.add_api_route(\n            path=\"/custom\",\n            endpoint=self._custom_route(),\n            methods=[\"GET\"],\n            tags=self.tags,\n            # Other parameters as needed\n        )\n</code></pre>"},{"location":"advanced/endpoint/#using-the-custom-endpointcreator","title":"Using the Custom EndpointCreator","text":"<pre><code># Assuming MyCustomEndpointCreator was created\n\n...\n\n# Use the custom EndpointCreator with crud_router\nmy_router = crud_router(\n    session=get_session,\n    model=MyModel,\n    create_schema=CreateMyModelSchema,\n    update_schema=UpdateMyModelSchema,\n    crud=FastCRUD(MyModel),\n    path=\"/mymodel\",\n    tags=[\"MyModel\"],\n    included_methods=[\"create\", \"read\", \"update\"],  # Including selective methods\n    endpoint_creator=MyCustomEndpointCreator,\n)\n\napp.include_router(my_router)\n</code></pre>"},{"location":"advanced/endpoint/#reusing-pagination-query-parameters","title":"Reusing Pagination Query Parameters","text":"<p>FastCRUD provides a <code>PaginatedRequestQuery</code> Pydantic model that encapsulates all query parameters used for pagination and sorting. This model can be reused in custom endpoints using FastAPI's <code>Depends()</code>, making it easy to maintain consistent pagination behavior across your API.</p> <p>Import Path Change</p> <p>Until version 0.18.x, pagination utilities were imported from <code>fastcrud.paginated</code>. Starting from version 0.19.0, this import path is deprecated and will be completely removed in version 0.20.0. Please update your imports to use <code>from fastcrud import PaginatedRequestQuery</code> instead.</p>"},{"location":"advanced/endpoint/#using-paginatedrequestquery-in-custom-endpoints","title":"Using <code>PaginatedRequestQuery</code> in Custom Endpoints","text":"<p>The <code>PaginatedRequestQuery</code> model includes all standard pagination parameters:</p> <ul> <li><code>offset</code> and <code>limit</code> for offset-based pagination</li> <li><code>page</code> and <code>items_per_page</code> (alias: <code>itemsPerPage</code>) for page-based pagination</li> <li><code>sort</code> for sorting by one or more fields</li> </ul> <p>Here's how to use it in a custom endpoint:</p> <pre><code>from typing import Annotated\nfrom fastapi import Depends, APIRouter\nfrom fastcrud import PaginatedRequestQuery\nfrom sqlalchemy.ext.asyncio import AsyncSession\n\nrouter = APIRouter()\n\n@router.get(\"/custom/items\")\nasync def get_custom_items(\n    db: Annotated[AsyncSession, Depends(get_session)],\n    query: Annotated[PaginatedRequestQuery, Depends()],\n):\n    \"\"\"Custom endpoint using the same pagination parameters as FastCRUD.\"\"\"\n    # Access pagination parameters\n    if query.page is not None and query.items_per_page is not None:\n        # Page-based pagination\n        offset = (query.page - 1) * query.items_per_page\n        limit = query.items_per_page\n    else:\n        # Offset-based pagination\n        offset = query.offset\n        limit = query.limit\n\n    # Use offset and limit in your query\n    # ... your custom logic here\n\n    return {\"offset\": offset, \"limit\": limit, \"sort\": query.sort}\n</code></pre>"},{"location":"advanced/endpoint/#query-parameter-examples","title":"Query Parameter Examples","text":"<p>Once the <code>PaginatedRequestQuery</code> dependency is added to your endpoint, it automatically accepts the following query parameters:</p> <p>Page-based pagination: <pre><code># Basic page-based pagination\nGET /custom/items?page=2&amp;itemsPerPage=20\n\n# With sorting\nGET /custom/items?page=1&amp;itemsPerPage=10&amp;sort=name,-price\n</code></pre></p> <p>Offset-based pagination: <pre><code># Basic offset-based pagination\nGET /custom/items?offset=10&amp;limit=50\n\n# With sorting\nGET /custom/items?offset=0&amp;limit=100&amp;sort=-created_at\n</code></pre></p> <p>Sorting only: <pre><code># Single field ascending\nGET /custom/items?sort=name\n\n# Single field descending\nGET /custom/items?sort=-price\n\n# Multiple fields mixed order\nGET /custom/items?sort=category,-price,name\n</code></pre></p> <p>No parameters (all optional): <pre><code># All parameters will be None\nGET /custom/items\n</code></pre></p>"},{"location":"advanced/endpoint/#extending-paginatedrequestquery","title":"Extending <code>PaginatedRequestQuery</code>","text":"<p>You can also subclass <code>PaginatedRequestQuery</code> to add custom query parameters while maintaining all the standard pagination fields:</p> <pre><code>from typing import Optional\nfrom pydantic import Field\nfrom fastcrud import PaginatedRequestQuery\n\nclass CustomPaginatedQuery(PaginatedRequestQuery):\n    \"\"\"Extended query with custom filter.\"\"\"\n\n    status: Optional[str] = Field(None, description=\"Filter by status\")\n    category: Optional[str] = Field(None, description=\"Filter by category\")\n\n@router.get(\"/custom/filtered-items\")\nasync def get_filtered_items(\n    db: Annotated[AsyncSession, Depends(get_session)],\n    query: Annotated[CustomPaginatedQuery, Depends()],\n):\n    \"\"\"Custom endpoint with additional filter parameters.\"\"\"\n    # Access both standard pagination and custom parameters\n    return {\n        \"page\": query.page,\n        \"items_per_page\": query.items_per_page,\n        \"status\": query.status,\n        \"category\": query.category,\n    }\n</code></pre>"},{"location":"advanced/endpoint/#benefits","title":"Benefits","text":"<p>Using <code>PaginatedRequestQuery</code> provides several advantages:</p> <ul> <li>Consistency: All endpoints use the same pagination parameter names and behavior</li> <li>Reusability: No need to redefine pagination parameters for each custom endpoint</li> <li>OpenAPI Documentation: Automatic generation of proper API documentation with field descriptions</li> <li>Type Safety: Full Pydantic validation for all query parameters</li> <li>Flexibility: Easy to extend with custom parameters while maintaining standard pagination</li> </ul>"},{"location":"advanced/endpoint/#reusing-cursor-pagination-query-parameters","title":"Reusing Cursor Pagination Query Parameters","text":"<p>FastCRUD also provides a <code>CursorPaginatedRequestQuery</code> Pydantic model for cursor-based pagination. This model is ideal for large datasets and infinite scrolling features, as it provides consistent results even when data is being modified.</p> <p>Import Path Change</p> <p>Until version 0.18.x, pagination utilities were imported from <code>fastcrud.paginated</code>. Starting from version 0.19.0, this import path is deprecated and will be completely removed in version 0.20.0. Please update your imports to use <code>from fastcrud import CursorPaginatedRequestQuery</code> instead.</p>"},{"location":"advanced/endpoint/#using-cursorpaginatedrequestquery-in-custom-endpoints","title":"Using <code>CursorPaginatedRequestQuery</code> in Custom Endpoints","text":"<p>The <code>CursorPaginatedRequestQuery</code> model includes cursor-based pagination parameters:</p> <ul> <li><code>cursor</code> - Cursor value for pagination (typically the ID of the last item from previous page)</li> <li><code>limit</code> - Maximum number of items to return per page (default: 100, max: 1000)</li> <li><code>sort_column</code> - Column name to sort by (default: \"id\")</li> <li><code>sort_order</code> - Sort order: \"asc\" or \"desc\" (default: \"asc\")</li> </ul> <p>Here's how to use it in a custom endpoint:</p> <pre><code>from typing import Annotated\nfrom fastapi import Depends, APIRouter\nfrom fastcrud import CursorPaginatedRequestQuery\nfrom sqlalchemy.ext.asyncio import AsyncSession\n\nrouter = APIRouter()\n\n@router.get(\"/cursor/items\")\nasync def get_cursor_items(\n    db: Annotated[AsyncSession, Depends(get_session)],\n    query: Annotated[CursorPaginatedRequestQuery, Depends()],\n):\n    \"\"\"Custom endpoint using cursor-based pagination.\"\"\"\n    # Use the cursor parameters in your query logic\n    items = await some_crud.get_multi_by_cursor(\n        db,\n        cursor=query.cursor,\n        limit=query.limit,\n        sort_column=query.sort_column,\n        sort_order=query.sort_order,\n    )\n\n    return items\n</code></pre>"},{"location":"advanced/endpoint/#cursor-pagination-query-parameter-examples","title":"Cursor Pagination Query Parameter Examples","text":"<p>Once the <code>CursorPaginatedRequestQuery</code> dependency is added to your endpoint, it automatically accepts the following query parameters:</p> <p>Basic cursor pagination: <pre><code># First page (no cursor)\nGET /cursor/items?limit=20\n\n# Next page using cursor from previous response\nGET /cursor/items?cursor=123&amp;limit=20\n</code></pre></p> <p>With custom sorting: <pre><code># Sort by created_at in descending order\nGET /cursor/items?sort_column=created_at&amp;sort_order=desc&amp;limit=50\n\n# Sort by name in ascending order with cursor\nGET /cursor/items?cursor=456&amp;sort_column=name&amp;sort_order=asc&amp;limit=25\n</code></pre></p> <p>All parameters: <pre><code># Full cursor pagination with all parameters\nGET /cursor/items?cursor=789&amp;limit=100&amp;sort_column=updated_at&amp;sort_order=desc\n</code></pre></p> <p>Default behavior: <pre><code># All parameters will use defaults: limit=100, sort_column=\"id\", sort_order=\"asc\"\nGET /cursor/items\n</code></pre></p>"},{"location":"advanced/endpoint/#extending-cursorpaginatedrequestquery","title":"Extending <code>CursorPaginatedRequestQuery</code>","text":"<p>You can also subclass <code>CursorPaginatedRequestQuery</code> to add custom query parameters:</p> <pre><code>from typing import Optional\nfrom pydantic import Field\nfrom fastcrud import CursorPaginatedRequestQuery\n\nclass CustomCursorQuery(CursorPaginatedRequestQuery):\n    \"\"\"Extended cursor query with custom filters.\"\"\"\n\n    status: Optional[str] = Field(None, description=\"Filter by status\")\n    category: Optional[str] = Field(None, description=\"Filter by category\")\n\n@router.get(\"/cursor/filtered-items\")\nasync def get_filtered_cursor_items(\n    db: Annotated[AsyncSession, Depends(get_session)],\n    query: Annotated[CustomCursorQuery, Depends()],\n):\n    \"\"\"Custom endpoint with additional filter parameters.\"\"\"\n    # Access both cursor pagination and custom parameters\n    return {\n        \"cursor\": query.cursor,\n        \"limit\": query.limit,\n        \"sort_column\": query.sort_column,\n        \"sort_order\": query.sort_order,\n        \"status\": query.status,\n        \"category\": query.category,\n    }\n</code></pre>"},{"location":"advanced/endpoint/#benefits-of-cursor-pagination","title":"Benefits of Cursor Pagination","text":"<ul> <li>Consistent results: Data modifications don't affect pagination consistency</li> <li>Performance: Efficient for large datasets</li> <li>Real-time data: Perfect for infinite scrolling and real-time feeds</li> <li>No page drift: Unlike offset-based pagination, items won't be skipped or duplicated when data changes</li> </ul>"},{"location":"advanced/endpoint/#custom-soft-delete","title":"Custom Soft Delete","text":"<p>To implement custom soft delete columns using <code>EndpointCreator</code> and <code>crud_router</code> in FastCRUD, you need to specify the names of the columns used for indicating deletion status and the deletion timestamp in your model. FastCRUD provides flexibility in handling soft deletes by allowing you to configure these column names directly when setting up CRUD operations or API endpoints.</p> <p>Here's how to specify custom soft delete columns when utilizing <code>EndpointCreator</code> and <code>crud_router</code>:</p>"},{"location":"advanced/endpoint/#defining-models-with-custom-soft-delete-columns","title":"Defining Models with Custom Soft Delete Columns","text":"<p>First, ensure your SQLAlchemy model is equipped with the custom soft delete columns. Here's an example model with custom columns for soft deletion:</p> <pre><code>from sqlalchemy import Boolean, Column, DateTime, Integer, String\nfrom sqlalchemy.orm import DeclarativeBase\n\n\nclass Base(DeclarativeBase):\n    pass\n\n\nclass MyModel(Base):\n    __tablename__ = \"my_model\"\n    id = Column(Integer, primary_key=True)\n    name = Column(String)\n    archived = Column(Boolean, default=False)  # Custom soft delete column\n    archived_at = Column(DateTime)  # Custom timestamp column for soft delete\n</code></pre> <p>And a schema necessary to activate the soft delete endpoint:</p> <pre><code>class DeleteMyModelSchema(BaseModel):\n    pass\n</code></pre>"},{"location":"advanced/endpoint/#using-endpointcreator-and-crud_router-with-custom-soft-delete-or-update-columns","title":"Using <code>EndpointCreator</code> and <code>crud_router</code> with Custom Soft Delete or Update Columns","text":"<p>When initializing <code>crud_router</code> or creating a custom <code>EndpointCreator</code>, you can pass the names of your custom soft delete columns through the <code>FastCRUD</code> initialization. This informs FastCRUD which columns to check and update for soft deletion operations.</p> <p>Here's an example of using <code>crud_router</code> with custom soft delete columns:</p> <pre><code>from fastapi import FastAPI\nfrom fastcrud import FastCRUD, crud_router\nfrom sqlalchemy.ext.asyncio import AsyncSession\n\napp = FastAPI()\n\n# Assuming async_session is your AsyncSession generator\n# and MyModel is your SQLAlchemy model\n\n# Initialize FastCRUD with custom soft delete columns\nmy_model_crud = FastCRUD(\n    MyModel,\n    is_deleted_column='archived',  # Custom 'is_deleted' column name\n    deleted_at_column='archived_at',  # Custom 'deleted_at' column name\n)\n\n# Setup CRUD router with the FastCRUD instance\napp.include_router(crud_router(\n    session=async_session,\n    model=MyModel,\n    create_schema=CreateMyModelSchema,\n    update_schema=UpdateMyModelSchema,\n    crud=my_model_crud,\n    delete_schema=DeleteMyModelSchema,\n    path=\"/mymodel\",\n    tags=[\"MyModel\"],\n))\n</code></pre> <p>You may also directly pass the names of the columns to <code>crud_router</code> or <code>EndpointCreator</code>:</p> <pre><code>app.include_router(endpoint_creator(\n    session=async_session,\n    model=MyModel,\n    create_schema=CreateMyModelSchema,\n    update_schema=UpdateMyModelSchema,\n    delete_schema=DeleteMyModelSchema,\n    path=\"/mymodel\",\n    tags=[\"MyModel\"],\n    is_deleted_column='archived',\n    deleted_at_column='archived_at',\n))\n</code></pre> <p>This setup ensures that the soft delete functionality within your application utilizes the <code>archived</code> and <code>archived_at</code> columns for marking records as deleted, rather than the default <code>is_deleted</code> and <code>deleted_at</code> fields.</p> <p>By specifying custom column names for soft deletion, you can adapt FastCRUD to fit the design of your database models, providing a flexible solution for handling deleted records in a way that best suits your application's needs.</p> <p>You can also customize your <code>updated_at</code> column:</p> <pre><code>class MyModel(Base):\n    __tablename__ = \"my_model\"\n    id = Column(Integer, primary_key=True)\n    name = Column(String)\n    archived = Column(Boolean, default=False)  # Custom soft delete column\n    archived_at = Column(DateTime)  # Custom timestamp column for soft delete\n    date_updated = Column(DateTime)  # Custom timestamp column for update\n\n\napp.include_router(endpoint_creator(\n    session=async_session,\n    model=MyModel,\n    create_schema=CreateMyModelSchema,\n    update_schema=UpdateMyModelSchema,\n    delete_schema=DeleteMyModelSchema,\n    path=\"/mymodel\",\n    tags=[\"MyModel\"],\n    is_deleted_column='archived',\n    deleted_at_column='archived_at',\n    updated_at_column='date_updated',\n))\n</code></pre>"},{"location":"advanced/endpoint/#using-filters-in-fastcrud","title":"Using Filters in FastCRUD","text":"<p>FastCRUD provides filtering capabilities, allowing you to filter query results based on various conditions. Filters can be applied to <code>read_multi</code> endpoint. This section explains how to configure and use filters in FastCRUD.</p>"},{"location":"advanced/endpoint/#defining-filters","title":"Defining Filters","text":"<p>Filters are either defined using the <code>FilterConfig</code> class or just passed as a dictionary. This class allows you to specify default filter values and validate filter types. Here's an example of how to define filters for a model:</p> <pre><code>from fastcrud import FilterConfig\n\n# Define filter configuration for a model\nfilter_config = FilterConfig(\n    tier_id=None,  # Default filter value for tier_id\n    name=None,  # Default filter value for name\n)\n</code></pre> <p>And the same thing using a <code>dict</code>: <pre><code>filter_config = {\n    \"tier_id\": None,  # Default filter value for tier_id\n    \"name\": None,  # Default filter value for name\n}\n</code></pre></p> <p>By using <code>FilterConfig</code> you get better error messages.</p>"},{"location":"advanced/endpoint/#applying-filters-to-endpoints","title":"Applying Filters to Endpoints","text":"<p>You can apply filters to your endpoints by passing the <code>filter_config</code> to the <code>crud_router</code> or <code>EndpointCreator</code>. Here's an example:</p> <pre><code>from fastcrud import crud_router\n\nfrom .database import async_session\nfrom .yourmodel.model import YourModel\nfrom .yourmodel.schemas import CreateYourModelSchema, UpdateYourModelSchema\n\n# Apply filters using crud_router\napp.include_router(\n    crud_router(\n        session=async_session,\n        model=YourModel,\n        create_schema=CreateYourModelSchema,\n        update_schema=UpdateYourModelSchema,\n        path=\"/yourmodel\",\n        tags=[\"YourModel\"],\n        filter_config=filter_config,  # Apply the filter configuration\n    ),\n)\n</code></pre>"},{"location":"advanced/endpoint/#dependency-based-filtering","title":"Dependency-Based Filtering","text":"<p>FastCRUD also supports dependency-based filtering, allowing you to automatically filter query results based on values from dependencies. This is particularly useful for implementing row-level access control, where users should only see data that belongs to their organization or tenant.</p> <pre><code>from fastapi import Depends\nfrom fastcrud import crud_router, FilterConfig\n\n# Define a dependency that returns the user's organization ID\nasync def get_auth_user():\n    # Your authentication logic here\n    return UserInfo(organization_id=123)\n\nasync def get_org_id(auth: UserInfo = Depends(get_auth_user)):\n    return auth.organization_id\n\n# Create a router with dependency-based filtering\nepc_router = crud_router(\n    session=async_session,\n    model=ExternalProviderConfig,\n    create_schema=ExternalProviderConfigSchema,\n    update_schema=ExternalProviderConfigSchema,\n    path=\"/external_provider_configs\",\n    filter_config=FilterConfig(\n        organization_id=get_org_id,  # This will be resolved at runtime\n    ),\n    tags=[\"external_provider_configs\"],\n)\n\napp.include_router(epc_router)\n</code></pre> <p>In this example, the <code>get_org_id</code> dependency will be called for each request, and the returned value will be used to filter the results by <code>organization_id</code>.</p> <p>For more details on dependency-based filtering, see the Dependency-Based Filtering documentation.</p>"},{"location":"advanced/endpoint/#using-filters-in-requests","title":"Using Filters in Requests","text":"<p>Once filters are configured, you can use them in your API requests. Filters are passed as query parameters. Here's an example of how to use filters in a request to a paginated endpoint:</p> <pre><code>GET /yourmodel?page=1&amp;itemsPerPage=3&amp;tier_id=1&amp;name=Alice\n</code></pre>"},{"location":"advanced/endpoint/#custom-filter-validation","title":"Custom Filter Validation","text":"<p>The <code>FilterConfig</code> class includes a validator to check filter types. If an invalid filter type is provided, a <code>ValueError</code> is raised. You can customize the validation logic by extending the <code>FilterConfig</code> class:</p> <pre><code>from fastcrud import FilterConfig\nfrom pydantic import ValidationError\n\nclass CustomFilterConfig(FilterConfig):\n    @field_validator(\"filters\")\n    def check_filter_types(cls, filters: dict[str, Any]) -&gt; dict[str, Any]:\n        for key, value in filters.items():\n            if not isinstance(value, (type(None), str, int, float, bool)):\n                raise ValueError(f\"Invalid default value for '{key}': {value}\")\n        return filters\n\ntry:\n    # Example of invalid filter configuration\n    invalid_filter_config = CustomFilterConfig(invalid_field=[])\nexcept ValidationError as e:\n    print(e)\n</code></pre>"},{"location":"advanced/endpoint/#handling-invalid-filter-columns","title":"Handling Invalid Filter Columns","text":"<p>FastCRUD ensures that filters are applied only to valid columns in your model. If an invalid filter column is specified, a <code>ValueError</code> is raised:</p> <pre><code>try:\n    # Example of invalid filter column\n    invalid_filter_config = FilterConfig(non_existent_column=None)\nexcept ValueError as e:\n    print(e)  # Output: Invalid filter column 'non_existent_column': not found in model\n</code></pre>"},{"location":"advanced/endpoint/#sorting-results","title":"Sorting Results","text":"<p>FastCRUD automatically provides sorting functionality for the \"read multiple\" endpoint through the <code>sort</code> query parameter. This allows clients to control the ordering of returned results.</p>"},{"location":"advanced/endpoint/#basic-sorting","title":"Basic Sorting","text":"<p>Sort by a single field in ascending order: <pre><code>GET /items?sort=name\n</code></pre></p> <p>Sort by a single field in descending order (use <code>-</code> prefix): <pre><code>GET /items?sort=-price\n</code></pre></p>"},{"location":"advanced/endpoint/#multi-field-sorting","title":"Multi-field Sorting","text":"<p>Sort by multiple fields by separating them with commas: <pre><code>GET /items?sort=category,name\n</code></pre></p> <p>Mix ascending and descending orders: <pre><code>GET /items?sort=category,-price,name\n</code></pre> This sorts by: 1. <code>category</code> (ascending) 2. <code>price</code> (descending) 3. <code>name</code> (ascending)</p>"},{"location":"advanced/endpoint/#sorting-format","title":"Sorting Format","text":"<p>The sort parameter accepts the following format: - Field names separated by commas: <code>field1,field2,field3</code> - Prefix with <code>-</code> for descending order: <code>-field1,field2,-field3</code> - No spaces around commas - Field names must match your model's column names</p>"},{"location":"advanced/endpoint/#error-handling","title":"Error Handling","text":"<p>If you specify an invalid column name that doesn't exist in your model, FastCRUD will return a 400 Bad Request error with details about the invalid column.</p>"},{"location":"advanced/endpoint/#combining-with-other-parameters","title":"Combining with Other Parameters","text":"<p>Sorting can be combined with pagination and filtering:</p> <pre><code>GET /items?sort=-created_at&amp;page=1&amp;itemsPerPage=10&amp;category=Books\n</code></pre> <p>This example: - Sorts by <code>created_at</code> in descending order (newest first) - Returns the first page with 10 items per page - Filters for items in the \"Books\" category</p>"},{"location":"advanced/endpoint/#server-side-field-injection","title":"Server-Side Field Injection","text":"<p>FastCRUD provides automatic field injection through <code>CreateConfig</code>, <code>UpdateConfig</code>, and <code>DeleteConfig</code> classes. This feature allows you to automatically inject values for fields before data is written to the database, perfect for authentication context, timestamps, and audit fields.</p>"},{"location":"advanced/endpoint/#when-to-use-server-side-field-injection","title":"When to Use Server-Side Field Injection","text":"<p>This feature is essential for building secure, multi-user applications where you need to:</p>"},{"location":"advanced/endpoint/#1-prevent-security-vulnerabilities","title":"1. Prevent Security Vulnerabilities","text":"<p>When you have user-specific data that should never be set by the frontend:</p> <pre><code># SECURITY RISK: Frontend can set any user_id\nclass ItemCreateSchema(BaseModel):\n    name: str\n    user_id: int  # Frontend could submit ANY user ID!\n\n# SECURE: user_id automatically injected from auth context\nclass ItemCreateSchema(BaseModel):\n    name: str\n    # user_id excluded - comes from authentication\n\ncreate_config = CreateConfig(\n    auto_fields={\n        \"user_id\": get_current_user_id,  # From JWT/session\n    },\n    exclude_from_schema=[\"user_id\"]  # Hidden from API docs\n)\n</code></pre>"},{"location":"advanced/endpoint/#2-automatic-audit-trails","title":"2. Automatic Audit Trails","text":"<p>For compliance and debugging, automatically track who changed what and when:</p> <pre><code># Automatically adds audit fields to every record\ncreate_config = CreateConfig(\n    auto_fields={\n        \"created_by\": get_current_user_id,\n        \"created_at\": get_current_timestamp,\n        \"ip_address\": get_client_ip,\n        \"user_agent\": get_user_agent,\n    },\n    exclude_from_schema=[\"created_by\", \"created_at\", \"ip_address\", \"user_agent\"]\n)\n\nupdate_config = UpdateConfig(\n    auto_fields={\n        \"updated_by\": get_current_user_id,\n        \"updated_at\": get_current_timestamp,\n    },\n    exclude_from_schema=[\"updated_by\", \"updated_at\"]\n)\n</code></pre>"},{"location":"advanced/endpoint/#3-multi-tenant-applications","title":"3. Multi-Tenant Applications","text":"<p>Automatically scope data to the correct organization/tenant:</p> <pre><code>async def get_current_org_id(user: User = Depends(get_current_user)):\n    return user.organization_id\n\ncreate_config = CreateConfig(\n    auto_fields={\n        \"organization_id\": get_current_org_id,  # Auto-scoped\n        \"user_id\": lambda user=Depends(get_current_user): user.id,\n    },\n    exclude_from_schema=[\"organization_id\", \"user_id\"]\n)\n\n# Combined with filtering - users only see their org's data\nrouter = crud_router(\n    # ... other params\n    create_config=create_config,\n    filter_config=FilterConfig(organization_id=get_current_org_id),\n)\n</code></pre>"},{"location":"advanced/endpoint/#4-workflow-and-status-management","title":"4. Workflow and Status Management","text":"<p>Automatically set status fields based on business logic:</p> <pre><code>def get_initial_status():\n    return \"pending_review\"\n\nasync def get_approver_id(user: User = Depends(get_current_user)):\n    if user.role == \"admin\":\n        return None  # Admins auto-approve\n    return user.manager_id\n\ncreate_config = CreateConfig(\n    auto_fields={\n        \"status\": get_initial_status,\n        \"assigned_to\": get_approver_id,\n        \"submitted_by\": get_current_user_id,\n    }\n)\n</code></pre>"},{"location":"advanced/endpoint/#5-preventing-data-tampering","title":"5. Preventing Data Tampering","text":"<p>When you need to ensure certain fields can only be set server-side:</p> <pre><code># Frontend cannot manipulate pricing or financial data\ncreate_config = CreateConfig(\n    auto_fields={\n        \"price\": calculate_dynamic_price,     # Based on business rules\n        \"discount\": get_user_discount_rate,   # Based on user tier\n        \"tax_rate\": get_applicable_tax_rate,  # Based on location\n    },\n    exclude_from_schema=[\"price\", \"discount\", \"tax_rate\"]\n)\n</code></pre>"},{"location":"advanced/endpoint/#common-use-cases-for-server-side-field-injection","title":"Common Use Cases for Server-Side Field Injection","text":"<p>Server-side field injection is particularly valuable in these common scenarios. The following table provides a quick overview of the most frequent use cases and their solutions:</p> Scenario Problem Solution User Items Frontend could create items for other users Auto-inject <code>user_id</code> from authentication Audit Logs Manual timestamp/user tracking is error-prone Auto-inject <code>created_by</code>, <code>created_at</code>, etc. Multi-Tenant Users could access other organizations' data Auto-inject <code>organization_id</code> + filter by it Approval Workflows Need to track who submitted what when Auto-inject submitter, timestamp, initial status Financial Data Pricing must be server-controlled Auto-calculate and inject prices, taxes, discounts Content Moderation All posts need initial review status Auto-inject <code>status: \"pending\"</code> <p>These scenarios address security and data integrity requirements where client-provided data cannot be trusted or where server-side business logic must control field values. Automatic field injection prevents manual validation errors and ensures consistent data handling.</p> <p>Below are detailed examples and explanations for each scenario:</p>"},{"location":"advanced/endpoint/#user-scoped-data","title":"User-Scoped Data","text":"<p>Problem: Frontend applications can potentially create data for other users by manipulating user IDs in requests.</p> <p>Solution: Auto-inject the authenticated user's ID from the session/JWT token.</p> <pre><code>create_config = CreateConfig(\n    auto_fields={\"user_id\": get_current_user_id},\n    exclude_from_schema=[\"user_id\"]\n)\n</code></pre> <p>This ensures that when a user creates an item, it's automatically associated with their account, preventing unauthorized data creation.</p>"},{"location":"advanced/endpoint/#audit-trail-requirements","title":"Audit Trail Requirements","text":"<p>Problem: Manual tracking of who modified what and when is error-prone and often forgotten.</p> <p>Solution: Automatically inject audit fields for every operation.</p> <pre><code>create_config = CreateConfig(\n    auto_fields={\n        \"created_by\": get_current_user_id,\n        \"created_at\": get_current_timestamp,\n        \"created_ip\": get_client_ip,\n    }\n)\n\nupdate_config = UpdateConfig(\n    auto_fields={\n        \"updated_by\": get_current_user_id, \n        \"updated_at\": get_current_timestamp,\n    }\n)\n</code></pre> <p>Perfect for compliance requirements, debugging, and maintaining data lineage.</p>"},{"location":"advanced/endpoint/#multi-tenant-applications","title":"Multi-Tenant Applications","text":"<p>Problem: In multi-tenant systems, users could potentially access or modify data from other organizations.</p> <p>Solution: Auto-inject organization/tenant identifiers and combine with filtering.</p> <pre><code>create_config = CreateConfig(\n    auto_fields={\"organization_id\": get_current_org_id},\n    exclude_from_schema=[\"organization_id\"]\n)\n\n# Also filter reads by organization\nrouter = crud_router(\n    # ... other config\n    filter_config=FilterConfig(organization_id=get_current_org_id)\n)\n</code></pre> <p>This creates complete data isolation between tenants automatically.</p>"},{"location":"advanced/endpoint/#approval-and-workflow-systems","title":"Approval and Workflow Systems","text":"<p>Problem: Tracking submission details, approval status, and workflow state requires consistent data entry.</p> <p>Solution: Auto-inject workflow metadata based on business rules.</p> <pre><code>async def determine_initial_status(user = Depends(get_current_user)):\n    if user.role == \"admin\":\n        return \"approved\"\n    return \"pending_review\"\n\ncreate_config = CreateConfig(\n    auto_fields={\n        \"status\": determine_initial_status,\n        \"submitted_by\": get_current_user_id,\n        \"submitted_at\": get_current_timestamp,\n    }\n)\n</code></pre> <p>Ensures consistent workflow state management without manual intervention.</p>"},{"location":"advanced/endpoint/#financial-and-pricing-data","title":"Financial and Pricing Data","text":"<p>Problem: Pricing, taxes, and financial calculations must be controlled server-side to prevent manipulation.</p> <p>Solution: Auto-calculate and inject financial fields based on business logic.</p> <pre><code>async def calculate_price(item_data, user = Depends(get_current_user)):\n    base_price = get_base_price(item_data.product_id)\n    user_discount = get_user_discount_rate(user.tier)\n    return base_price * (1 - user_discount)\n\ncreate_config = CreateConfig(\n    auto_fields={\n        \"price\": calculate_price,\n        \"tax_rate\": get_applicable_tax_rate,\n        \"currency\": lambda: \"USD\",\n    },\n    exclude_from_schema=[\"price\", \"tax_rate\", \"currency\"]\n)\n</code></pre> <p>Prevents price manipulation while ensuring accurate calculations.</p>"},{"location":"advanced/endpoint/#content-moderation","title":"Content Moderation","text":"<p>Problem: User-generated content needs consistent initial moderation status and safety checks.</p> <p>Solution: Auto-inject moderation fields and initial review status.</p> <pre><code>async def get_initial_moderation_status(content: str):\n    if contains_flagged_content(content):\n        return \"requires_review\"\n    return \"approved\"\n\ncreate_config = CreateConfig(\n    auto_fields={\n        \"moderation_status\": get_initial_moderation_status,\n        \"flagged_at\": lambda: None,  # Will be set later if flagged\n        \"reviewed_by\": lambda: None,  # Will be set when reviewed\n    }\n)\n</code></pre> <p>Ensures all content goes through proper moderation workflows automatically.</p>"},{"location":"advanced/endpoint/#real-world-example","title":"Real-World Example","text":"<p>Here's a complete example for a multi-user blog application:</p> <pre><code>from datetime import datetime\nfrom fastapi import Depends, HTTPException\nfrom fastcrud import crud_router, CreateConfig, UpdateConfig, FilterConfig\n\n# Authentication dependency\nasync def get_current_user(token: str = Depends(oauth2_scheme)):\n    user = await verify_jwt_token(token)\n    if not user:\n        raise HTTPException(401, \"Invalid token\")\n    return user\n\n# Auto-field functions\nasync def get_user_id(user = Depends(get_current_user)):\n    return user.id\n\nasync def get_user_org(user = Depends(get_current_user)):\n    return user.organization_id\n\ndef get_timestamp():\n    return datetime.utcnow()\n\ndef get_initial_post_status():\n    return \"draft\"  # All posts start as drafts\n\n# Schema - notice what's missing!\nclass PostCreateSchema(BaseModel):\n    title: str\n    content: str\n    # NO user_id, organization_id, timestamps, etc.\n\n# Configuration\ncreate_config = CreateConfig(\n    auto_fields={\n        \"author_id\": get_user_id,           # Who wrote it\n        \"organization_id\": get_user_org,     # Which org\n        \"status\": get_initial_post_status,   # Initial state\n        \"created_at\": get_timestamp,         # When\n        \"version\": lambda: 1,                # Version control\n    },\n    exclude_from_schema=[\n        \"author_id\", \"organization_id\", \"status\",\n        \"created_at\", \"version\"\n    ]\n)\n\nupdate_config = UpdateConfig(\n    auto_fields={\n        \"updated_at\": get_timestamp,\n        \"updated_by\": get_user_id,\n    },\n    exclude_from_schema=[\"updated_at\", \"updated_by\"]\n)\n\n# Router with automatic security\nrouter = crud_router(\n    session=get_db,\n    model=Post,\n    create_schema=PostCreateSchema,\n    update_schema=PostUpdateSchema,\n    create_config=create_config,\n    update_config=update_config,\n    # Users only see posts from their organization\n    filter_config=FilterConfig(organization_id=get_user_org),\n)\n</code></pre> <p>Result:</p> <ul> <li>Users can only create posts for themselves</li> <li>All posts are automatically scoped to their organization</li> <li>Complete audit trail is maintained</li> <li>Frontend cannot tamper with sensitive fields</li> <li>Clean API schema without clutter</li> </ul>"},{"location":"advanced/endpoint/#auto-field-injection","title":"Auto Field Injection","text":"<p>Auto fields are automatically injected values that are added to your data before it's written to the database. These values are provided by callable functions that can use FastAPI's dependency injection system.</p>"},{"location":"advanced/endpoint/#createconfig","title":"CreateConfig","text":"<p>Use <code>CreateConfig</code> to inject fields during create operations:</p> <pre><code>from datetime import datetime\nfrom fastapi import Depends, Cookie\nfrom fastcrud import crud_router, CreateConfig\n\n# Functions that return values (can use Depends for DI)\nasync def get_current_user_id(session_token: str = Cookie(None)):\n    user = await verify_token(session_token)\n    return user.id\n\ndef get_current_timestamp():\n    return datetime.utcnow()\n\ncreate_config = CreateConfig(\n    auto_fields={\n        \"user_id\": get_current_user_id,      # Injected from cookie\n        \"created_by\": get_current_user_id,   # Same user\n        \"created_at\": get_current_timestamp, # Timestamp\n    },\n    exclude_from_schema=[\"user_id\", \"created_by\", \"created_at\"]\n)\n\nrouter = crud_router(\n    session=get_db,\n    model=Item,\n    create_schema=CreateItemSchema,  # Does NOT include auto fields\n    update_schema=UpdateItemSchema,\n    create_config=create_config,\n)\n</code></pre>"},{"location":"advanced/endpoint/#updateconfig","title":"UpdateConfig","text":"<p>Use <code>UpdateConfig</code> to inject fields during update operations:</p> <pre><code>update_config = UpdateConfig(\n    auto_fields={\n        \"updated_by\": get_current_user_id,\n        \"updated_at\": get_current_timestamp,\n    },\n    exclude_from_schema=[\"updated_by\", \"updated_at\", \"user_id\"]\n)\n\nrouter = crud_router(\n    session=get_db,\n    model=Item,\n    create_schema=CreateItemSchema,\n    update_schema=UpdateItemSchema,\n    update_config=update_config,\n)\n</code></pre>"},{"location":"advanced/endpoint/#deleteconfig","title":"DeleteConfig","text":"<p>Use <code>DeleteConfig</code> to inject fields during soft delete operations:</p> <pre><code>delete_config = DeleteConfig(\n    auto_fields={\n        \"deleted_by\": get_current_user_id,\n        \"deleted_at\": get_current_timestamp,\n    }\n)\n\nrouter = crud_router(\n    session=get_db,\n    model=Item,\n    create_schema=CreateItemSchema,\n    update_schema=UpdateItemSchema,\n    delete_config=delete_config,\n)\n</code></pre>"},{"location":"advanced/endpoint/#schema-exclusion","title":"Schema Exclusion","text":"<p>The <code>exclude_from_schema</code> parameter removes fields from the request schema, preventing them from appearing in API documentation and ensuring clients cannot manually set these values:</p> <pre><code>create_config = CreateConfig(\n    auto_fields={\n        \"user_id\": get_current_user_id,\n        \"created_at\": get_current_timestamp,\n    },\n    exclude_from_schema=[\"user_id\", \"created_at\"]  # Hidden from API docs\n)\n</code></pre>"},{"location":"advanced/endpoint/#authorization-and-validation","title":"Authorization and Validation","text":"<p>Auto fields can include authorization checks:</p> <pre><code>async def check_can_delete(\n    session_token: str = Cookie(None),\n    item_id: int = Path(...)\n):\n    user = await verify_token(session_token)\n    if not user.can_delete:\n        raise HTTPException(403, \"Not authorized to delete\")\n    return user.id\n\ndelete_config = DeleteConfig(\n    auto_fields={\n        \"deleted_by\": check_can_delete,  # Includes auth check\n    }\n)\n</code></pre>"},{"location":"advanced/endpoint/#multiple-auto-fields","title":"Multiple Auto Fields","text":"<p>You can inject multiple fields simultaneously:</p> <pre><code>create_config = CreateConfig(\n    auto_fields={\n        \"user_id\": get_current_user_id,\n        \"organization_id\": get_current_org_id,\n        \"created_at\": get_current_timestamp,\n        \"created_by\": get_current_user_id,\n        \"version\": lambda: \"1.0\",\n    }\n)\n</code></pre>"},{"location":"advanced/endpoint/#using-with-endpointcreator","title":"Using with EndpointCreator","text":"<p>All configuration classes work with both <code>crud_router</code> and <code>EndpointCreator</code>:</p> <pre><code>from fastcrud import EndpointCreator\n\nendpoint_creator = EndpointCreator(\n    session=get_db,\n    model=Item,\n    create_schema=CreateItemSchema,\n    update_schema=UpdateItemSchema,\n    create_config=create_config,\n    update_config=update_config,\n    delete_config=delete_config,\n)\n\nendpoint_creator.add_routes_to_router()\napp.include_router(endpoint_creator.router, prefix=\"/items\")\n</code></pre>"},{"location":"advanced/endpoint/#benefits_1","title":"Benefits","text":"<ul> <li>Security: Prevent clients from setting sensitive fields like user_id or audit timestamps</li> <li>Automation: Automatically populate fields without manual intervention</li> <li>Consistency: Ensure all records have proper audit trails and ownership</li> <li>Flexibility: Use FastAPI's dependency injection for complex value resolution</li> <li>Clean APIs: Keep auto-injected fields hidden from API documentation</li> </ul>"},{"location":"advanced/endpoint/#conclusion","title":"Conclusion","text":"<p>The <code>EndpointCreator</code> class in FastCRUD offers flexibility and control over CRUD operations and custom endpoint creation. By extending this class or using the <code>included_methods</code> and <code>deleted_methods</code> parameters, you can tailor your API's functionality to your specific requirements, ensuring a more customizable and streamlined experience.</p>"},{"location":"advanced/filters/","title":"Advanced Filtering","text":"<p>The <code>_parse_filters</code> method in FastCRUD supports complex filtering operations including OR and NOT conditions.</p>"},{"location":"advanced/filters/#basic-usage","title":"Basic Usage","text":"<p>Filters are specified as keyword arguments in the format <code>field_name__operator=value</code>:</p> <pre><code># Simple equality filter\nresults = await crud.get_multi(db, name=\"John\")\n\n# Comparison operators\nresults = await crud.get_multi(db, age__gt=18)\n</code></pre>"},{"location":"advanced/filters/#or-operations","title":"OR Operations","text":""},{"location":"advanced/filters/#single-field-or","title":"Single Field OR","text":"<p>Use the <code>__or</code> suffix to apply multiple conditions to the same field with OR logic:</p> <pre><code># Find users aged under 18 OR over 65\nresults = await crud.get_multi(\n    db,\n    age__or={\n        \"lt\": 18,\n        \"gt\": 65\n    }\n)\n# Generates: WHERE age &lt; 18 OR age &gt; 65\n</code></pre> <p>You can also provide a list of values for the same operator to create multiple OR conditions:</p> <pre><code># Find users with names starting with Alice OR Frank OR Bob\nresults = await crud.get_multi(\n    db,\n    name__or={\n        \"like\": [\"Alice%\", \"Frank%\", \"Bob%\"]\n    }\n)\n# Generates: WHERE name LIKE 'Alice%' OR name LIKE 'Frank%' OR name LIKE 'Bob%'\n\n# Mix list and single values in OR conditions\nresults = await crud.get_multi(\n    db,\n    name__or={\n        \"like\": [\"Alice%\", \"Frank%\"],  # List of patterns\n        \"startswith\": \"Bob\"             # Single value\n    }\n)\n# Generates: WHERE name LIKE 'Alice%' OR name LIKE 'Frank%' OR name STARTSWITH 'Bob'\n</code></pre>"},{"location":"advanced/filters/#multi-field-or","title":"Multi-Field OR","text":"<p>Use the special <code>_or</code> parameter to apply OR conditions across multiple different fields:</p> <pre><code># Find users with name containing 'john' OR email containing 'john'\nresults = await crud.get_multi(\n    db,\n    _or={\n        \"name__ilike\": \"%john%\",\n        \"email__ilike\": \"%john%\"\n    }\n)\n# Generates: WHERE name ILIKE '%john%' OR email ILIKE '%john%'\n</code></pre> <p>This is particularly useful for implementing search functionality across multiple fields.</p>"},{"location":"advanced/filters/#not-operations","title":"NOT Operations","text":"<p>Use the <code>__not</code> suffix to negate multiple conditions on the same field:</p> <pre><code># Find users NOT aged 20 AND NOT between 30-40\nresults = await crud.get_multi(\n    db,\n    age__not={\n        \"eq\": 20,\n        \"between\": (30, 40)\n    }\n)\n# Generates: WHERE NOT age = 20 AND NOT (age BETWEEN 30 AND 40)\n</code></pre> <p>Similar to OR operations, you can provide a list of values for the same operator in NOT conditions:</p> <pre><code># Find users whose names do NOT start with Alice, Frank, or Bob\nresults = await crud.get_multi(\n    db,\n    name__not={\n        \"like\": [\"Alice%\", \"Frank%\", \"Bob%\"]\n    }\n)\n# Generates: WHERE NOT (name LIKE 'Alice%') AND NOT (name LIKE 'Frank%') AND NOT (name LIKE 'Bob%')\n</code></pre>"},{"location":"advanced/filters/#supported-operators","title":"Supported Operators","text":"<ul> <li>Comparison: <code>eq</code>, <code>gt</code>, <code>lt</code>, <code>gte</code>, <code>lte</code>, <code>ne</code></li> <li>Null checks: <code>is</code>, <code>is_not</code></li> <li>Text matching: <code>like</code>, <code>notlike</code>, <code>ilike</code>, <code>notilike</code>, <code>startswith</code>, <code>endswith</code>, <code>contains</code>, <code>match</code></li> <li>Collections: <code>in</code>, <code>not_in</code>, <code>between</code></li> <li>Logical: <code>or</code>, <code>not</code></li> </ul>"},{"location":"advanced/filters/#examples","title":"Examples","text":"<pre><code># Complex age filtering\nresults = await crud.get_multi(\n    db,\n    age__or={\n        \"between\": (20, 30),\n        \"eq\": 18\n    },\n    status__not={\n        \"in\": [\"inactive\", \"banned\"]\n    }\n)\n\n# Text search with OR conditions on a single field\nresults = await crud.get_multi(\n    db,\n    name__or={\n        \"startswith\": \"A\",\n        \"endswith\": \"smith\"\n    }\n)\n\n# Search for multiple patterns with LIKE operator\nresults = await crud.get_multi(\n    db,\n    name__or={\n        \"like\": [\"Alice%\", \"Bob%\", \"Charlie%\"]\n    }\n)\n\n# Combine multiple operators including lists\nresults = await crud.get_multi(\n    db,\n    email__or={\n        \"ilike\": [\"%gmail.com\", \"%yahoo.com\"],  # Multiple email domains\n        \"endswith\": \".edu\"                      # OR educational emails\n    }\n)\n\n# Search across multiple fields with the same keyword\nkeyword = \"john\"\nresults = await crud.get_multi(\n    db,\n    _or={\n        \"name__ilike\": f\"%{keyword}%\",\n        \"email__ilike\": f\"%{keyword}%\",\n        \"phone__ilike\": f\"%{keyword}%\",\n        \"address__ilike\": f\"%{keyword}%\"\n    }\n)\n\n# Combining multi-field OR with regular filters\nresults = await crud.get_multi(\n    db,\n    is_active=True,  # Regular filter applied to all results\n    _or={\n        \"name__ilike\": \"%search term%\",\n        \"description__ilike\": \"%search term%\"\n    }\n)\n</code></pre>"},{"location":"advanced/filters/#error-handling","title":"Error Handling","text":"<ul> <li>Invalid column names raise <code>ValueError</code></li> <li>Invalid operators are ignored</li> <li>Invalid value types for operators (e.g., non-list for <code>between</code>) raise <code>ValueError</code></li> </ul>"},{"location":"advanced/joins/","title":"Comprehensive Guide to Joins in FastCRUD","text":"<p>FastCRUD simplifies CRUD operations while offering capabilities for handling complex data relationships. This guide thoroughly explores the use of <code>JoinConfig</code> for executing join operations in FastCRUD methods such as <code>count</code>, <code>get_joined</code>, and <code>get_multi_joined</code>, alongside simplified join techniques for straightforward scenarios.</p>"},{"location":"advanced/joins/#understanding-joinconfig","title":"Understanding <code>JoinConfig</code>","text":"<p><code>JoinConfig</code> is a detailed configuration mechanism for specifying joins between models in FastCRUD queries. It contains the following key attributes:</p> <ul> <li><code>model</code>: The SQLAlchemy model to join.</li> <li><code>join_on</code>: The condition defining how the join connects to other models.</li> <li><code>join_prefix</code>: An optional prefix for the joined columns to avoid column name conflicts.</li> <li><code>schema_to_select</code>: An optional Pydantic schema for selecting specific columns from the joined model.</li> <li><code>join_type</code>: The type of join (e.g., <code>\"left\"</code>, <code>\"inner\"</code>).</li> <li><code>alias</code>: An optional SQLAlchemy <code>AliasedClass</code> for complex scenarios like self-referential joins or multiple joins on the same model.</li> <li><code>filters</code>: An optional dictionary to apply filters directly to the joined model.</li> <li><code>relationship_type</code>: Specifies the relationship type, such as <code>\"one-to-one\"</code> or <code>\"one-to-many\"</code>. Default is <code>\"one-to-one\"</code>.</li> <li><code>sort_columns</code>: An optional column name or list of column names to sort the nested items by. Only applies to <code>\"one-to-many\"</code> relationships.</li> <li><code>sort_orders</code>: An optional sort order (<code>\"asc\"</code> or <code>\"desc\"</code>) or list of sort orders corresponding to the columns in <code>sort_columns</code>. If not provided, defaults to <code>\"asc\"</code> for each column.</li> </ul> <p>Tip</p> <p>For <code>\"many-to-many\"</code>, you don't need to pass a <code>relationship_type</code>.</p>"},{"location":"advanced/joins/#understanding-countconfig","title":"Understanding <code>CountConfig</code>","text":"<p><code>CountConfig</code> is a configuration mechanism for counting related objects in joined queries. This is particularly useful for many-to-many relationships where you want to include counts of related objects without actually joining the data. It contains the following key attributes:</p> <ul> <li><code>model</code>: The SQLAlchemy model to count.</li> <li><code>join_on</code>: The condition defining how the count query connects to the primary model.</li> <li><code>alias</code>: An optional alias for the count column in the result. Defaults to <code>\"{model.__tablename__}_count\"</code>.</li> <li><code>filters</code>: An optional dictionary to apply filters directly to the count query.</li> </ul> <p>The count is implemented as a scalar subquery, which means all records from the primary model will be returned with their respective counts (including 0 for records with no related objects).</p>"},{"location":"advanced/joins/#applying-joins-in-fastcrud-methods","title":"Applying Joins in FastCRUD Methods","text":"Models - <code>Tier</code>, <code>Department</code>, <code>User</code>, <code>Story</code>, <code>Task</code> <code>tier/model.py</code> <pre><code>from sqlalchemy import Column, Integer, String\nfrom sqlalchemy.orm import DeclarativeBase\n\n\nclass Base(DeclarativeBase):\n    pass\n\n\nclass Tier(Base):\n    __tablename__ = \"tier\"\n    id = Column(Integer, primary_key=True)\n    name = Column(String, unique=True)\n</code></pre> <code>department/model.py</code> <pre><code>from sqlalchemy import Column, Integer, String\nfrom sqlalchemy.orm import DeclarativeBase\n\n\nclass Base(DeclarativeBase):\n    pass\n\n\nclass Department(Base):\n    __tablename__ = \"department\"\n    id = Column(Integer, primary_key=True)\n    name = Column(String)\n</code></pre> <code>user/model.py</code> <pre><code>from sqlalchemy import (\n    Boolean,\n    Column,\n    DateTime,\n    ForeignKey,\n    Integer,\n    String,\n    func,\n)\nfrom sqlalchemy.orm import DeclarativeBase\n\n\nclass Base(DeclarativeBase):\n    pass\n\n\nclass User(Base):\n    __tablename__ = \"user\"\n    id = Column(Integer, primary_key=True)\n    name = Column(String)\n    username = Column(String)\n    email = Column(String)\n    age = Column(Integer)\n    role = Column(String)\n    tier_id = Column(Integer, ForeignKey(\"tier.id\"))\n    department_id = Column(Integer, ForeignKey(\"department.id\"))\n    manager_id = Column(Integer, ForeignKey(\"user.id\"))\n    is_active = Column(Boolean, default=True)\n    is_superuser = Column(Boolean, default=False)\n    registration_date = Column(DateTime, default=func.now())\n    archived = Column(Boolean, default=False)\n    archived_at = Column(DateTime)\n</code></pre> <code>story/model.py</code> <pre><code>from sqlalchemy import Column, Integer, String\nfrom sqlalchemy.orm import DeclarativeBase\n\n\nclass Base(DeclarativeBase):\n    pass\n\n\nclass Story(Base):\n    __tablename__ = \"story\"\n    id = Column(Integer, primary_key=True)\n    name = Column(String)\n</code></pre> <code>task/model.py</code> <pre><code>from sqlalchemy import Column, ForeignKey, Integer, String\nfrom sqlalchemy.orm import DeclarativeBase\n\n\nclass Base(DeclarativeBase):\n    pass\n\n\nclass Task(Base):\n    __tablename__ = \"task\"\n    id = Column(Integer, primary_key=True)\n    creator_id = Column(Integer, ForeignKey(\"user.id\"))\n    owner_id = Column(Integer, ForeignKey(\"user.id\"))\n    assigned_user_id = Column(Integer, ForeignKey(\"user.id\"))\n    story_id = Column(Integer, ForeignKey(\"story.id\"))\n    status = Column(String)\n    priority = Column(String)\n</code></pre>"},{"location":"advanced/joins/#the-count-method-with-joins","title":"The <code>count</code> Method with Joins","text":"<p>The <code>count</code> method can be enhanced with join operations to perform complex aggregate queries. While <code>count</code> primarily returns the number of records matching a given condition, introducing joins allows for counting records across related models based on specific relationships and conditions.</p>"},{"location":"advanced/joins/#using-joinconfig","title":"Using <code>JoinConfig</code>","text":"<p>For join requirements, the <code>count</code> method can be invoked with join parameters passed as a list of <code>JoinConfig</code> to the <code>joins_config</code> parameter:</p> <pre><code>from fastcrud import JoinConfig\n\ntask_crud = FastCRUD(Task)\n\n# Count the number of tasks assigned to users in a specific department\ntask_count = await task_crud.count(\n    db=db,\n    joins_config=[\n        JoinConfig(\n            model=User,\n            join_on=Task.assigned_user_id == User.id,\n        ),\n        JoinConfig(\n            model=Department,\n            join_on=User.department_id == Department.id,\n            filters={\"name\": \"Engineering\"},\n        ),\n    ],\n)\n</code></pre>"},{"location":"advanced/joins/#fetching-data-with-get_joined-and-get_multi_joined","title":"Fetching Data with <code>get_joined</code> and <code>get_multi_joined</code>","text":"<p>These methods are essential for retrieving records from a primary model while including related data from one or more joined models. They support both simple and complex joining scenarios, including self-referential joins and many-to-many relationships.</p>"},{"location":"advanced/joins/#simple-joins-using-base-parameters","title":"Simple Joins Using Base Parameters","text":"<p>For simpler join requirements, FastCRUD allows specifying join parameters directly:</p> <ul> <li><code>join_model</code>: The target model to join.</li> <li><code>join_on</code>: The join condition.</li> <li><code>join_prefix</code>: Optional prefix for columns from the joined model.</li> <li><code>join_schema_to_select</code>: An optional Pydantic schema for selecting specific columns from the joined model.</li> <li><code>join_type</code>: Specifies the SQL join type.</li> <li><code>alias</code>: An optional SQLAlchemy <code>AliasedClass</code> for complex scenarios like self-referential joins or multiple joins on the same model.</li> <li><code>join_filters</code>: Additional filters for the joined model.</li> </ul>"},{"location":"advanced/joins/#examples-of-simple-joining","title":"Examples of Simple Joining","text":"<pre><code># Fetch tasks with assigned user details, specifying a left join\ntasks_with_users = await task_crud.get_joined(\n    db=db,\n    join_model=User,\n    join_on=Task.assigned_user_id == User.id,\n    join_type=\"left\",\n)\n</code></pre>"},{"location":"advanced/joins/#getting-joined-data-nested","title":"Getting Joined Data Nested","text":"<p>Note that by default, <code>FastCRUD</code> joins all the data and returns it in a single dictionary.</p> <p>Let's take two of the tables from above and join them with <code>FastCRUD</code>:</p> <pre><code>user_crud = FastCRUD(User)\nuser_tier = await user_crud.get_joined(\n    db=db,\n    join_model=Tier,\n    join_on=User.tier_id == Tier.id,\n    join_prefix=\"tier_\",\n    join_type=\"left\",\n    id=1,\n)\n</code></pre> <p>We'll get:</p> <pre><code>{\n    \"id\": 1,\n    \"name\": \"Example\",\n    \"tier_id\": 1,\n    \"tier_name\": \"Free\"\n}\n</code></pre> <p>If you want the joined data in a nested dictionary instead, you may just pass <code>nest_joins=True</code>:</p> <pre><code>user_tier = await user_crud.get_joined(\n    db=db,\n    join_model=Tier,\n    join_on=User.tier_id == Tier.id,\n    join_prefix=\"tier_\",\n    join_type=\"left\",\n    nest_joins=True,\n    id=1,\n)\n</code></pre> <p>And you will get:</p> <pre><code>{\n    \"id\": 1,\n    \"name\": \"Example\",\n    \"tier\": {\n        \"id\": 1,\n        \"name\": \"Free\"\n    }\n}\n</code></pre> <p>This works for both <code>get_joined</code> and <code>get_multi_joined</code>.</p> <p>Warning</p> <p>Note that the final <code>\"_\"</code> in the passed <code>\"tier_\"</code> is stripped.</p> <p>join_prefix and return_as_model Compatibility</p> <p>When using <code>return_as_model=True</code> with <code>nest_joins=True</code>, ensure that your <code>join_prefix</code> (minus trailing \"_\") matches the field name in your Pydantic schema. Otherwise, FastCRUD will raise a <code>ValueError</code> with clear guidance on how to fix the mismatch.</p> <p>\u274c This will raise an error: <pre><code># Schema expects \"children\" field\nclass ParentRead(BaseModel):\n    children: list[ChildRead] = []\n\n# But join_prefix creates \"child\" key\njoin_config = JoinConfig(\n    join_prefix=\"child_\",  # Creates \"child\" key\n    relationship_type=\"one-to-many\"\n)\n\nresult = await crud.get_joined(\n    return_as_model=True,  # Will raise ValueError\n    nest_joins=True,\n    joins_config=[join_config]\n)\n# Error: join_prefix 'child_' creates key 'child' which is not a field in schema ParentRead\n</code></pre></p> <p>\u2705 This works correctly: <pre><code># Match the schema field name\njoin_config = JoinConfig(\n    join_prefix=\"children_\",  # Creates \"children\" key to match schema\n    relationship_type=\"one-to-many\"\n)\n\nresult = await crud.get_joined(\n    return_as_model=True,\n    nest_joins=True,\n    joins_config=[join_config]\n)\n# Result: ParentRead(children=[...actual children...])\n</code></pre></p>"},{"location":"advanced/joins/#complex-joins-using-joinconfig","title":"Complex Joins Using <code>JoinConfig</code>","text":"<p>When dealing with more complex join conditions, such as multiple joins, self-referential joins, or needing to specify aliases and filters, <code>JoinConfig</code> instances become the norm. They offer granular control over each join's aspects, enabling precise and efficient data retrieval.</p> <p>Example:</p> <code>user/schemas.py</code> Excerpt <pre><code>class ReadUserSchema(BaseModel):\n    id: int\n    name: str | None = None\n    username: str | None = None\n    email: str | None = None\n    age: int | None = None\n    role: str | None = None\n    tier_id: int | None = None\n    department_id: int | None = None\n    manager_id: int | None = None\n    is_active: bool\n    is_superuser: bool\n    registration_date: datetime.datetime\n    archived: bool\n    archived_at: datetime.datetime | None = None\n</code></pre> <pre><code># Fetch users with details from related departments and tiers, using aliases for self-referential joins\nfrom fastcrud import aliased\n\nmanager_alias = aliased(User)\n\nusers = await user_crud.get_multi_joined(\n    db=db,\n    schema_to_select=ReadUserSchema,\n    joins_config=[\n        JoinConfig(\n            model=Department,\n            join_on=User.department_id == Department.id,\n            join_prefix=\"dept_\",\n        ),\n        JoinConfig(\n            model=Tier,\n            join_on=User.tier_id == Tier.id,\n            join_prefix=\"tier_\",\n        ),\n        JoinConfig(\n            model=User,\n            alias=manager_alias,\n            join_on=User.manager_id == manager_alias.id,\n            join_prefix=\"manager_\",\n        ),\n    ],\n)\n</code></pre>"},{"location":"advanced/joins/#handling-one-to-one-and-one-to-many-joins-in-fastcrud","title":"Handling One-to-One and One-to-Many Joins in FastCRUD","text":"<p>FastCRUD provides flexibility in handling one-to-one and one-to-many relationships through <code>get_joined</code> and <code>get_multi_joined</code> methods, along with the ability to specify how joined data should be structured using both the <code>relationship_type</code> (default <code>\"one-to-one\"</code>) and the <code>nest_joins</code> (default <code>False</code>) parameters.</p>"},{"location":"advanced/joins/#one-to-one-relationships","title":"One-to-One Relationships","text":"<ul> <li><code>get_joined</code>: Fetch a single record and its directly associated record (e.g., a user and their profile).</li> <li><code>get_multi_joined</code> (with <code>nest_joins=False</code>): Retrieve multiple records, each linked to a single related record from another table (e.g., users and their profiles).</li> </ul>"},{"location":"advanced/joins/#example","title":"Example","text":"<p>Let's take two of the tables from above and join them with <code>FastCRUD</code>:</p> <pre><code>user_crud = FastCRUD(User)\nuser_tier = await user_crud.get_joined(\n    db=db,\n    join_model=Tier,\n    join_on=User.tier_id == Tier.id,\n    join_prefix=\"tier_\",\n    join_type=\"left\",\n    id=1,\n)\n</code></pre> <p>The result will be:</p> <pre><code>{\n    \"id\": 1,\n    \"name\": \"Example\",\n    \"tier_id\": 1,\n    \"tier_name\": \"Free\"\n}\n</code></pre>"},{"location":"advanced/joins/#one-to-one-relationship-with-nested-joins","title":"One-to-One Relationship with Nested Joins","text":"<p>To get the joined data in a nested dictionary:</p> <pre><code>user_tier = await user_crud.get_joined(\n    db=db,\n    join_model=Tier,\n    join_on=User.tier_id == Tier.id,\n    join_prefix=\"tier_\",\n    join_type=\"left\",\n    nest_joins=True,\n    id=1,\n)\n</code></pre> <p>The result will be:</p> <pre><code>{\n    \"id\": 1,\n    \"name\": \"Example\",\n    \"tier\": {\n        \"id\": 1,\n        \"name\": \"Free\"\n    }\n}\n</code></pre>"},{"location":"advanced/joins/#one-to-many-relationships","title":"One-to-Many Relationships","text":"<ul> <li><code>get_joined</code> (with <code>nest_joins=True</code>): Retrieve a single record with all its related records nested within it (e.g., a user and all their blog posts).</li> <li><code>get_multi_joined</code> (with <code>nest_joins=True</code>): Fetch multiple primary records, each with their related records nested (e.g., multiple users and all their blog posts).</li> </ul> <p>Warning</p> <p>When using <code>nest_joins=True</code>, the performance will always be a bit worse than when using <code>nest_joins=False</code>. For cases where more performance is necessary, consider using <code>nest_joins=False</code> and remodeling your database.</p>"},{"location":"advanced/joins/#example_1","title":"Example","text":"<p>To demonstrate a one-to-many relationship, let's assume <code>Author</code> and <code>Article</code> tables:</p> <pre><code>class Author(Base):\n    __tablename__ = \"author\"\n    id = Column(Integer, primary_key=True)\n    profile_id = Column(Integer, ForeignKey(\"profile.id\"))\n    name = Column(String)\n\n\nclass Article(Base):\n    __tablename__ = \"article\"\n    id = Column(Integer, primary_key=True)\n    author_id = Column(Integer, ForeignKey(\"author.id\"))\n    title = Column(String)\n    content = Column(String)\n</code></pre> <p>Fetch a user and all their posts:</p> <pre><code>author_crud = FastCRUD(Author)\nauthor_articles = await author_crud.get_joined(\n    db=db,\n    join_model=Article,\n    join_on=Author.id == Article.author_id,\n    join_prefix=\"article_\",\n    join_type=\"left\",\n    nest_joins=True,\n    id=1,\n)\n</code></pre> <p>The result will be:</p> <pre><code>{\n    \"id\": 1,\n    \"name\": \"Example Author\",\n    \"articles\": [\n        {\n            \"id\": 101,\n            \"author_id\": 1,\n            \"title\": \"First Article!\",\n            \"content\": \"First article content\"\n        },\n        {\n            \"id\": 102,\n            \"author_id\": 1,\n            \"title\": \"Second Article?\",\n            \"content\": \"Second article content\"\n        }\n    ]\n}\n</code></pre>"},{"location":"advanced/joins/#sorting-nested-items-in-one-to-many-relationships","title":"Sorting Nested Items in One-to-Many Relationships","text":"<p>FastCRUD allows you to sort nested items in one-to-many relationships using the <code>sort_columns</code> and <code>sort_orders</code> parameters in the <code>JoinConfig</code>. This is particularly useful when you want to display nested items in a specific order.</p> <pre><code>from fastcrud import FastCRUD, JoinConfig\n\nauthor_crud = FastCRUD(Author)\n\n# Define join configuration with sorting\njoins_config = [\n    JoinConfig(\n        model=Article,\n        join_on=Author.id == Article.author_id,\n        join_prefix=\"articles_\",\n        relationship_type=\"one-to-many\",\n        sort_columns=\"title\",  # Sort articles by title\n        sort_orders=\"asc\"      # In ascending order\n    )\n]\n\n# Fetch authors with their articles sorted by title\nresult = await author_crud.get_multi_joined(\n    db=db,\n    joins_config=joins_config,\n    nest_joins=True\n)\n</code></pre> <p>You can also sort by multiple columns with different sort orders:</p> <pre><code>joins_config = [\n    JoinConfig(\n        model=Article,\n        join_on=Author.id == Article.author_id,\n        join_prefix=\"articles_\",\n        relationship_type=\"one-to-many\",\n        sort_columns=[\"published_date\", \"title\"],  # Sort by date first, then title\n        sort_orders=[\"desc\", \"asc\"]               # Date descending, title ascending\n    )\n]\n</code></pre> <p>This will result in nested articles being sorted first by published_date in descending order, and then by title in ascending order within each date group.</p>"},{"location":"advanced/joins/#many-to-many-relationships-with-get_multi_joined","title":"Many-to-Many Relationships with <code>get_multi_joined</code>","text":"<p>FastCRUD simplifies dealing with many-to-many relationships by allowing easy fetch operations with joined models. Here, we demonstrate using <code>get_multi_joined</code> to handle a many-to-many relationship between <code>Project</code> and <code>Participant</code> models, linked through an association table.</p> <p>Note on Handling Many-to-Many Relationships:</p> <p>When using <code>get_multi_joined</code> for many-to-many relationships, it's essential to maintain a specific order in your <code>joins_config</code>:</p> <ol> <li>First, specify the main table you're querying from.</li> <li>Next, include the association table that links your main table to the other table involved in the many-to-many relationship.</li> <li>Finally, specify the other table that is connected via the association table.</li> </ol> <p>This order ensures that the SQL joins are structured correctly to reflect the many-to-many relationship and retrieve the desired data accurately.</p> <p>Tip</p> <p>Note that the first one can be the model defined in <code>FastCRUD(Model)</code>.</p>"},{"location":"advanced/joins/#scenario","title":"Scenario","text":"<p>Imagine a scenario where projects have multiple participants, and participants can be involved in multiple projects. This many-to-many relationship is facilitated through an association table.</p>"},{"location":"advanced/joins/#models","title":"Models","text":"<p>Our models include <code>Project</code>, <code>Participant</code>, and an association model <code>ProjectsParticipantsAssociation</code>:</p> Models <pre><code>class Project(Base):\n    __tablename__ = \"projects\"\n    id = Column(Integer, primary_key=True)\n    name = Column(String(32), nullable=False)\n    description = Column(String(32))\n    participants = relationship(\n        \"Participant\",\n        secondary=\"projects_participants_association\",\n        back_populates=\"projects\",\n    )\n\n\nclass Participant(Base):\n    __tablename__ = \"participants\"\n    id = Column(Integer, primary_key=True)\n    name = Column(String(32), nullable=False)\n    role = Column(String(32))\n    projects = relationship(\n        \"Project\",\n        secondary=\"projects_participants_association\",\n        back_populates=\"participants\",\n    )\n\n\nclass ProjectsParticipantsAssociation(Base):\n    __tablename__ = \"projects_participants_association\"\n    project_id = Column(Integer, ForeignKey(\"projects.id\"), primary_key=True)\n    participant_id = Column(Integer, ForeignKey(\"participants.id\"), primary_key=True)\n</code></pre>"},{"location":"advanced/joins/#fetching-data-with-get_multi_joined","title":"Fetching Data with <code>get_multi_joined</code>","text":"<p>To fetch projects along with their participants, we utilize <code>get_multi_joined</code> with appropriate <code>JoinConfig</code> settings:</p> <pre><code>from fastcrud import FastCRUD, JoinConfig\n\n# Initialize FastCRUD for the Project model\nproject_crud = FastCRUD(Project)\n\n# Define join conditions and configuration\njoins_config = [\n    JoinConfig(\n        model=ProjectsParticipantsAssociation,\n        join_on=Project.id == ProjectsParticipantsAssociation.project_id,\n        join_prefix=\"pp_\",\n        join_type=\"inner\",\n    ),\n    JoinConfig(\n        model=Participant,\n        join_on=ProjectsParticipantsAssociation.participant_id == Participant.id,\n        join_prefix=\"participant_\",\n        join_type=\"inner\",\n    ),\n]\n\n# Fetch projects with their participants as dictionaries\nprojects_with_participants = await project_crud.get_multi_joined(\n    db_session,\n    joins_config=joins_config,\n)\n\n# Or fetch as typed Pydantic models\nfrom .schemas import ReadProjectSchema\n\nprojects_with_participants = await project_crud.get_multi_joined(\n    db_session,\n    schema_to_select=ReadProjectSchema,\n    return_as_model=True,\n    joins_config=joins_config,\n)\n</code></pre> <p>Return Types: - When <code>return_as_model=True</code> and <code>schema_to_select</code> is provided: <code>GetMultiResponseModel[SelectSchemaType]</code> (i.e., <code>Dict[str, Union[List[SelectSchemaType], int]]</code>) - When <code>return_as_model=False</code>: <code>GetMultiResponseDict</code> (i.e., <code>Dict[str, Union[List[Dict[str, Any]], int]]</code>)</p> <p>Now, <code>projects_with_participants['data']</code> will contain projects along with their participant information. The full results would look like:</p> <pre><code>{\n    \"data\": [\n        {\n            \"id\": 1,\n            \"name\": \"Project A\",\n            \"description\": \"Description of Project A\",\n            \"participants\": [\n                {\n                    \"id\": 1,\n                    \"name\": \"Participant 1\",\n                    \"role\": \"Developer\"\n                },\n                {\n                    \"id\": 2,\n                    \"name\": \"Participant 2\",\n                    \"role\": \"Designer\"\n                }\n            ]\n        },\n        {\n            \"id\": 2,\n            \"name\": \"Project B\",\n            \"description\": \"Description of Project B\",\n            \"participants\": [\n                {\n                    \"id\": 3,\n                    \"name\": \"Participant 3\",\n                    \"role\": \"Manager\"\n                },\n                {\n                    \"id\": 4,\n                    \"name\": \"Participant 4\",\n                    \"role\": \"Tester\"\n                }\n            ]\n        }\n    ],\n    \"total_count\": 2\n}\n</code></pre>"},{"location":"advanced/joins/#counting-related-objects-with-countconfig","title":"Counting Related Objects with <code>CountConfig</code>","text":"<p>FastCRUD provides <code>CountConfig</code> for efficiently counting related objects without fetching the actual data. This is particularly useful for many-to-many relationships or when you need to display counts alongside your main data.</p>"},{"location":"advanced/joins/#basic-usage","title":"Basic Usage","text":"<p>Use <code>CountConfig</code> with the <code>counts_config</code> parameter in <code>get_multi_joined</code>:</p> <pre><code>from fastcrud import FastCRUD, CountConfig\n\n# Count participants for each project\nproject_crud = FastCRUD(Project)\n\ncount_config = CountConfig(\n    model=Participant,\n    join_on=(Participant.id == ProjectsParticipantsAssociation.participant_id)\n           &amp; (ProjectsParticipantsAssociation.project_id == Project.id),\n    alias=\"participants_count\",\n)\n\nresult = await project_crud.get_multi_joined(\n    db=session,\n    counts_config=[count_config],\n)\n</code></pre> <p>This will return data like:</p> <pre><code>{\n    \"data\": [\n        {\"id\": 1, \"name\": \"Project Alpha\", \"participants_count\": 3},\n        {\"id\": 2, \"name\": \"Project Beta\", \"participants_count\": 2},\n        {\"id\": 3, \"name\": \"Project Gamma\", \"participants_count\": 0}\n    ],\n    \"total_count\": 3\n}\n</code></pre>"},{"location":"advanced/joins/#counting-with-filters","title":"Counting with Filters","text":"<p>Apply filters to count only specific related objects:</p> <pre><code># Count only developers for each project\ncount_config = CountConfig(\n    model=Participant,\n    join_on=(Participant.id == ProjectsParticipantsAssociation.participant_id)\n           &amp; (ProjectsParticipantsAssociation.project_id == Project.id),\n    alias=\"developers_count\",\n    filters={\"role\": \"Developer\"},\n)\n\nresult = await project_crud.get_multi_joined(\n    db=session,\n    counts_config=[count_config],\n)\n</code></pre>"},{"location":"advanced/joins/#multiple-count-configurations","title":"Multiple Count Configurations","text":"<p>You can use multiple <code>CountConfig</code> instances to get different counts:</p> <pre><code># Count all participants and developers separately\nall_participants_count = CountConfig(\n    model=Participant,\n    join_on=(Participant.id == ProjectsParticipantsAssociation.participant_id)\n           &amp; (ProjectsParticipantsAssociation.project_id == Project.id),\n    alias=\"all_participants_count\",\n)\n\ndevelopers_count = CountConfig(\n    model=Participant,\n    join_on=(Participant.id == ProjectsParticipantsAssociation.participant_id)\n           &amp; (ProjectsParticipantsAssociation.project_id == Project.id),\n    alias=\"developers_count\",\n    filters={\"role\": \"Developer\"},\n)\n\nresult = await project_crud.get_multi_joined(\n    db=session,\n    counts_config=[all_participants_count, developers_count],\n)\n</code></pre>"},{"location":"advanced/joins/#one-to-many-relationships_1","title":"One-to-Many Relationships","text":"<p><code>CountConfig</code> works with one-to-many relationships as well:</p> <pre><code># Count articles for each author\nauthor_crud = FastCRUD(Author)\n\ncount_config = CountConfig(\n    model=Article,\n    join_on=Article.author_id == Author.id,\n    alias=\"articles_count\",\n)\n\nresult = await author_crud.get_multi_joined(\n    db=session,\n    counts_config=[count_config],\n)\n</code></pre>"},{"location":"advanced/joins/#combining-with-regular-joins","title":"Combining with Regular Joins","text":"<p>You can use <code>CountConfig</code> alongside <code>JoinConfig</code> for comprehensive data retrieval:</p> <pre><code># Get project details with participant information AND counts\njoins_config = [\n    JoinConfig(\n        model=ProjectsParticipantsAssociation,\n        join_on=Project.id == ProjectsParticipantsAssociation.project_id,\n        join_prefix=\"pp_\",\n        join_type=\"inner\",\n    ),\n    JoinConfig(\n        model=Participant,\n        join_on=ProjectsParticipantsAssociation.participant_id == Participant.id,\n        join_prefix=\"participant_\",\n        join_type=\"inner\",\n    ),\n]\n\ncounts_config = [\n    CountConfig(\n        model=Participant,\n        join_on=(Participant.id == ProjectsParticipantsAssociation.participant_id)\n               &amp; (ProjectsParticipantsAssociation.project_id == Project.id),\n        alias=\"total_participants\",\n    )\n]\n\nresult = await project_crud.get_multi_joined(\n    db=session,\n    joins_config=joins_config,\n    counts_config=counts_config,\n    nest_joins=True,\n)\n</code></pre>"},{"location":"advanced/joins/#practical-tips-for-advanced-joins","title":"Practical Tips for Advanced Joins","text":"<ul> <li>Prefixing: Always use the <code>join_prefix</code> attribute to avoid column name collisions, especially in complex joins involving multiple models or self-referential joins.</li> <li>Aliasing: Utilize the <code>alias</code> attribute for disambiguating joins on the same model or for self-referential joins.</li> <li>Filtering Joined Models: Apply filters directly to joined models using the <code>filters</code> attribute in <code>JoinConfig</code> to refine the data set returned by the query.</li> <li>Ordering Joins: In many-to-many relationships or complex join scenarios, carefully sequence your <code>JoinConfig</code> entries to ensure logical and efficient SQL join construction.</li> </ul>"},{"location":"advanced/joins/#conclusion","title":"Conclusion","text":"<p>FastCRUD's support for join operations enhances the ability to perform complex queries across related models in FastAPI applications. By understanding and utilizing the <code>JoinConfig</code> and <code>CountConfig</code> classes within the <code>count</code>, <code>get_joined</code>, and <code>get_multi_joined</code> methods, developers can craft powerful data retrieval queries that efficiently handle both data fetching and counting operations.</p>"},{"location":"advanced/overview/","title":"Advanced Usage Overview","text":"<p>The Advanced section of our documentation delves into the sophisticated capabilities and features of our application, tailored for users looking to leverage advanced functionalities. This part of our guide aims to unlock deeper insights and efficiencies through more complex use cases and configurations.</p>"},{"location":"advanced/overview/#key-topics","title":"Key Topics","text":""},{"location":"advanced/overview/#1-advanced-filtering-and-searching","title":"1. Advanced Filtering and Searching","text":"<p>Explore how to implement advanced filtering and searching capabilities in your application. This guide covers the use of comparison operators (such as greater than, less than, etc.), pattern matching, logical operations like OR and NOT, and more to perform complex queries.</p> <ul> <li>Advanced Filtering Guide</li> <li>Legacy Filtering Options</li> </ul>"},{"location":"advanced/overview/#2-bulk-operations-and-batch-processing","title":"2. Bulk Operations and Batch Processing","text":"<p>Learn how to efficiently handle bulk operations and batch processing. This section provides insights into performing mass updates, deletes, and inserts, optimizing performance for large datasets.</p> <ul> <li>Bulk Operations Guide</li> </ul>"},{"location":"advanced/overview/#3-soft-delete-mechanisms-and-strategies","title":"3. Soft Delete Mechanisms and Strategies","text":"<p>Understand the implementation of soft delete mechanisms within our application. This guide covers configuring and using custom columns for soft deletes, restoring deleted records, and filtering queries to exclude soft-deleted entries.</p> <ul> <li>Soft Delete Strategies Guide</li> </ul>"},{"location":"advanced/overview/#4-advanced-use-of-endpointcreator-and-crud_router","title":"4. Advanced Use of EndpointCreator and crud_router","text":"<p>This topic extends the use of <code>EndpointCreator</code> and <code>crud_router</code> for advanced endpoint management, including creating custom routes, selective method exposure, and integrating soft delete functionalities.</p> <ul> <li>Advanced Endpoint Management Guide</li> </ul>"},{"location":"advanced/overview/#5-using-get_joined-and-get_multi_joined-for-multiple-models","title":"5. Using <code>get_joined</code> and <code>get_multi_joined</code> for multiple models","text":"<p>Explore the use of <code>get_joined</code> and <code>get_multi_joined</code> functions for complex queries that involve joining multiple models, including self-joins and scenarios requiring multiple joins on the same model.</p> <ul> <li>Joining Multiple Models Guide</li> </ul>"},{"location":"advanced/overview/#6-method-chaining-with-select","title":"6. Method Chaining with <code>select</code>","text":"<p>FastCRUD's <code>select</code> method introduces method chaining, allowing for the construction of detailed queries with a focus on precision. It simplifies the process of dynamically applying filters, sorting, and conditions, making it easier to manage complex query requirements.</p> <ul> <li>Method Chaining Guide</li> </ul>"},{"location":"advanced/overview/#7-in-depth-explanation-of-joined-methods","title":"7. In depth explanation of Joined methods","text":"<p>Explore different ways of joining models in FastCRUD with examples and tips.</p> <ul> <li>Joining Models</li> </ul>"},{"location":"advanced/overview/#8-filters-in-automatic-endpoints","title":"8. Filters in Automatic Endpoints","text":"<p>Learn how to add query parameters to your <code>get_multi</code> and <code>get_paginated</code> endpoints.</p> <ul> <li>Filters in Endpoints</li> </ul>"},{"location":"advanced/overview/#9-response-key-configuration","title":"9. Response Key Configuration","text":"<p>Customize the key used for list responses in FastCRUD through the <code>multi_response_key</code> parameter. This guide covers default behavior and how to configure custom response keys for better API consistency.</p> <ul> <li>Response Key Configuration Guide</li> </ul>"},{"location":"advanced/overview/#prerequisites","title":"Prerequisites","text":"<p>Advanced usage assumes a solid understanding of the basic features and functionalities of our application. Knowledge of FastAPI, SQLAlchemy, and Pydantic is highly recommended to fully grasp the concepts discussed.</p>"},{"location":"advanced/response_keys/","title":"Response Key Configuration","text":"<p>FastCRUD allows you to customize the key used for list responses through the <code>multi_response_key</code> parameter. This guide demonstrates both default and custom configurations.</p>"},{"location":"advanced/response_keys/#default-configuration","title":"Default Configuration","text":"<p>By default, FastCRUD uses <code>\"data\"</code> as the response key:</p> <pre><code>from fastcrud import FastCRUD\nfrom .models import MyModel\nfrom .database import session as db\n\n# Default initialization\ncrud = FastCRUD(MyModel)\n\n# Get multiple items\nresult = await crud.get_multi(db, limit=2)\n</code></pre> <p>Response structure: <pre><code>{\n    \"data\": [\n        {\"id\": 1, \"name\": \"Item 1\"},\n        {\"id\": 2, \"name\": \"Item 2\"}\n    ],\n    \"total_count\": 10,\n    \"has_more\": true,\n    \"page\": 1,\n    \"items_per_page\": 2\n}\n</code></pre></p>"},{"location":"advanced/response_keys/#custom-response-key","title":"Custom Response Key","text":"<p>You can customize the response key using <code>multi_response_key</code>:</p> <pre><code>from fastcrud import FastCRUD\nfrom .models import MyModel\nfrom .database import session as db\n\n# Custom response key initialization\ncrud = FastCRUD(MyModel, multi_response_key=\"items\")\n\n# Get multiple items\nresult = await crud.get_multi(db, limit=2)\n</code></pre> <p>Response structure: <pre><code>{\n    \"items\": [\n        {\"id\": 1, \"name\": \"Item 1\"},\n        {\"id\": 2, \"name\": \"Item 2\"}\n    ],\n    \"total_count\": 10,\n    \"has_more\": true,\n    \"page\": 1,\n    \"items_per_page\": 2\n}\n</code></pre></p>"},{"location":"advanced/response_keys/#using-with-endpointcreator","title":"Using with EndpointCreator","text":"<p>When using <code>EndpointCreator</code>, the response key configuration is automatically inherited:</p> <pre><code>from fastcrud import FastCRUD, EndpointCreator\nfrom .models import MyModel\nfrom .schemas import CreateSchema, UpdateSchema\n\n# Custom response key\ncrud = FastCRUD(MyModel, multi_response_key=\"items\")\n\nendpoint_creator = EndpointCreator(\n    session=async_session,\n    model=MyModel,\n    create_schema=CreateSchema,\n    update_schema=UpdateSchema,\n    crud=crud  # The response key setting is inherited\n)\n</code></pre> <p>The API endpoints created will use the configured response key in their responses.</p>"},{"location":"advanced/response_keys/#response-models","title":"Response Models","text":"<p>When using Pydantic response models with custom response keys, make sure to define them accordingly:</p> <pre><code>from pydantic import BaseModel\n\n# For default \"data\" key\nclass DefaultResponse(BaseModel):\n    data: list[YourSchema]\n    total_count: int\n    has_more: bool\n    page: int | None = None\n    items_per_page: int | None = None\n\n# For custom \"items\" key\nclass CustomResponse(BaseModel):\n    items: list[YourSchema]\n    total_count: int\n    has_more: bool\n    page: int | None = None\n    items_per_page: int | None = None\n</code></pre> <p>Note</p> <p>FastCRUD automatically handles the response model creation when using <code>EndpointCreator</code> or <code>crud_router</code>,  so manual response model definition is only needed for custom implementations.</p>"},{"location":"api/crud_router/","title":"CRUD Router API Reference","text":"<p><code>crud_router</code> is a utility function for creating and configuring a FastAPI router with CRUD endpoints for a given model.</p>"},{"location":"api/crud_router/#function-definition","title":"Function Definition","text":"<p>Creates and configures a FastAPI router with CRUD endpoints for a given model.</p> <p>This utility function streamlines the process of setting up a router for CRUD operations, using a custom <code>EndpointCreator</code> if provided, and managing dependency injections as well as selective method inclusions or exclusions.</p> <p>Parameters:</p> Name Type Description Default <code>session</code> <code>Callable</code> <p>The SQLAlchemy async session.</p> required <code>model</code> <code>ModelType</code> <p>The SQLAlchemy model.</p> required <code>create_schema</code> <code>Type[CreateSchemaType]</code> <p>Pydantic schema for creating an item.</p> required <code>update_schema</code> <code>Type[UpdateSchemaType]</code> <p>Pydantic schema for updating an item.</p> required <code>crud</code> <code>Optional[FastCRUD]</code> <p>An optional <code>FastCRUD</code> instance. If not provided, uses <code>FastCRUD(model)</code>.</p> <code>None</code> <code>delete_schema</code> <code>Optional[Type[DeleteSchemaType]]</code> <p>Optional Pydantic schema for deleting an item.</p> <code>None</code> <code>path</code> <code>str</code> <p>Base path for the CRUD endpoints.</p> <code>''</code> <code>tags</code> <code>Optional[list[Union[str, Enum]]]</code> <p>Optional list of tags for grouping endpoints in the documentation.</p> <code>None</code> <code>include_in_schema</code> <code>bool</code> <p>Whether to include the created endpoints in the OpenAPI schema.</p> <code>True</code> <code>create_deps</code> <code>Sequence[Callable]</code> <p>Optional list of functions to be injected as dependencies for the create endpoint.</p> <code>[]</code> <code>read_deps</code> <code>Sequence[Callable]</code> <p>Optional list of functions to be injected as dependencies for the read endpoint.</p> <code>[]</code> <code>read_multi_deps</code> <code>Sequence[Callable]</code> <p>Optional list of functions to be injected as dependencies for the read multiple items endpoint.</p> <code>[]</code> <code>update_deps</code> <code>Sequence[Callable]</code> <p>Optional list of functions to be injected as dependencies for the update endpoint.</p> <code>[]</code> <code>delete_deps</code> <code>Sequence[Callable]</code> <p>Optional list of functions to be injected as dependencies for the delete endpoint.</p> <code>[]</code> <code>db_delete_deps</code> <code>Sequence[Callable]</code> <p>Optional list of functions to be injected as dependencies for the hard delete endpoint.</p> <code>[]</code> <code>included_methods</code> <code>Optional[list[str]]</code> <p>Optional list of CRUD methods to include. If <code>None</code>, all methods are included.</p> <code>None</code> <code>deleted_methods</code> <code>Optional[list[str]]</code> <p>Optional list of CRUD methods to exclude.</p> <code>None</code> <code>endpoint_creator</code> <code>Optional[Type[EndpointCreator]]</code> <p>Optional custom class derived from <code>EndpointCreator</code> for advanced customization.</p> <code>None</code> <code>is_deleted_column</code> <code>str</code> <p>Optional column name to use for indicating a soft delete. Defaults to <code>\"is_deleted\"</code>.</p> <code>'is_deleted'</code> <code>deleted_at_column</code> <code>str</code> <p>Optional column name to use for storing the timestamp of a soft delete. Defaults to <code>\"deleted_at\"</code>.</p> <code>'deleted_at'</code> <code>updated_at_column</code> <code>str</code> <p>Optional column name to use for storing the timestamp of an update. Defaults to <code>\"updated_at\"</code>.</p> <code>'updated_at'</code> <code>endpoint_names</code> <code>Optional[dict[str, str]]</code> <p>Optional dictionary to customize endpoint names for CRUD operations. Keys are operation types             (<code>\"create\"</code>, <code>\"read\"</code>, <code>\"update\"</code>, <code>\"delete\"</code>, <code>\"db_delete\"</code>, <code>\"read_multi\"</code>), and             values are the custom names to use. Unspecified operations will use default names.</p> <code>None</code> <code>filter_config</code> <code>Optional[Union[FilterConfig, dict]]</code> <p>Optional <code>FilterConfig</code> instance or dictionary to configure filters for the <code>read_multi</code> endpoint.</p> <code>None</code> <code>select_schema</code> <code>Optional[Type[SelectSchemaType]]</code> <p>Optional Pydantic schema for selecting an item.</p> <code>None</code> <p>Returns:</p> Type Description <code>APIRouter</code> <p>Configured <code>APIRouter</code> instance with the CRUD endpoints.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If both <code>included_methods</code> and <code>deleted_methods</code> are provided.</p> <p>Examples:</p> Models and Schemas Used Below <code>mymodel/model.py</code> <pre><code>from sqlalchemy import Boolean, Column, DateTime, Integer, String\nfrom sqlalchemy.orm import DeclarativeBase\n\n\nclass Base(DeclarativeBase):\n    pass\n\n\nclass MyModel(Base):\n    __tablename__ = \"my_model\"\n    id = Column(Integer, primary_key=True)\n    name = Column(String)\n</code></pre> <code>mymodel/schemas.py</code> <pre><code>import datetime\n\nfrom pydantic import BaseModel\n\n\nclass CreateMyModelSchema(BaseModel):\n    name: str | None = None\n\n\nclass UpdateMyModelSchema(BaseModel):\n    name: str | None = None\n\n\nclass DeleteMyModelSchema(BaseModel):\n    pass\n</code></pre> <code>customer/model.py</code> <pre><code>from sqlalchemy import Column, Integer, String\nfrom sqlalchemy.orm import DeclarativeBase\n\n\nclass Base(DeclarativeBase):\n    pass\n\n\nclass Customer(Base):\n    __tablename__ = \"customer\"\n    id = Column(Integer, primary_key=True)\n    name = Column(String)\n</code></pre> <code>customer/schemas.py</code> <pre><code>from pydantic import BaseModel\n\n\nclass CreateCustomerSchema(BaseModel):\n    name: str | None = None\n\n\nclass ReadCustomerSchema(BaseModel):\n    id: int\n    name: str | None = None\n\n\nclass UpdateCustomerSchema(BaseModel):\n    name: str | None = None\n\n\nclass DeleteCustomerSchema(BaseModel):\n    pass\n</code></pre> <code>product/model.py</code> <pre><code>from sqlalchemy import Column, Integer, Numeric, String\nfrom sqlalchemy.orm import DeclarativeBase\n\n\nclass Base(DeclarativeBase):\n    pass\n\n\nclass Product(Base):\n    __tablename__ = \"product\"\n    id = Column(Integer, primary_key=True)\n    name = Column(String)\n    price = Column(Numeric)\n</code></pre> <code>product/schemas.py</code> <pre><code>from pydantic import BaseModel\n\n\nclass CreateProductSchema(BaseModel):\n    name: str | None = None\n    price: float | None = None\n\n\nclass ReadProductSchema(BaseModel):\n    id: int\n    name: str | None = None\n    price: float | None = None\n\n\nclass UpdateProductSchema(BaseModel):\n    name: str | None = None\n    price: float | None = None\n\n\nclass DeleteProductSchema(BaseModel):\n    pass\n</code></pre> <code>order/model.py</code> <pre><code>from sqlalchemy import Column, ForeignKey, Integer\nfrom sqlalchemy.orm import DeclarativeBase\n\n\nclass Base(DeclarativeBase):\n    pass\n\n\nclass Order(Base):\n    __tablename__ = \"order\"\n    id = Column(Integer, primary_key=True)\n    customer_id = Column(Integer, ForeignKey(\"customer.id\"))\n    product_id = Column(Integer, ForeignKey(\"product.id\"))\n    quantity = Column(Integer)\n</code></pre> <code>order/schemas.py</code> <pre><code>from pydantic import BaseModel\n\n\nclass CreateOrderSchema(BaseModel):\n    customer_id: int | None = None\n    product_id: int | None = None\n    quantity: int | None = None\n\n\nclass ReadOrderSchema(BaseModel):\n    id: int\n    customer_id: int | None = None\n    product_id: int | None = None\n    quantity: int | None = None\n\n\nclass UpdateOrderSchema(BaseModel):\n    customer_id: int | None = None\n    product_id: int | None = None\n    quantity: int | None = None\n\n\nclass DeleteOrderSchema(BaseModel):\n    pass\n</code></pre> <code>tier/model.py</code> <pre><code>from sqlalchemy import Column, Integer, String\nfrom sqlalchemy.orm import DeclarativeBase\n\n\nclass Base(DeclarativeBase):\n    pass\n\n\nclass Tier(Base):\n    __tablename__ = \"tier\"\n    id = Column(Integer, primary_key=True)\n    name = Column(String, unique=True)\n</code></pre> <code>tier/schemas.py</code> <pre><code>from pydantic import BaseModel\n\n\nclass ReadTierSchema(BaseModel):\n    id: int\n    name: str | None = None\n</code></pre> <code>department/model.py</code> <pre><code>from sqlalchemy import Column, Integer, String\nfrom sqlalchemy.orm import DeclarativeBase\n\n\nclass Base(DeclarativeBase):\n    pass\n\n\nclass Department(Base):\n    __tablename__ = \"department\"\n    id = Column(Integer, primary_key=True)\n    name = Column(String)\n</code></pre> <code>department/schemas.py</code> <pre><code>from pydantic import BaseModel\n\n\nclass ReadDepartmentSchema(BaseModel):\n    id: int\n    name: str | None = None\n</code></pre> <code>user/model.py</code> <pre><code>from sqlalchemy import (\n    Boolean,\n    Column,\n    DateTime,\n    ForeignKey,\n    Integer,\n    String,\n    func,\n)\nfrom sqlalchemy.orm import DeclarativeBase\n\n\nclass Base(DeclarativeBase):\n    pass\n\n\nclass User(Base):\n    __tablename__ = \"user\"\n    id = Column(Integer, primary_key=True)\n    name = Column(String)\n    username = Column(String)\n    email = Column(String)\n    age = Column(Integer)\n    role = Column(String)\n    tier_id = Column(Integer, ForeignKey(\"tier.id\"))\n    department_id = Column(Integer, ForeignKey(\"department.id\"))\n    manager_id = Column(Integer, ForeignKey(\"user.id\"))\n    is_active = Column(Boolean, default=True)\n    is_superuser = Column(Boolean, default=False)\n    registration_date = Column(DateTime, default=func.now())\n    archived = Column(Boolean, default=False)\n    archived_at = Column(DateTime)\n</code></pre> <code>user/schemas.py</code> <pre><code>import datetime\n\nfrom pydantic import BaseModel\n\n\nclass CreateUserSchema(BaseModel):\n    name: str | None = None\n    username: str | None = None\n    email: str | None = None\n    age: int | None = None\n    role: str | None = None\n    tier_id: int | None = None\n    department_id: int | None = None\n    manager_id: int | None = None\n    is_active: bool | None = None\n    is_superuser: bool | None = None\n\n\nclass ReadUserSchema(BaseModel):\n    id: int\n    name: str | None = None\n    username: str | None = None\n    email: str | None = None\n    age: int | None = None\n    role: str | None = None\n    tier_id: int | None = None\n    department_id: int | None = None\n    manager_id: int | None = None\n    is_active: bool\n    is_superuser: bool\n    registration_date: datetime.datetime\n    archived: bool\n    archived_at: datetime.datetime | None = None\n\n\nclass UpdateUserSchema(BaseModel):\n    name: str | None = None\n    username: str | None = None\n    email: str | None = None\n    age: int | None = None\n    role: str | None = None\n    tier_id: int | None = None\n    department_id: int | None = None\n    manager_id: int | None = None\n    is_active: bool | None = None\n    is_superuser: bool | None = None\n\n\nclass DeleteUserSchema(BaseModel):\n    pass\n</code></pre> <code>story/model.py</code> <pre><code>from sqlalchemy import Column, Integer, String\nfrom sqlalchemy.orm import DeclarativeBase\n\n\nclass Base(DeclarativeBase):\n    pass\n\n\nclass Story(Base):\n    __tablename__ = \"story\"\n    id = Column(Integer, primary_key=True)\n    name = Column(String)\n</code></pre> <code>story/schemas.py</code> <pre><code>from pydantic import BaseModel\n\n\nclass CreateStorySchema(BaseModel):\n    name: str | None = None\n\n\nclass ReadStorySchema(BaseModel):\n    id: int\n    name: str | None = None\n\n\nclass UpdateStorySchema(BaseModel):\n    name: str | None = None\n\n\nclass DeleteStorySchema(BaseModel):\n    pass\n</code></pre> <code>task/model.py</code> <pre><code>from sqlalchemy import Column, ForeignKey, Integer, String\nfrom sqlalchemy.orm import DeclarativeBase\n\n\nclass Base(DeclarativeBase):\n    pass\n\n\nclass Task(Base):\n    __tablename__ = \"task\"\n    id = Column(Integer, primary_key=True)\n    creator_id = Column(Integer, ForeignKey(\"user.id\"))\n    owner_id = Column(Integer, ForeignKey(\"user.id\"))\n    assigned_user_id = Column(Integer, ForeignKey(\"user.id\"))\n    story_id = Column(Integer, ForeignKey(\"story.id\"))\n    status = Column(String)\n    priority = Column(String)\n</code></pre> <code>task/schemas.py</code> <pre><code>from pydantic import BaseModel\n\n\nclass CreateTaskSchema(BaseModel):\n    creator_id: int | None = None\n    owner_id: int | None = None\n    assigned_user_id: int | None = None\n    story_id: int | None = None\n    status: str | None = None\n    priority: str | None = None\n\n\nclass ReadTaskSchema(BaseModel):\n    id: int\n    creator_id: int | None = None\n    owner_id: int | None = None\n    assigned_user_id: int | None = None\n    story_id: int | None = None\n    status: str | None = None\n    priority: str | None = None\n\n\nclass UpdateTaskSchema(BaseModel):\n    creator_id: int | None = None\n    owner_id: int | None = None\n    assigned_user_id: int | None = None\n    story_id: int | None = None\n    status: str | None = None\n    priority: str | None = None\n\n\nclass DeleteTaskSchema(BaseModel):\n    pass\n</code></pre> <p>Basic Setup:</p> <pre><code>mymodel_router = crud_router(\n    session=async_session,\n    model=MyModel,\n    create_schema=CreateMyModelSchema,\n    update_schema=UpdateMyModelSchema,\n    path=\"/mymodel\",\n    tags=[\"MyModel\"],\n)\n</code></pre> <p>With Custom Dependencies:</p> <pre><code>def get_current_user(token: str = Depends(oauth2_scheme)):\n    # Implement user retrieval logic\n    return ...\n\nuser_router = crud_router(\n    session=async_session,\n    model=User,\n    create_schema=CreateUserSchema,\n    update_schema=UpdateUserSchema,\n    read_deps=[get_current_user],\n    update_deps=[get_current_user],\n    path=\"/users\",\n    tags=[\"Users\"],\n)\n</code></pre> <p>Adding Delete Endpoints: <pre><code>product_router = crud_router(\n    session=async_session,\n    model=Product,\n    create_schema=CreateProductSchema,\n    update_schema=UpdateProductSchema,\n    delete_schema=DeleteProductSchema,\n    path=\"/products\",\n    tags=[\"Products\"],\n)\n</code></pre></p> <p>Customizing Path and Tags: <pre><code>OrderCRUD = FastCRUD[\n    Order,\n    CreateOrderSchema,\n    UpdateOrderSchema,\n    UpdateOrderSchema,\n    DeleteOrderSchema,\n]\norder_router = crud_router(\n    session=async_session,\n    model=Order,\n    create_schema=CreateOrderSchema,\n    update_schema=UpdateOrderSchema,\n    crud=OrderCRUD(Order),\n    path=\"/orders\",\n    tags=[\"Orders\", \"Sales\"],\n)\n</code></pre></p> <p>Integrating Multiple Models: <pre><code>ProductCRUD = FastCRUD[\n    Product,\n    CreateProductSchema,\n    UpdateProductSchema,\n    UpdateProductSchema,\n    DeleteProductSchema,\n]\nproduct_router = crud_router(\n    session=async_session,\n    model=Product,\n    create_schema=CreateProductSchema,\n    update_schema=UpdateProductSchema,\n    crud=ProductCRUD(Product),\n    path=\"/products\",\n    tags=[\"Inventory\"],\n)\n\nCustomerCRUD = FastCRUD[\n    Customer,\n    CreateCustomerSchema,\n    UpdateCustomerSchema,\n    UpdateCustomerSchema,\n    DeleteCustomerSchema,\n]\ncustomer_router = crud_router(\n    session=async_session,\n    model=Customer,\n    create_schema=CreateCustomerSchema,\n    update_schema=UpdateCustomerSchema,\n    crud=CustomerCRUD(Customer),\n    path=\"/customers\",\n    tags=[\"CRM\"],\n)\n</code></pre></p> <p>With Selective CRUD Methods:</p> <pre><code>MyModelCRUD = FastCRUD[\n    MyModel,\n    CreateMyModelSchema,\n    UpdateMyModelSchema,\n    UpdateMyModelSchema,\n    DeleteMyModelSchema,\n]\n# Only include 'create' and 'read' methods\nmymodel_router = crud_router(\n    session=async_session,\n    model=MyModel,\n    create_schema=CreateMyModelSchema,\n    update_schema=UpdateMyModelSchema,\n    crud=MyModelCRUD(MyModel),\n    path=\"/mymodel\",\n    tags=[\"MyModel\"],\n    included_methods=[\"create\", \"read\"],\n)\n</code></pre> <p>Using a Custom <code>EndpointCreator</code>:</p> <pre><code>class CustomEndpointCreator(EndpointCreator):\n    def _custom_route(self):\n        async def custom_endpoint():\n            # Custom endpoint logic\n            return {\"message\": \"Custom route\"}\n\n        return custom_endpoint\n\n        async def add_routes_to_router(self, ...):\n            # First, add standard CRUD routes\n            super().add_routes_to_router(...)\n\n            # Now, add custom routes\n            self.router.add_api_route(\n                path=\"/custom\",\n                endpoint=self._custom_route(),\n                methods=[\"GET\"],\n                tags=self.tags,\n                # Other parameters as needed\n            )\n\nMyModelCRUD = FastCRUD[\n    MyModel,\n    CreateMyModelSchema,\n    UpdateMyModelSchema,\n    UpdateMyModelSchema,\n    DeleteMyModelSchema,\n]\nmymodel_router = crud_router(\n    session=async_session,\n    model=MyModel,\n    create_schema=CreateMyModelSchema,\n    update_schema=UpdateMyModelSchema,\n    crud=MyModelCRUD(MyModel),\n    path=\"/mymodel\",\n    tags=[\"MyModel\"],\n    endpoint_creator=CustomEndpointCreator,\n)\n\napp.include_router(mymodel_router)\n</code></pre> <p>Customizing Endpoint Names:</p> <pre><code>task_router = crud_router(\n    session=async_session,\n    model=Task,\n    create_schema=CreateTaskSchema,\n    update_schema=UpdateTaskSchema,\n    path=\"/tasks\",\n    tags=[\"Task Management\"],\n    endpoint_names={\n        \"create\": \"add_task\",\n        \"read\": \"get_task\",\n        \"update\": \"modify_task\",\n        \"delete\": \"remove_task\",\n        \"db_delete\": \"permanently_remove_task\",\n        \"read_multi\": \"list_tasks\",\n    },\n)\n</code></pre> <p>Using <code>FilterConfig</code> with <code>dict</code>:</p> <pre><code>from fastapi import FastAPI\nfrom fastcrud import crud_router\n\nfrom .database import async_session\nfrom .mymodel.model import MyModel\nfrom .mymodel.schemas import CreateMyModelSchema, UpdateMyModelSchema\n\napp = FastAPI()\n\nmymodel_router = crud_router(\n    session=async_session,\n    model=MyModel,\n    create_schema=CreateMyModelSchema,\n    update_schema=UpdateMyModelSchema,\n    filter_config=FilterConfig(filters={\"id\": None, \"name\": \"default\"}),\n)\n# Adds CRUD routes with filtering capabilities\napp.include_router(mymodel_router, prefix=\"/mymodel\")\n\n# Explanation:\n# The FilterConfig specifies that 'id' should be a query parameter with no default value\n# and 'name' should be a query parameter with a default value of 'default'.\n# When fetching multiple items, you can filter by these parameters.\n# Example GET request: /mymodel/get_multi?id=1&amp;name=example\n</code></pre> <p>Using <code>FilterConfig</code> with keyword arguments:</p> <pre><code>from fastapi import FastAPI\nfrom fastcrud import crud_router\n\nfrom .database import async_session\nfrom .mymodel.model import MyModel\nfrom .mymodel.schemas import CreateMyModelSchema, UpdateMyModelSchema\n\napp = FastAPI()\n\nmymodel_router = crud_router(\n    session=async_session,\n    model=MyModel,\n    create_schema=CreateMyModelSchema,\n    update_schema=UpdateMyModelSchema,\n    filter_config=FilterConfig(id=None, name=\"default\"),\n)\n# Adds CRUD routes with filtering capabilities\napp.include_router(mymodel_router, prefix=\"/mymodel\")\n\n# Explanation:\n# The FilterConfig specifies that 'id' should be a query parameter with no default value\n# and 'name' should be a query parameter with a default value of 'default'.\n# When fetching multiple items, you can filter by these parameters.\n# Example GET request: /mymodel/get_multi?id=1&amp;name=example\n</code></pre> Source code in <code>fastcrud/endpoint/crud_router.py</code> <pre><code>def crud_router(\n    session: Callable,\n    model: ModelType,\n    create_schema: Type[CreateSchemaType],\n    update_schema: Type[UpdateSchemaType],\n    crud: Optional[FastCRUD] = None,\n    delete_schema: Optional[Type[DeleteSchemaType]] = None,\n    path: str = \"\",\n    tags: Optional[list[Union[str, Enum]]] = None,\n    include_in_schema: bool = True,\n    create_deps: Sequence[Callable] = [],\n    read_deps: Sequence[Callable] = [],\n    read_multi_deps: Sequence[Callable] = [],\n    update_deps: Sequence[Callable] = [],\n    delete_deps: Sequence[Callable] = [],\n    db_delete_deps: Sequence[Callable] = [],\n    included_methods: Optional[list[str]] = None,\n    deleted_methods: Optional[list[str]] = None,\n    endpoint_creator: Optional[Type[EndpointCreator]] = None,\n    is_deleted_column: str = \"is_deleted\",\n    deleted_at_column: str = \"deleted_at\",\n    updated_at_column: str = \"updated_at\",\n    endpoint_names: Optional[dict[str, str]] = None,\n    filter_config: Optional[Union[FilterConfig, dict]] = None,\n    select_schema: Optional[Type[SelectSchemaType]] = None,\n    create_config: Optional[CreateConfig] = None,\n    update_config: Optional[UpdateConfig] = None,\n    delete_config: Optional[DeleteConfig] = None,\n) -&gt; APIRouter:\n    \"\"\"\n    Creates and configures a FastAPI router with CRUD endpoints for a given model.\n\n    This utility function streamlines the process of setting up a router for CRUD operations,\n    using a custom `EndpointCreator` if provided, and managing dependency injections as well\n    as selective method inclusions or exclusions.\n\n    Args:\n        session: The SQLAlchemy async session.\n        model: The SQLAlchemy model.\n        create_schema: Pydantic schema for creating an item.\n        update_schema: Pydantic schema for updating an item.\n        crud: An optional `FastCRUD` instance. If not provided, uses `FastCRUD(model)`.\n        delete_schema: Optional Pydantic schema for deleting an item.\n        path: Base path for the CRUD endpoints.\n        tags: Optional list of tags for grouping endpoints in the documentation.\n        include_in_schema: Whether to include the created endpoints in the OpenAPI schema.\n        create_deps: Optional list of functions to be injected as dependencies for the create endpoint.\n        read_deps: Optional list of functions to be injected as dependencies for the read endpoint.\n        read_multi_deps: Optional list of functions to be injected as dependencies for the read multiple items endpoint.\n        update_deps: Optional list of functions to be injected as dependencies for the update endpoint.\n        delete_deps: Optional list of functions to be injected as dependencies for the delete endpoint.\n        db_delete_deps: Optional list of functions to be injected as dependencies for the hard delete endpoint.\n        included_methods: Optional list of CRUD methods to include. If `None`, all methods are included.\n        deleted_methods: Optional list of CRUD methods to exclude.\n        endpoint_creator: Optional custom class derived from `EndpointCreator` for advanced customization.\n        is_deleted_column: Optional column name to use for indicating a soft delete. Defaults to `\"is_deleted\"`.\n        deleted_at_column: Optional column name to use for storing the timestamp of a soft delete. Defaults to `\"deleted_at\"`.\n        updated_at_column: Optional column name to use for storing the timestamp of an update. Defaults to `\"updated_at\"`.\n        endpoint_names: Optional dictionary to customize endpoint names for CRUD operations. Keys are operation types\n                        (`\"create\"`, `\"read\"`, `\"update\"`, `\"delete\"`, `\"db_delete\"`, `\"read_multi\"`), and\n                        values are the custom names to use. Unspecified operations will use default names.\n        filter_config: Optional `FilterConfig` instance or dictionary to configure filters for the `read_multi` endpoint.\n        select_schema: Optional Pydantic schema for selecting an item.\n\n    Returns:\n        Configured `APIRouter` instance with the CRUD endpoints.\n\n    Raises:\n        ValueError: If both `included_methods` and `deleted_methods` are provided.\n\n    Examples:\n        ??? example \"Models and Schemas Used Below\"\n\n            ??? example \"`mymodel/model.py`\"\n\n                ```python\n                --8&lt;--\n                fastcrud/examples/mymodel/model.py:imports\n                fastcrud/examples/mymodel/model.py:model_simple\n                --8&lt;--\n                ```\n\n            ??? example \"`mymodel/schemas.py`\"\n\n                ```python\n                --8&lt;--\n                fastcrud/examples/mymodel/schemas.py:imports\n                fastcrud/examples/mymodel/schemas.py:createschema\n                fastcrud/examples/mymodel/schemas.py:updateschema\n                fastcrud/examples/mymodel/schemas.py:deleteschema\n                --8&lt;--\n                ```\n\n            ---\n\n            ??? example \"`customer/model.py`\"\n\n                ```python\n                --8&lt;--\n                fastcrud/examples/customer/model.py:imports\n                fastcrud/examples/customer/model.py:model\n                --8&lt;--\n                ```\n\n            ??? example \"`customer/schemas.py`\"\n\n                ```python\n                --8&lt;--\n                fastcrud/examples/customer/schemas.py:imports\n                fastcrud/examples/customer/schemas.py:createschema\n                fastcrud/examples/customer/schemas.py:readschema\n                fastcrud/examples/customer/schemas.py:updateschema\n                fastcrud/examples/customer/schemas.py:deleteschema\n                --8&lt;--\n                ```\n\n            ??? example \"`product/model.py`\"\n\n                ```python\n                --8&lt;--\n                fastcrud/examples/product/model.py:imports\n                fastcrud/examples/product/model.py:model\n                --8&lt;--\n                ```\n\n            ??? example \"`product/schemas.py`\"\n\n                ```python\n                --8&lt;--\n                fastcrud/examples/product/schemas.py:imports\n                fastcrud/examples/product/schemas.py:createschema\n                fastcrud/examples/product/schemas.py:readschema\n                fastcrud/examples/product/schemas.py:updateschema\n                fastcrud/examples/product/schemas.py:deleteschema\n                --8&lt;--\n                ```\n\n            ??? example \"`order/model.py`\"\n\n                ```python\n                --8&lt;--\n                fastcrud/examples/order/model.py:imports\n                fastcrud/examples/order/model.py:model\n                --8&lt;--\n                ```\n\n            ??? example \"`order/schemas.py`\"\n\n                ```python\n                --8&lt;--\n                fastcrud/examples/order/schemas.py:imports\n                fastcrud/examples/order/schemas.py:createschema\n                fastcrud/examples/order/schemas.py:readschema\n                fastcrud/examples/order/schemas.py:updateschema\n                fastcrud/examples/order/schemas.py:deleteschema\n                --8&lt;--\n                ```\n\n            ---\n\n            ??? example \"`tier/model.py`\"\n\n                ```python\n                --8&lt;--\n                fastcrud/examples/tier/model.py:imports\n                fastcrud/examples/tier/model.py:model\n                --8&lt;--\n                ```\n\n            ??? example \"`tier/schemas.py`\"\n\n                ```python\n                --8&lt;--\n                fastcrud/examples/tier/schemas.py:imports\n                fastcrud/examples/tier/schemas.py:readschema\n                --8&lt;--\n                ```\n\n            ??? example \"`department/model.py`\"\n\n                ```python\n                --8&lt;--\n                fastcrud/examples/department/model.py:imports\n                fastcrud/examples/department/model.py:model\n                --8&lt;--\n                ```\n\n            ??? example \"`department/schemas.py`\"\n\n                ```python\n                --8&lt;--\n                fastcrud/examples/department/schemas.py:imports\n                fastcrud/examples/department/schemas.py:readschema\n                --8&lt;--\n                ```\n\n            ??? example \"`user/model.py`\"\n\n                ```python\n                --8&lt;--\n                fastcrud/examples/user/model.py:imports\n                fastcrud/examples/user/model.py:model\n                --8&lt;--\n                ```\n\n            ??? example \"`user/schemas.py`\"\n\n                ```python\n                --8&lt;--\n                fastcrud/examples/user/schemas.py:imports\n                fastcrud/examples/user/schemas.py:createschema\n                fastcrud/examples/user/schemas.py:readschema\n                fastcrud/examples/user/schemas.py:updateschema\n                fastcrud/examples/user/schemas.py:deleteschema\n                --8&lt;--\n                ```\n\n            ??? example \"`story/model.py`\"\n\n                ```python\n                --8&lt;--\n                fastcrud/examples/story/model.py:imports\n                fastcrud/examples/story/model.py:model\n                --8&lt;--\n                ```\n\n            ??? example \"`story/schemas.py`\"\n\n                ```python\n                --8&lt;--\n                fastcrud/examples/story/schemas.py:imports\n                fastcrud/examples/story/schemas.py:createschema\n                fastcrud/examples/story/schemas.py:readschema\n                fastcrud/examples/story/schemas.py:updateschema\n                fastcrud/examples/story/schemas.py:deleteschema\n                --8&lt;--\n                ```\n\n            ??? example \"`task/model.py`\"\n\n                ```python\n                --8&lt;--\n                fastcrud/examples/task/model.py:imports\n                fastcrud/examples/task/model.py:model\n                --8&lt;--\n                ```\n\n            ??? example \"`task/schemas.py`\"\n\n                ```python\n                --8&lt;--\n                fastcrud/examples/task/schemas.py:imports\n                fastcrud/examples/task/schemas.py:createschema\n                fastcrud/examples/task/schemas.py:readschema\n                fastcrud/examples/task/schemas.py:updateschema\n                fastcrud/examples/task/schemas.py:deleteschema\n                --8&lt;--\n                ```\n\n        Basic Setup:\n\n        ```python\n        mymodel_router = crud_router(\n            session=async_session,\n            model=MyModel,\n            create_schema=CreateMyModelSchema,\n            update_schema=UpdateMyModelSchema,\n            path=\"/mymodel\",\n            tags=[\"MyModel\"],\n        )\n        ```\n\n        With Custom Dependencies:\n\n        ```python\n        def get_current_user(token: str = Depends(oauth2_scheme)):\n            # Implement user retrieval logic\n            return ...\n\n        user_router = crud_router(\n            session=async_session,\n            model=User,\n            create_schema=CreateUserSchema,\n            update_schema=UpdateUserSchema,\n            read_deps=[get_current_user],\n            update_deps=[get_current_user],\n            path=\"/users\",\n            tags=[\"Users\"],\n        )\n        ```\n\n        Adding Delete Endpoints:\n        ```python\n        product_router = crud_router(\n            session=async_session,\n            model=Product,\n            create_schema=CreateProductSchema,\n            update_schema=UpdateProductSchema,\n            delete_schema=DeleteProductSchema,\n            path=\"/products\",\n            tags=[\"Products\"],\n        )\n        ```\n\n        Customizing Path and Tags:\n        ```python\n        OrderCRUD = FastCRUD[\n            Order,\n            CreateOrderSchema,\n            UpdateOrderSchema,\n            UpdateOrderSchema,\n            DeleteOrderSchema,\n        ]\n        order_router = crud_router(\n            session=async_session,\n            model=Order,\n            create_schema=CreateOrderSchema,\n            update_schema=UpdateOrderSchema,\n            crud=OrderCRUD(Order),\n            path=\"/orders\",\n            tags=[\"Orders\", \"Sales\"],\n        )\n        ```\n\n        Integrating Multiple Models:\n        ```python\n        ProductCRUD = FastCRUD[\n            Product,\n            CreateProductSchema,\n            UpdateProductSchema,\n            UpdateProductSchema,\n            DeleteProductSchema,\n        ]\n        product_router = crud_router(\n            session=async_session,\n            model=Product,\n            create_schema=CreateProductSchema,\n            update_schema=UpdateProductSchema,\n            crud=ProductCRUD(Product),\n            path=\"/products\",\n            tags=[\"Inventory\"],\n        )\n\n        CustomerCRUD = FastCRUD[\n            Customer,\n            CreateCustomerSchema,\n            UpdateCustomerSchema,\n            UpdateCustomerSchema,\n            DeleteCustomerSchema,\n        ]\n        customer_router = crud_router(\n            session=async_session,\n            model=Customer,\n            create_schema=CreateCustomerSchema,\n            update_schema=UpdateCustomerSchema,\n            crud=CustomerCRUD(Customer),\n            path=\"/customers\",\n            tags=[\"CRM\"],\n        )\n        ```\n\n        With Selective CRUD Methods:\n\n        ```python\n        MyModelCRUD = FastCRUD[\n            MyModel,\n            CreateMyModelSchema,\n            UpdateMyModelSchema,\n            UpdateMyModelSchema,\n            DeleteMyModelSchema,\n        ]\n        # Only include 'create' and 'read' methods\n        mymodel_router = crud_router(\n            session=async_session,\n            model=MyModel,\n            create_schema=CreateMyModelSchema,\n            update_schema=UpdateMyModelSchema,\n            crud=MyModelCRUD(MyModel),\n            path=\"/mymodel\",\n            tags=[\"MyModel\"],\n            included_methods=[\"create\", \"read\"],\n        )\n        ```\n\n        Using a Custom `EndpointCreator`:\n\n        ```python\n        class CustomEndpointCreator(EndpointCreator):\n            def _custom_route(self):\n                async def custom_endpoint():\n                    # Custom endpoint logic\n                    return {\"message\": \"Custom route\"}\n\n                return custom_endpoint\n\n                async def add_routes_to_router(self, ...):\n                    # First, add standard CRUD routes\n                    super().add_routes_to_router(...)\n\n                    # Now, add custom routes\n                    self.router.add_api_route(\n                        path=\"/custom\",\n                        endpoint=self._custom_route(),\n                        methods=[\"GET\"],\n                        tags=self.tags,\n                        # Other parameters as needed\n                    )\n\n        MyModelCRUD = FastCRUD[\n            MyModel,\n            CreateMyModelSchema,\n            UpdateMyModelSchema,\n            UpdateMyModelSchema,\n            DeleteMyModelSchema,\n        ]\n        mymodel_router = crud_router(\n            session=async_session,\n            model=MyModel,\n            create_schema=CreateMyModelSchema,\n            update_schema=UpdateMyModelSchema,\n            crud=MyModelCRUD(MyModel),\n            path=\"/mymodel\",\n            tags=[\"MyModel\"],\n            endpoint_creator=CustomEndpointCreator,\n        )\n\n        app.include_router(mymodel_router)\n        ```\n\n        Customizing Endpoint Names:\n\n        ```python\n        task_router = crud_router(\n            session=async_session,\n            model=Task,\n            create_schema=CreateTaskSchema,\n            update_schema=UpdateTaskSchema,\n            path=\"/tasks\",\n            tags=[\"Task Management\"],\n            endpoint_names={\n                \"create\": \"add_task\",\n                \"read\": \"get_task\",\n                \"update\": \"modify_task\",\n                \"delete\": \"remove_task\",\n                \"db_delete\": \"permanently_remove_task\",\n                \"read_multi\": \"list_tasks\",\n            },\n        )\n        ```\n\n        Using `FilterConfig` with `dict`:\n\n        ```python\n        from fastapi import FastAPI\n        from fastcrud import crud_router\n\n        from .database import async_session\n        from .mymodel.model import MyModel\n        from .mymodel.schemas import CreateMyModelSchema, UpdateMyModelSchema\n\n        app = FastAPI()\n\n        mymodel_router = crud_router(\n            session=async_session,\n            model=MyModel,\n            create_schema=CreateMyModelSchema,\n            update_schema=UpdateMyModelSchema,\n            filter_config=FilterConfig(filters={\"id\": None, \"name\": \"default\"}),\n        )\n        # Adds CRUD routes with filtering capabilities\n        app.include_router(mymodel_router, prefix=\"/mymodel\")\n\n        # Explanation:\n        # The FilterConfig specifies that 'id' should be a query parameter with no default value\n        # and 'name' should be a query parameter with a default value of 'default'.\n        # When fetching multiple items, you can filter by these parameters.\n        # Example GET request: /mymodel/get_multi?id=1&amp;name=example\n        ```\n\n        Using `FilterConfig` with keyword arguments:\n\n        ```python\n        from fastapi import FastAPI\n        from fastcrud import crud_router\n\n        from .database import async_session\n        from .mymodel.model import MyModel\n        from .mymodel.schemas import CreateMyModelSchema, UpdateMyModelSchema\n\n        app = FastAPI()\n\n        mymodel_router = crud_router(\n            session=async_session,\n            model=MyModel,\n            create_schema=CreateMyModelSchema,\n            update_schema=UpdateMyModelSchema,\n            filter_config=FilterConfig(id=None, name=\"default\"),\n        )\n        # Adds CRUD routes with filtering capabilities\n        app.include_router(mymodel_router, prefix=\"/mymodel\")\n\n        # Explanation:\n        # The FilterConfig specifies that 'id' should be a query parameter with no default value\n        # and 'name' should be a query parameter with a default value of 'default'.\n        # When fetching multiple items, you can filter by these parameters.\n        # Example GET request: /mymodel/get_multi?id=1&amp;name=example\n        ```\n    \"\"\"\n    crud = crud or FastCRUD(\n        model=model,\n        is_deleted_column=is_deleted_column,\n        deleted_at_column=deleted_at_column,\n        updated_at_column=updated_at_column,\n    )\n\n    endpoint_creator_class = endpoint_creator or EndpointCreator\n    endpoint_creator_instance = endpoint_creator_class(\n        session=session,\n        model=model,\n        crud=crud,\n        create_schema=create_schema,  # type: ignore\n        update_schema=update_schema,  # type: ignore\n        include_in_schema=include_in_schema,\n        delete_schema=delete_schema,  # type: ignore\n        path=path,\n        tags=tags,\n        is_deleted_column=is_deleted_column,\n        deleted_at_column=deleted_at_column,\n        updated_at_column=updated_at_column,\n        endpoint_names=endpoint_names,\n        filter_config=filter_config,\n        select_schema=select_schema,  # type: ignore\n        create_config=create_config,\n        update_config=update_config,\n        delete_config=delete_config,\n    )\n\n    endpoint_creator_instance.add_routes_to_router(\n        create_deps=create_deps,\n        read_deps=read_deps,\n        read_multi_deps=read_multi_deps,\n        update_deps=update_deps,\n        delete_deps=delete_deps,\n        db_delete_deps=db_delete_deps,\n        included_methods=included_methods,\n        deleted_methods=deleted_methods,\n    )\n\n    return endpoint_creator_instance.router\n</code></pre>"},{"location":"api/endpoint_creator/","title":"EndpointCreator API Reference","text":"<p><code>EndpointCreator</code> is a class designed to create and register CRUD endpoints for a FastAPI application. It simplifies the process of adding CRUD (Create, Read, Update, Delete) endpoints to a FastAPI router.</p>"},{"location":"api/endpoint_creator/#class-definition","title":"Class Definition","text":"<p>A class to create and register CRUD endpoints for a FastAPI application.</p> <p>This class simplifies the process of adding create, read, update, and delete (CRUD) endpoints to a FastAPI router. It is initialized with a SQLAlchemy session, model, CRUD operations, and Pydantic schemas, and allows for custom dependency injection for each endpoint. The method assumes <code>id</code> is the primary key for path parameters.</p> <p>Attributes:</p> Name Type Description <code>session</code> <p>The SQLAlchemy async session.</p> <code>model</code> <p>The SQLAlchemy model.</p> <code>create_schema</code> <p>Pydantic schema for creating an item.</p> <code>update_schema</code> <p>Pydantic schema for updating an item.</p> <code>crud</code> <p>An optional FastCRUD instance. If not provided, uses <code>FastCRUD(model)</code>.</p> <code>include_in_schema</code> <p>Whether to include the created endpoints in the OpenAPI schema.</p> <code>delete_schema</code> <p>Optional Pydantic schema for deleting an item.</p> <code>path</code> <p>Base path for the CRUD endpoints.</p> <code>tags</code> <p>List of tags for grouping endpoints in the documentation.</p> <code>is_deleted_column</code> <p>Optional column name to use for indicating a soft delete. Defaults to <code>\"is_deleted\"</code>.</p> <code>deleted_at_column</code> <p>Optional column name to use for storing the timestamp of a soft delete. Defaults to <code>\"deleted_at\"</code>.</p> <code>updated_at_column</code> <p>Optional column name to use for storing the timestamp of an update. Defaults to <code>\"updated_at\"</code>.</p> <code>endpoint_names</code> <p>Optional dictionary to customize endpoint names for CRUD operations. Keys are operation types             (<code>\"create\"</code>, <code>\"read\"</code>, <code>\"update\"</code>, <code>\"delete\"</code>, <code>\"db_delete\"</code>, <code>\"read_multi\"</code>), and             values are the custom names to use. Unspecified operations will use default names.</p> <code>filter_config</code> <code>Optional[FilterConfig]</code> <p>Optional <code>FilterConfig</code> instance or dictionary to configure filters for the <code>read_multi</code> endpoint.</p> <code>select_schema</code> <p>Optional Pydantic schema for selecting an item.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If both <code>included_methods</code> and <code>deleted_methods</code> are provided.</p> <p>Examples:</p> <p>Basic Setup:</p> <code>mymodel/model.py</code> <pre><code>from sqlalchemy import Boolean, Column, DateTime, Integer, String\nfrom sqlalchemy.orm import DeclarativeBase\n\n\nclass Base(DeclarativeBase):\n    pass\n\n\nclass MyModel(Base):\n    __tablename__ = \"my_model\"\n    id = Column(Integer, primary_key=True)\n    name = Column(String)\n</code></pre> <code>mymodel/schemas.py</code> <pre><code>import datetime\n\nfrom pydantic import BaseModel\n\n\nclass CreateMyModelSchema(BaseModel):\n    name: str | None = None\n\n\nclass UpdateMyModelSchema(BaseModel):\n    name: str | None = None\n</code></pre> <pre><code>from fastapi import FastAPI\nfrom fastcrud import EndpointCreator\n\nfrom .database import async_session\nfrom .mymodel.model import MyModel\nfrom .mymodel.schemas import CreateMyModelSchema, UpdateMyModelSchema\n\napp = FastAPI()\nendpoint_creator = EndpointCreator(\n    session=async_session,\n    model=MyModel,\n    create_schema=CreateMyModelSchema,\n    update_schema=UpdateMyModelSchema,\n)\nendpoint_creator.add_routes_to_router()\napp.include_router(endpoint_creator.router, prefix=\"/mymodel\")\n</code></pre> <p>With Custom Dependencies:</p> <pre><code>from fastapi.security import OAuth2PasswordBearer\n\noauth2_scheme = OAuth2PasswordBearer(tokenUrl=\"token\")\n\ndef get_current_user(token: str = Depends(oauth2_scheme)):\n    return ...\n\nendpoint_creator.add_routes_to_router(\n    read_deps=[get_current_user],\n    update_deps=[get_current_user],\n)\n</code></pre> <p>Selective Endpoint Creation (inclusion):</p> <pre><code># Only create 'create' and 'read' endpoints\nendpoint_creator.add_routes_to_router(\n    included_methods=[\"create\", \"read\"],\n)\n</code></pre> <p>Selective Endpoint Creation (deletion):</p> <pre><code># Create all but 'update' and 'delete' endpoints\nendpoint_creator.add_routes_to_router(\n    deleted_methods=[\"update\", \"delete\"],\n)\n</code></pre> <p>Integrating with Multiple Models:</p> <pre><code># Assuming definitions for OtherModel, OtherModelCRUD, etc.\n\nother_model_crud = OtherModelCRUD(OtherModel)\nother_endpoint_creator = EndpointCreator(\n    session=async_session,\n    model=OtherModel,\n    create_schema=CreateOtherModelSchema,\n    update_schema=UpdateOtherModelSchema,\n    crud=other_model_crud,\n)\nother_endpoint_creator.add_routes_to_router()\napp.include_router(other_endpoint_creator.router, prefix=\"/othermodel\")\n</code></pre> <p>Customizing Endpoint Names:</p> <pre><code>endpoint_creator = EndpointCreator(\n    session=async_session,\n    model=MyModel,\n    create_schema=CreateMyModelSchema,\n    update_schema=UpdateMyModelSchema,\n    path=\"/mymodel\",\n    tags=[\"MyModel\"],\n    endpoint_names={\n        \"create\": \"add\",  # Custom endpoint name for creating items\n        \"read\": \"fetch\",  # Custom endpoint name for reading a single item\n        \"update\": \"change\",  # Custom endpoint name for updating items\n        # The delete operation will use the default name \"delete\"\n    },\n)\nendpoint_creator.add_routes_to_router()\n</code></pre> <p>Using <code>filter_config</code> with <code>dict</code>:</p> <pre><code>from fastapi import FastAPI\nfrom fastcrud import EndpointCreator, FilterConfig\n\nfrom .database import async_session\nfrom .mymodel.model import MyModel\nfrom .mymodel.schemas import CreateMyModelSchema, UpdateMyModelSchema\n\napp = FastAPI()\nendpoint_creator = EndpointCreator(\n    session=async_session,\n    model=MyModel,\n    create_schema=CreateMyModelSchema,\n    update_schema=UpdateMyModelSchema,\n    filter_config=FilterConfig(filters={\"id\": None, \"name\": \"default\"}),\n)\n# Adds CRUD routes with filtering capabilities\nendpoint_creator.add_routes_to_router()\n# Include the internal router into the FastAPI app\napp.include_router(endpoint_creator.router, prefix=\"/mymodel\")\n\n# Explanation:\n# The FilterConfig specifies that 'id' should be a query parameter with no default value\n# and 'name' should be a query parameter with a default value of 'default'.\n# When fetching multiple items, you can filter by these parameters.\n# Example GET request: /mymodel/get_multi?id=1&amp;name=example\n</code></pre> <p>Using <code>filter_config</code> with keyword arguments:</p> <pre><code>from fastapi import FastAPI\nfrom fastcrud import EndpointCreator, FilterConfig\n\nfrom .database import async_session\nfrom .mymodel.model import MyModel\nfrom .mymodel.schemas import CreateMyModelSchema, UpdateMyModelSchema\n\napp = FastAPI()\nendpoint_creator = EndpointCreator(\n    session=async_session,\n    model=MyModel,\n    create_schema=CreateMyModelSchema,\n    update_schema=UpdateMyModelSchema,\n    filter_config=FilterConfig(id=None, name=\"default\"),\n)\n# Adds CRUD routes with filtering capabilities\nendpoint_creator.add_routes_to_router()\n# Include the internal router into the FastAPI app\napp.include_router(endpoint_creator.router, prefix=\"/mymodel\")\n\n# Explanation:\n# The FilterConfig specifies that 'id' should be a query parameter with no default value\n# and 'name' should be a query parameter with a default value of 'default'.\n# When fetching multiple items, you can filter by these parameters.\n# Example GET request: /mymodel/get_multi?id=1&amp;name=example\n</code></pre> Source code in <code>fastcrud/endpoint/endpoint_creator.py</code> <pre><code>class EndpointCreator:\n    \"\"\"\n    A class to create and register CRUD endpoints for a FastAPI application.\n\n    This class simplifies the process of adding create, read, update, and delete (CRUD) endpoints\n    to a FastAPI router. It is initialized with a SQLAlchemy session, model, CRUD operations,\n    and Pydantic schemas, and allows for custom dependency injection for each endpoint.\n    The method assumes `id` is the primary key for path parameters.\n\n    Attributes:\n        session: The SQLAlchemy async session.\n        model: The SQLAlchemy model.\n        create_schema: Pydantic schema for creating an item.\n        update_schema: Pydantic schema for updating an item.\n        crud: An optional FastCRUD instance. If not provided, uses `FastCRUD(model)`.\n        include_in_schema: Whether to include the created endpoints in the OpenAPI schema.\n        delete_schema: Optional Pydantic schema for deleting an item.\n        path: Base path for the CRUD endpoints.\n        tags: List of tags for grouping endpoints in the documentation.\n        is_deleted_column: Optional column name to use for indicating a soft delete. Defaults to `\"is_deleted\"`.\n        deleted_at_column: Optional column name to use for storing the timestamp of a soft delete. Defaults to `\"deleted_at\"`.\n        updated_at_column: Optional column name to use for storing the timestamp of an update. Defaults to `\"updated_at\"`.\n        endpoint_names: Optional dictionary to customize endpoint names for CRUD operations. Keys are operation types\n                        (`\"create\"`, `\"read\"`, `\"update\"`, `\"delete\"`, `\"db_delete\"`, `\"read_multi\"`), and\n                        values are the custom names to use. Unspecified operations will use default names.\n        filter_config: Optional `FilterConfig` instance or dictionary to configure filters for the `read_multi` endpoint.\n        select_schema: Optional Pydantic schema for selecting an item.\n\n    Raises:\n        ValueError: If both `included_methods` and `deleted_methods` are provided.\n\n    Examples:\n        Basic Setup:\n\n        ??? example \"`mymodel/model.py`\"\n\n            ```python\n            --8&lt;--\n            fastcrud/examples/mymodel/model.py:imports\n            fastcrud/examples/mymodel/model.py:model_simple\n            --8&lt;--\n            ```\n\n        ??? example \"`mymodel/schemas.py`\"\n\n            ```python\n            --8&lt;--\n            fastcrud/examples/mymodel/schemas.py:imports\n            fastcrud/examples/mymodel/schemas.py:createschema\n            fastcrud/examples/mymodel/schemas.py:updateschema\n            --8&lt;--\n            ```\n\n        ```python\n        from fastapi import FastAPI\n        from fastcrud import EndpointCreator\n\n        from .database import async_session\n        from .mymodel.model import MyModel\n        from .mymodel.schemas import CreateMyModelSchema, UpdateMyModelSchema\n\n        app = FastAPI()\n        endpoint_creator = EndpointCreator(\n            session=async_session,\n            model=MyModel,\n            create_schema=CreateMyModelSchema,\n            update_schema=UpdateMyModelSchema,\n        )\n        endpoint_creator.add_routes_to_router()\n        app.include_router(endpoint_creator.router, prefix=\"/mymodel\")\n        ```\n\n        With Custom Dependencies:\n\n        ```python\n        from fastapi.security import OAuth2PasswordBearer\n\n        oauth2_scheme = OAuth2PasswordBearer(tokenUrl=\"token\")\n\n        def get_current_user(token: str = Depends(oauth2_scheme)):\n            return ...\n\n        endpoint_creator.add_routes_to_router(\n            read_deps=[get_current_user],\n            update_deps=[get_current_user],\n        )\n        ```\n\n        Selective Endpoint Creation (inclusion):\n\n        ```python\n        # Only create 'create' and 'read' endpoints\n        endpoint_creator.add_routes_to_router(\n            included_methods=[\"create\", \"read\"],\n        )\n        ```\n\n        Selective Endpoint Creation (deletion):\n\n        ```python\n        # Create all but 'update' and 'delete' endpoints\n        endpoint_creator.add_routes_to_router(\n            deleted_methods=[\"update\", \"delete\"],\n        )\n        ```\n\n        Integrating with Multiple Models:\n\n        ```python\n        # Assuming definitions for OtherModel, OtherModelCRUD, etc.\n\n        other_model_crud = OtherModelCRUD(OtherModel)\n        other_endpoint_creator = EndpointCreator(\n            session=async_session,\n            model=OtherModel,\n            create_schema=CreateOtherModelSchema,\n            update_schema=UpdateOtherModelSchema,\n            crud=other_model_crud,\n        )\n        other_endpoint_creator.add_routes_to_router()\n        app.include_router(other_endpoint_creator.router, prefix=\"/othermodel\")\n        ```\n\n        Customizing Endpoint Names:\n\n        ```python\n        endpoint_creator = EndpointCreator(\n            session=async_session,\n            model=MyModel,\n            create_schema=CreateMyModelSchema,\n            update_schema=UpdateMyModelSchema,\n            path=\"/mymodel\",\n            tags=[\"MyModel\"],\n            endpoint_names={\n                \"create\": \"add\",  # Custom endpoint name for creating items\n                \"read\": \"fetch\",  # Custom endpoint name for reading a single item\n                \"update\": \"change\",  # Custom endpoint name for updating items\n                # The delete operation will use the default name \"delete\"\n            },\n        )\n        endpoint_creator.add_routes_to_router()\n        ```\n\n        Using `filter_config` with `dict`:\n\n        ```python\n        from fastapi import FastAPI\n        from fastcrud import EndpointCreator, FilterConfig\n\n        from .database import async_session\n        from .mymodel.model import MyModel\n        from .mymodel.schemas import CreateMyModelSchema, UpdateMyModelSchema\n\n        app = FastAPI()\n        endpoint_creator = EndpointCreator(\n            session=async_session,\n            model=MyModel,\n            create_schema=CreateMyModelSchema,\n            update_schema=UpdateMyModelSchema,\n            filter_config=FilterConfig(filters={\"id\": None, \"name\": \"default\"}),\n        )\n        # Adds CRUD routes with filtering capabilities\n        endpoint_creator.add_routes_to_router()\n        # Include the internal router into the FastAPI app\n        app.include_router(endpoint_creator.router, prefix=\"/mymodel\")\n\n        # Explanation:\n        # The FilterConfig specifies that 'id' should be a query parameter with no default value\n        # and 'name' should be a query parameter with a default value of 'default'.\n        # When fetching multiple items, you can filter by these parameters.\n        # Example GET request: /mymodel/get_multi?id=1&amp;name=example\n        ```\n\n        Using `filter_config` with keyword arguments:\n\n        ```python\n        from fastapi import FastAPI\n        from fastcrud import EndpointCreator, FilterConfig\n\n        from .database import async_session\n        from .mymodel.model import MyModel\n        from .mymodel.schemas import CreateMyModelSchema, UpdateMyModelSchema\n\n        app = FastAPI()\n        endpoint_creator = EndpointCreator(\n            session=async_session,\n            model=MyModel,\n            create_schema=CreateMyModelSchema,\n            update_schema=UpdateMyModelSchema,\n            filter_config=FilterConfig(id=None, name=\"default\"),\n        )\n        # Adds CRUD routes with filtering capabilities\n        endpoint_creator.add_routes_to_router()\n        # Include the internal router into the FastAPI app\n        app.include_router(endpoint_creator.router, prefix=\"/mymodel\")\n\n        # Explanation:\n        # The FilterConfig specifies that 'id' should be a query parameter with no default value\n        # and 'name' should be a query parameter with a default value of 'default'.\n        # When fetching multiple items, you can filter by these parameters.\n        # Example GET request: /mymodel/get_multi?id=1&amp;name=example\n        ```\n    \"\"\"\n\n    def __init__(\n        self,\n        session: Callable,\n        model: ModelType,\n        create_schema: Type[CreateSchemaType],\n        update_schema: Type[UpdateSchemaType],\n        crud: Optional[FastCRUD] = None,\n        include_in_schema: bool = True,\n        delete_schema: Optional[Type[DeleteSchemaType]] = None,\n        path: str = \"\",\n        tags: Optional[list[Union[str, Enum]]] = None,\n        is_deleted_column: str = \"is_deleted\",\n        deleted_at_column: str = \"deleted_at\",\n        updated_at_column: str = \"updated_at\",\n        endpoint_names: Optional[dict[str, str]] = None,\n        filter_config: Optional[Union[FilterConfig, dict]] = None,\n        select_schema: Optional[Type[SelectSchemaType]] = None,\n        create_config: Optional[CreateConfig] = None,\n        update_config: Optional[UpdateConfig] = None,\n        delete_config: Optional[DeleteConfig] = None,\n    ) -&gt; None:\n        self._primary_keys = get_primary_key_columns(model)\n        self._primary_keys_types = {\n            pk.name: pk_type\n            for pk in self._primary_keys\n            if (pk_type := get_python_type(pk)) is not None\n        }\n        self.primary_key_names = [pk.name for pk in self._primary_keys]\n        self.session = session\n        self.crud = crud or FastCRUD(\n            model=model,\n            is_deleted_column=is_deleted_column,\n            deleted_at_column=deleted_at_column,\n            updated_at_column=updated_at_column,\n        )\n        self.model = model\n        self.create_schema = create_schema\n        self.update_schema = update_schema\n        self.delete_schema = delete_schema\n        self.select_schema = select_schema\n        self.include_in_schema = include_in_schema\n        self.path = path\n        self.tags = tags or []\n        self.router = APIRouter()\n        self.is_deleted_column = is_deleted_column\n        self.deleted_at_column = deleted_at_column\n        self.updated_at_column = updated_at_column\n        self.default_endpoint_names = {\n            \"create\": \"\",\n            \"read\": \"\",\n            \"update\": \"\",\n            \"delete\": \"\",\n            \"db_delete\": \"db_delete\",\n            \"read_multi\": \"\",\n        }\n        self.endpoint_names = {**self.default_endpoint_names, **(endpoint_names or {})}\n        if filter_config:\n            if isinstance(filter_config, dict):\n                filter_config = FilterConfig(**filter_config)\n            self._validate_filter_config(filter_config)\n            self.filter_config: Optional[FilterConfig] = filter_config\n        else:\n            self.filter_config = None\n        self.create_config = create_config\n        self.update_config = update_config\n        self.delete_config = delete_config\n        self.column_types = dict(get_column_types(model))\n\n        if select_schema is not None:\n            response_key = getattr(self.crud, \"multi_response_key\", \"data\")\n            self.list_response_model = create_list_response(select_schema, response_key)\n            self.paginated_response_model = create_paginated_response(\n                select_schema, response_key\n            )\n        else:\n            self.list_response_model = None  # type: ignore\n            self.paginated_response_model = None  # type: ignore\n\n    def _validate_filter_config(self, filter_config: FilterConfig) -&gt; None:\n        model_columns = self.crud.model_col_names\n        supported_filters = SUPPORTED_FILTERS\n        for key, value in filter_config.filters.items():\n            if callable(value):\n                continue\n\n            if filter_config.is_joined_filter(key):\n                try:\n                    relationship_path, final_field, operator = (\n                        filter_config.parse_joined_filter(key)\n                    )\n\n                    if operator and operator not in supported_filters:\n                        raise ValueError(\n                            f\"Invalid filter op '{operator}': following filter ops are allowed: {supported_filters.keys()}\"\n                        )\n\n                    if not validate_joined_filter_path(\n                        self.model, relationship_path, final_field\n                    ):\n                        raise ValueError(\n                            f\"Invalid joined filter '{key}': relationship path {'.'.join(relationship_path + [final_field])} not found in model '{self.model.__name__}'\"\n                        )\n                except ValueError as e:\n                    raise ValueError(f\"Invalid joined filter '{key}': {str(e)}\")\n            else:\n                if \"__\" in key:\n                    field_name, op = key.rsplit(\"__\", 1)\n                    if op not in supported_filters:\n                        raise ValueError(\n                            f\"Invalid filter op '{op}': following filter ops are allowed: {supported_filters.keys()}\"\n                        )\n                else:\n                    field_name = key\n\n                if field_name not in model_columns:\n                    raise ValueError(\n                        f\"Invalid filter column '{key}': not found in model '{self.model.__name__}' columns\"\n                    )\n\n    def _create_item(self) -&gt; Callable[..., Awaitable[Any]]:\n        \"\"\"Creates an endpoint for creating items in the database.\"\"\"\n        auto_field_injector = create_auto_field_injector(self.create_config)\n\n        request_schema: type[BaseModel] = self.create_schema\n        if self.create_config and self.create_config.exclude_from_schema:\n            request_schema = create_modified_schema(\n                self.create_schema,\n                tuple(self.create_config.exclude_from_schema),\n                f\"{self.create_schema.__name__}Modified\",\n            )\n\n        async def endpoint(\n            db: AsyncSession = Depends(self.session),\n            item: BaseModel = Body(...),\n            auto_fields: dict = Depends(auto_field_injector),\n        ):\n            unique_columns = get_unique_columns(self.model)\n\n            for column in unique_columns:\n                col_name = column.name\n                if hasattr(item, col_name):\n                    value = getattr(item, col_name)\n                    exists = await self.crud.exists(db, **{col_name: value})\n                    if exists:  # pragma: no cover\n                        raise DuplicateValueException(\n                            f\"Value {value} is already registered\"\n                        )\n\n            if auto_fields:\n                item_dict = item.model_dump()\n                item_dict.update(auto_fields)\n                db_object = self.model(**item_dict)\n                db.add(db_object)\n                await db.commit()\n                await db.refresh(db_object)\n                return db_object\n\n            return await self.crud.create(db, item)\n\n        endpoint.__annotations__[\"item\"] = request_schema\n\n        return endpoint\n\n    def _read_item(self) -&gt; Callable[..., Awaitable[Any]]:\n        \"\"\"Creates an endpoint for reading a single item from the database.\"\"\"\n\n        @apply_model_pk(**self._primary_keys_types)\n        async def endpoint(db: AsyncSession = Depends(self.session), **pkeys):\n            if self.select_schema is not None:\n                item = await self.crud.get(\n                    db,\n                    schema_to_select=cast(Type[BaseModel], self.select_schema),\n                    return_as_model=True,\n                    **pkeys,\n                )\n            else:\n                item = await self.crud.get(db, **pkeys)\n            if not item:  # pragma: no cover\n                raise NotFoundException(detail=\"Item not found\")\n            return item  # pragma: no cover\n\n        return cast(Callable[..., Awaitable[Any]], endpoint)\n\n    def _read_items(\n        self,\n    ) -&gt; Callable[\n        ...,\n        Awaitable[Union[dict[str, Any], PaginatedListResponse[Any], ListResponse[Any]]],\n    ]:\n        \"\"\"Creates an endpoint for reading multiple items from the database.\n\n        The created endpoint supports:\n        - Pagination (using page/itemsPerPage or offset/limit)\n        - Filtering based on configured filter parameters\n        - Sorting by one or more fields (supports both ascending and descending order)\n\n        Sorting can be applied using the 'sort' query parameter:\n        - Single field ascending: ?sort=field_name\n        - Single field descending: ?sort=-field_name\n        - Multiple fields: ?sort=field1,-field2 (field1 asc, field2 desc)\n\n        The query parameters are encapsulated in PaginatedRequestQuery schema,\n        which can be reused in custom endpoints.\n        \"\"\"\n        dynamic_filters = create_dynamic_filters(self.filter_config, self.column_types)\n\n        async def endpoint(\n            db: AsyncSession = Depends(self.session),\n            query: PaginatedRequestQuery = Depends(),\n            filters: dict = Depends(dynamic_filters),\n        ) -&gt; Union[dict[str, Any], PaginatedListResponse, ListResponse]:\n            is_paginated = (query.page is not None) or (\n                query.items_per_page is not None\n            )\n            has_offset_limit = (query.offset is not None) and (query.limit is not None)\n            default_offset = 0\n            default_limit = 100\n\n            if is_paginated and has_offset_limit:\n                raise BadRequestException(\n                    detail=\"Conflicting parameters: Use either 'page' and 'itemsPerPage' for paginated results or 'offset' and 'limit' for specific range queries.\"\n                )\n\n            if is_paginated:\n                page = query.page if query.page else 1\n                items_per_page = query.items_per_page if query.items_per_page else 10\n                offset = compute_offset(page=page, items_per_page=items_per_page)  # type: ignore\n                limit = items_per_page\n            elif not has_offset_limit:\n                offset = default_offset\n                limit = default_limit\n            else:\n                offset = query.offset if query.offset is not None else default_offset\n                limit = query.limit if query.limit is not None else default_limit\n\n            sort_columns: list[str] = []\n            sort_orders: list[str] = []\n            if query.sort:\n                for s in query.sort.split(\",\"):\n                    s = s.strip()\n                    if not s:\n                        continue\n                    if s.startswith(\"-\"):\n                        sort_columns.append(s[1:])\n                        sort_orders.append(\"desc\")\n                    else:\n                        sort_columns.append(s)\n                        sort_orders.append(\"asc\")\n\n            if self.select_schema is not None:\n                crud_data = await self.crud.get_multi(\n                    db,\n                    offset=offset,  # type: ignore\n                    limit=limit,  # type: ignore\n                    schema_to_select=self.select_schema,\n                    sort_columns=sort_columns,\n                    sort_orders=sort_orders,\n                    return_as_model=True,\n                    **filters,\n                )\n            else:\n                crud_data = await self.crud.get_multi(\n                    db,\n                    offset=offset,  # type: ignore\n                    limit=limit,  # type: ignore\n                    sort_columns=sort_columns,\n                    sort_orders=sort_orders,\n                    **filters,\n                )\n\n            if is_paginated:\n                return paginated_response(\n                    crud_data=crud_data,\n                    page=page,  # type: ignore\n                    items_per_page=items_per_page,  # type: ignore\n                    multi_response_key=self.crud.multi_response_key,\n                )\n\n            return cast(dict[str, Any], crud_data)  # pragma: no cover\n\n        return endpoint\n\n    def _update_item(self) -&gt; Callable[..., Awaitable[Any]]:\n        \"\"\"Creates an endpoint for updating an existing item in the database.\"\"\"\n        auto_field_injector = create_auto_field_injector(self.update_config)\n\n        request_schema: type[BaseModel] = self.update_schema\n        if self.update_config and self.update_config.exclude_from_schema:\n            request_schema = create_modified_schema(\n                self.update_schema,\n                tuple(self.update_config.exclude_from_schema),\n                f\"{self.update_schema.__name__}Modified\",\n            )\n\n        async def endpoint(\n            item: BaseModel = Body(...),\n            db: AsyncSession = Depends(self.session),\n            auto_fields: dict = Depends(auto_field_injector),\n            **pkeys,\n        ):\n            try:\n                if auto_fields:\n                    item_dict = item.model_dump(exclude_unset=True)\n                    item_dict.update(auto_fields)\n                    return await self.crud.update(db, item_dict, **pkeys)\n\n                return await self.crud.update(db, item, **pkeys)\n            except NoResultFound:\n                raise NotFoundException(detail=\"Item not found\")\n\n        endpoint.__annotations__[\"item\"] = request_schema\n\n        endpoint = apply_model_pk(**self._primary_keys_types)(endpoint)\n\n        return endpoint\n\n    def _delete_item(self) -&gt; Callable[..., Awaitable[Any]]:\n        \"\"\"Creates an endpoint for deleting (soft delete) an item from the database.\"\"\"\n        auto_field_injector = create_auto_field_injector(self.delete_config)\n\n        async def endpoint(\n            db: AsyncSession = Depends(self.session),\n            auto_fields: dict = Depends(auto_field_injector),\n            **pkeys,\n        ):\n            try:\n                await self.crud.delete(db, **pkeys)\n\n                if auto_fields:\n                    await self.crud.update(\n                        db, auto_fields, allow_multiple=False, **pkeys\n                    )\n\n                return {\"message\": \"Item deleted successfully\"}  # pragma: no cover\n            except NoResultFound:\n                raise NotFoundException(detail=\"Item not found\")\n\n        endpoint = apply_model_pk(**self._primary_keys_types)(endpoint)\n\n        return endpoint\n\n    def _db_delete(self) -&gt; Callable[..., Awaitable[Any]]:\n        \"\"\"\n        Creates an endpoint for hard deleting an item from the database.\n\n        This endpoint is only added if the `delete_schema` is provided during initialization.\n        The endpoint expects an item ID as a path parameter and uses the provided SQLAlchemy\n        async session to permanently delete the item from the database.\n        \"\"\"\n\n        @apply_model_pk(**self._primary_keys_types)\n        async def endpoint(db: AsyncSession = Depends(self.session), **pkeys):\n            await self.crud.db_delete(db, **pkeys)\n            return {\n                \"message\": \"Item permanently deleted from the database\"\n            }  # pragma: no cover\n\n        return cast(Callable[..., Awaitable[Any]], endpoint)\n\n    def _get_endpoint_path(self, operation: str) -&gt; str:\n        endpoint_name = self.endpoint_names.get(\n            operation, self.default_endpoint_names.get(operation, operation)\n        )\n        path = f\"{self.path}/{endpoint_name}\" if endpoint_name else self.path\n\n        if operation in {\"read\", \"update\", \"delete\", \"db_delete\"}:\n            _primary_keys_path_suffix = \"/\".join(\n                f\"{{{n}}}\" for n in self.primary_key_names\n            )\n            path = f\"{path}/{_primary_keys_path_suffix}\"\n\n        return path\n\n    def add_routes_to_router(\n        self,\n        create_deps: Sequence[Callable] = [],\n        read_deps: Sequence[Callable] = [],\n        read_multi_deps: Sequence[Callable] = [],\n        update_deps: Sequence[Callable] = [],\n        delete_deps: Sequence[Callable] = [],\n        db_delete_deps: Sequence[Callable] = [],\n        included_methods: Optional[Sequence[str]] = None,\n        deleted_methods: Optional[Sequence[str]] = None,\n    ):\n        \"\"\"\n        Adds CRUD operation routes to the FastAPI router with specified dependencies for each type of operation.\n\n        This method registers routes for create, read, update, and delete operations with the FastAPI router,\n        allowing for custom dependency injection for each type of operation.\n\n        Args:\n            create_deps: List of functions to be injected as dependencies for the create endpoint.\n            read_deps: List of functions to be injected as dependencies for the read endpoint.\n            read_multi_deps: List of functions to be injected as dependencies for the read multiple items endpoint.\n            update_deps: List of functions to be injected as dependencies for the update endpoint.\n            delete_deps: List of functions to be injected as dependencies for the delete endpoint.\n            db_delete_deps: List of functions to be injected as dependencies for the hard delete endpoint.\n            included_methods: Optional list of methods to include. Defaults to all CRUD methods.\n            deleted_methods: Optional list of methods to exclude. Defaults to `None`.\n\n        Raises:\n            ValueError: If both `included_methods` and `deleted_methods` are provided.\n\n        Examples:\n            Selective Endpoint Creation:\n\n            ```python\n            # Only create 'create' and 'read' endpoints\n            endpoint_creator.add_routes_to_router(\n                included_methods=[\"create\", \"read\"],\n            )\n            ```\n\n            Excluding Specific Endpoints:\n\n            ```python\n            # Create all endpoints except 'delete' and 'db_delete'\n            endpoint_creator.add_routes_to_router(\n                deleted_methods=[\"delete\", \"db_delete\"],\n            )\n            ```\n\n            With Custom Dependencies and Selective Endpoints:\n\n            ```python\n            def get_current_user(...):\n                ...\n\n            # Create only 'read' and 'update' endpoints with custom dependencies\n            endpoint_creator.add_routes_to_router(\n                read_deps=[get_current_user],\n                update_deps=[get_current_user],\n                included_methods=[\"read\", \"update\"],\n            )\n            ```\n\n        Note:\n            This method should be called to register the endpoints with the FastAPI application.\n            If `delete_schema` is provided on class instantiation, a hard delete endpoint is also registered.\n            This method assumes `id` is the primary key for path parameters.\n        \"\"\"\n        if (included_methods is not None) and (deleted_methods is not None):\n            raise ValueError(\n                \"Cannot use both 'included_methods' and 'deleted_methods' simultaneously.\"\n            )\n\n        if included_methods is None:\n            included_methods = [\n                \"create\",\n                \"read\",\n                \"read_multi\",\n                \"update\",\n                \"delete\",\n                \"db_delete\",\n            ]\n        else:\n            try:\n                included_methods = CRUDMethods(\n                    valid_methods=included_methods\n                ).valid_methods\n            except ValidationError as e:\n                raise ValueError(f\"Invalid CRUD methods in included_methods: {e}\")\n\n        if deleted_methods is None:\n            deleted_methods = []\n        else:\n            try:\n                deleted_methods = CRUDMethods(\n                    valid_methods=deleted_methods\n                ).valid_methods\n            except ValidationError as e:\n                raise ValueError(f\"Invalid CRUD methods in deleted_methods: {e}\")\n\n        delete_description = \"Delete a\"\n        if self.delete_schema:\n            delete_description = \"Soft delete a\"\n\n        if (\"create\" in included_methods) and (\"create\" not in deleted_methods):\n            self.router.add_api_route(\n                self._get_endpoint_path(operation=\"create\"),\n                self._create_item(),\n                methods=[\"POST\"],\n                include_in_schema=self.include_in_schema,\n                tags=self.tags,\n                dependencies=inject_dependencies(create_deps),\n                description=f\"Create a new {self.model.__name__} row in the database.\",\n            )\n\n        if (\"read\" in included_methods) and (\"read\" not in deleted_methods):\n            self.router.add_api_route(\n                self._get_endpoint_path(operation=\"read\"),\n                self._read_item(),\n                methods=[\"GET\"],\n                include_in_schema=self.include_in_schema,\n                tags=self.tags,\n                dependencies=inject_dependencies(read_deps),\n                response_model=self.select_schema if self.select_schema else None,\n                description=f\"Read a single {self.model.__name__} row from the database by its primary keys: {self.primary_key_names}.\",\n            )\n\n        if (\"read_multi\" in included_methods) and (\"read_multi\" not in deleted_methods):\n            if self.select_schema is not None:\n                response_model: Optional[\n                    Type[Union[PaginatedListResponse[Any], ListResponse[Any]]]\n                ] = Union[\n                    self.paginated_response_model,  # type: ignore\n                    self.list_response_model,  # type: ignore\n                ]\n            else:\n                response_model = None\n\n            self.router.add_api_route(\n                self._get_endpoint_path(operation=\"read_multi\"),\n                self._read_items(),\n                methods=[\"GET\"],\n                include_in_schema=self.include_in_schema,\n                tags=self.tags,\n                dependencies=inject_dependencies(read_multi_deps),\n                response_model=response_model,\n                description=(\n                    f\"Read multiple {self.model.__name__} rows from the database.\\n\\n\"\n                    f\"**Pagination Options:**\\n\"\n                    f\"- Use `page` &amp; `itemsPerPage` for paginated results\\n\"\n                    f\"- Use `offset` &amp; `limit` for specific ranges\\n\\n\"\n                    f\"**Sorting:**\\n\"\n                    f\"- Use `sort` parameter to sort results by one or more fields\\n\"\n                    f\"- Format: `field1,-field2` (comma-separated, `-` prefix for descending)\\n\"\n                    f\"- Examples: `name` (ascending), `-age` (descending), `name,-age` (mixed)\\n\\n\"\n                    f\"**Response Format:**\\n\"\n                    f\"- Returns paginated response when using page/itemsPerPage\\n\"\n                    f\"- Returns simple list response when using offset/limit\"\n                ),\n            )\n\n        if (\"update\" in included_methods) and (\"update\" not in deleted_methods):\n            self.router.add_api_route(\n                self._get_endpoint_path(operation=\"update\"),\n                self._update_item(),\n                methods=[\"PATCH\"],\n                include_in_schema=self.include_in_schema,\n                tags=self.tags,\n                dependencies=inject_dependencies(update_deps),\n                description=f\"Update an existing {self.model.__name__} row in the database by its primary keys: {self.primary_key_names}.\",\n            )\n\n        if (\"delete\" in included_methods) and (\"delete\" not in deleted_methods):\n            path = self._get_endpoint_path(operation=\"delete\")\n            self.router.add_api_route(\n                path,\n                self._delete_item(),\n                methods=[\"DELETE\"],\n                include_in_schema=self.include_in_schema,\n                tags=self.tags,\n                dependencies=inject_dependencies(delete_deps),\n                description=f\"{delete_description} {self.model.__name__} row from the database by its primary keys: {self.primary_key_names}.\",\n            )\n\n        if (\n            (\"db_delete\" in included_methods)\n            and (\"db_delete\" not in deleted_methods)\n            and self.delete_schema\n        ):\n            self.router.add_api_route(\n                self._get_endpoint_path(operation=\"db_delete\"),\n                self._db_delete(),\n                methods=[\"DELETE\"],\n                include_in_schema=self.include_in_schema,\n                tags=self.tags,\n                dependencies=inject_dependencies(db_delete_deps),\n                description=f\"Permanently delete a {self.model.__name__} row from the database by its primary keys: {self.primary_key_names}.\",\n            )\n\n    def add_custom_route(\n        self,\n        endpoint: Callable,\n        methods: Optional[Union[set[str], list[str]]],\n        path: Optional[str] = None,\n        dependencies: Optional[Sequence[Callable]] = None,\n        include_in_schema: bool = True,\n        tags: Optional[list[Union[str, Enum]]] = None,\n        summary: Optional[str] = None,\n        description: Optional[str] = None,\n        response_description: str = \"Successful Response\",\n    ) -&gt; None:\n        \"\"\"\n        Adds a custom route to the FastAPI router.\n\n        Args:\n            endpoint: The endpoint function to execute when the route is called.\n            methods: A list of HTTP methods for the route (e.g., `['GET', 'POST']`).\n            path: URL path for the custom route.\n            dependencies: A list of functions to be injected as dependencies for the route.\n            include_in_schema: Whether to include this route in the OpenAPI schema.\n            tags: Tags for grouping and categorizing the route in documentation.\n            summary: A short summary of the route, for documentation.\n            description: A detailed description of the route, for documentation.\n            response_description: A description of the response, for documentation.\n\n        Example:\n            ```python\n            async def custom_endpoint(foo: int, bar: str):\n                # custom logic here\n                return {\"foo\": foo, \"bar\": bar}\n\n            endpoint_creator.add_custom_route(\n                endpoint=custom_endpoint,\n                methods=[\"GET\"],\n                path=\"/custom\",\n                tags=[\"custom\"],\n                summary=\"Custom Endpoint\",\n                description=\"This is a custom endpoint.\",\n            )\n            ```\n        \"\"\"\n        path = path or self.path\n        full_path = f\"{self.path}{path}\"\n        self.router.add_api_route(\n            path=full_path,\n            endpoint=endpoint,\n            methods=methods,\n            dependencies=inject_dependencies(dependencies) or [],\n            include_in_schema=include_in_schema,\n            tags=tags or self.tags,\n            summary=summary,\n            description=description,\n            response_description=response_description,\n        )\n</code></pre>"},{"location":"api/endpoint_creator/#fastcrud.EndpointCreator.add_custom_route","title":"<code>add_custom_route(endpoint, methods, path=None, dependencies=None, include_in_schema=True, tags=None, summary=None, description=None, response_description='Successful Response')</code>","text":"<p>Adds a custom route to the FastAPI router.</p> <p>Parameters:</p> Name Type Description Default <code>endpoint</code> <code>Callable</code> <p>The endpoint function to execute when the route is called.</p> required <code>methods</code> <code>Optional[Union[set[str], list[str]]]</code> <p>A list of HTTP methods for the route (e.g., <code>['GET', 'POST']</code>).</p> required <code>path</code> <code>Optional[str]</code> <p>URL path for the custom route.</p> <code>None</code> <code>dependencies</code> <code>Optional[Sequence[Callable]]</code> <p>A list of functions to be injected as dependencies for the route.</p> <code>None</code> <code>include_in_schema</code> <code>bool</code> <p>Whether to include this route in the OpenAPI schema.</p> <code>True</code> <code>tags</code> <code>Optional[list[Union[str, Enum]]]</code> <p>Tags for grouping and categorizing the route in documentation.</p> <code>None</code> <code>summary</code> <code>Optional[str]</code> <p>A short summary of the route, for documentation.</p> <code>None</code> <code>description</code> <code>Optional[str]</code> <p>A detailed description of the route, for documentation.</p> <code>None</code> <code>response_description</code> <code>str</code> <p>A description of the response, for documentation.</p> <code>'Successful Response'</code> Example <pre><code>async def custom_endpoint(foo: int, bar: str):\n    # custom logic here\n    return {\"foo\": foo, \"bar\": bar}\n\nendpoint_creator.add_custom_route(\n    endpoint=custom_endpoint,\n    methods=[\"GET\"],\n    path=\"/custom\",\n    tags=[\"custom\"],\n    summary=\"Custom Endpoint\",\n    description=\"This is a custom endpoint.\",\n)\n</code></pre> Source code in <code>fastcrud/endpoint/endpoint_creator.py</code> <pre><code>def add_custom_route(\n    self,\n    endpoint: Callable,\n    methods: Optional[Union[set[str], list[str]]],\n    path: Optional[str] = None,\n    dependencies: Optional[Sequence[Callable]] = None,\n    include_in_schema: bool = True,\n    tags: Optional[list[Union[str, Enum]]] = None,\n    summary: Optional[str] = None,\n    description: Optional[str] = None,\n    response_description: str = \"Successful Response\",\n) -&gt; None:\n    \"\"\"\n    Adds a custom route to the FastAPI router.\n\n    Args:\n        endpoint: The endpoint function to execute when the route is called.\n        methods: A list of HTTP methods for the route (e.g., `['GET', 'POST']`).\n        path: URL path for the custom route.\n        dependencies: A list of functions to be injected as dependencies for the route.\n        include_in_schema: Whether to include this route in the OpenAPI schema.\n        tags: Tags for grouping and categorizing the route in documentation.\n        summary: A short summary of the route, for documentation.\n        description: A detailed description of the route, for documentation.\n        response_description: A description of the response, for documentation.\n\n    Example:\n        ```python\n        async def custom_endpoint(foo: int, bar: str):\n            # custom logic here\n            return {\"foo\": foo, \"bar\": bar}\n\n        endpoint_creator.add_custom_route(\n            endpoint=custom_endpoint,\n            methods=[\"GET\"],\n            path=\"/custom\",\n            tags=[\"custom\"],\n            summary=\"Custom Endpoint\",\n            description=\"This is a custom endpoint.\",\n        )\n        ```\n    \"\"\"\n    path = path or self.path\n    full_path = f\"{self.path}{path}\"\n    self.router.add_api_route(\n        path=full_path,\n        endpoint=endpoint,\n        methods=methods,\n        dependencies=inject_dependencies(dependencies) or [],\n        include_in_schema=include_in_schema,\n        tags=tags or self.tags,\n        summary=summary,\n        description=description,\n        response_description=response_description,\n    )\n</code></pre>"},{"location":"api/endpoint_creator/#fastcrud.EndpointCreator.add_routes_to_router","title":"<code>add_routes_to_router(create_deps=[], read_deps=[], read_multi_deps=[], update_deps=[], delete_deps=[], db_delete_deps=[], included_methods=None, deleted_methods=None)</code>","text":"<p>Adds CRUD operation routes to the FastAPI router with specified dependencies for each type of operation.</p> <p>This method registers routes for create, read, update, and delete operations with the FastAPI router, allowing for custom dependency injection for each type of operation.</p> <p>Parameters:</p> Name Type Description Default <code>create_deps</code> <code>Sequence[Callable]</code> <p>List of functions to be injected as dependencies for the create endpoint.</p> <code>[]</code> <code>read_deps</code> <code>Sequence[Callable]</code> <p>List of functions to be injected as dependencies for the read endpoint.</p> <code>[]</code> <code>read_multi_deps</code> <code>Sequence[Callable]</code> <p>List of functions to be injected as dependencies for the read multiple items endpoint.</p> <code>[]</code> <code>update_deps</code> <code>Sequence[Callable]</code> <p>List of functions to be injected as dependencies for the update endpoint.</p> <code>[]</code> <code>delete_deps</code> <code>Sequence[Callable]</code> <p>List of functions to be injected as dependencies for the delete endpoint.</p> <code>[]</code> <code>db_delete_deps</code> <code>Sequence[Callable]</code> <p>List of functions to be injected as dependencies for the hard delete endpoint.</p> <code>[]</code> <code>included_methods</code> <code>Optional[Sequence[str]]</code> <p>Optional list of methods to include. Defaults to all CRUD methods.</p> <code>None</code> <code>deleted_methods</code> <code>Optional[Sequence[str]]</code> <p>Optional list of methods to exclude. Defaults to <code>None</code>.</p> <code>None</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If both <code>included_methods</code> and <code>deleted_methods</code> are provided.</p> <p>Examples:</p> <p>Selective Endpoint Creation:</p> <pre><code># Only create 'create' and 'read' endpoints\nendpoint_creator.add_routes_to_router(\n    included_methods=[\"create\", \"read\"],\n)\n</code></pre> <p>Excluding Specific Endpoints:</p> <pre><code># Create all endpoints except 'delete' and 'db_delete'\nendpoint_creator.add_routes_to_router(\n    deleted_methods=[\"delete\", \"db_delete\"],\n)\n</code></pre> <p>With Custom Dependencies and Selective Endpoints:</p> <pre><code>def get_current_user(...):\n    ...\n\n# Create only 'read' and 'update' endpoints with custom dependencies\nendpoint_creator.add_routes_to_router(\n    read_deps=[get_current_user],\n    update_deps=[get_current_user],\n    included_methods=[\"read\", \"update\"],\n)\n</code></pre> Note <p>This method should be called to register the endpoints with the FastAPI application. If <code>delete_schema</code> is provided on class instantiation, a hard delete endpoint is also registered. This method assumes <code>id</code> is the primary key for path parameters.</p> Source code in <code>fastcrud/endpoint/endpoint_creator.py</code> <pre><code>def add_routes_to_router(\n    self,\n    create_deps: Sequence[Callable] = [],\n    read_deps: Sequence[Callable] = [],\n    read_multi_deps: Sequence[Callable] = [],\n    update_deps: Sequence[Callable] = [],\n    delete_deps: Sequence[Callable] = [],\n    db_delete_deps: Sequence[Callable] = [],\n    included_methods: Optional[Sequence[str]] = None,\n    deleted_methods: Optional[Sequence[str]] = None,\n):\n    \"\"\"\n    Adds CRUD operation routes to the FastAPI router with specified dependencies for each type of operation.\n\n    This method registers routes for create, read, update, and delete operations with the FastAPI router,\n    allowing for custom dependency injection for each type of operation.\n\n    Args:\n        create_deps: List of functions to be injected as dependencies for the create endpoint.\n        read_deps: List of functions to be injected as dependencies for the read endpoint.\n        read_multi_deps: List of functions to be injected as dependencies for the read multiple items endpoint.\n        update_deps: List of functions to be injected as dependencies for the update endpoint.\n        delete_deps: List of functions to be injected as dependencies for the delete endpoint.\n        db_delete_deps: List of functions to be injected as dependencies for the hard delete endpoint.\n        included_methods: Optional list of methods to include. Defaults to all CRUD methods.\n        deleted_methods: Optional list of methods to exclude. Defaults to `None`.\n\n    Raises:\n        ValueError: If both `included_methods` and `deleted_methods` are provided.\n\n    Examples:\n        Selective Endpoint Creation:\n\n        ```python\n        # Only create 'create' and 'read' endpoints\n        endpoint_creator.add_routes_to_router(\n            included_methods=[\"create\", \"read\"],\n        )\n        ```\n\n        Excluding Specific Endpoints:\n\n        ```python\n        # Create all endpoints except 'delete' and 'db_delete'\n        endpoint_creator.add_routes_to_router(\n            deleted_methods=[\"delete\", \"db_delete\"],\n        )\n        ```\n\n        With Custom Dependencies and Selective Endpoints:\n\n        ```python\n        def get_current_user(...):\n            ...\n\n        # Create only 'read' and 'update' endpoints with custom dependencies\n        endpoint_creator.add_routes_to_router(\n            read_deps=[get_current_user],\n            update_deps=[get_current_user],\n            included_methods=[\"read\", \"update\"],\n        )\n        ```\n\n    Note:\n        This method should be called to register the endpoints with the FastAPI application.\n        If `delete_schema` is provided on class instantiation, a hard delete endpoint is also registered.\n        This method assumes `id` is the primary key for path parameters.\n    \"\"\"\n    if (included_methods is not None) and (deleted_methods is not None):\n        raise ValueError(\n            \"Cannot use both 'included_methods' and 'deleted_methods' simultaneously.\"\n        )\n\n    if included_methods is None:\n        included_methods = [\n            \"create\",\n            \"read\",\n            \"read_multi\",\n            \"update\",\n            \"delete\",\n            \"db_delete\",\n        ]\n    else:\n        try:\n            included_methods = CRUDMethods(\n                valid_methods=included_methods\n            ).valid_methods\n        except ValidationError as e:\n            raise ValueError(f\"Invalid CRUD methods in included_methods: {e}\")\n\n    if deleted_methods is None:\n        deleted_methods = []\n    else:\n        try:\n            deleted_methods = CRUDMethods(\n                valid_methods=deleted_methods\n            ).valid_methods\n        except ValidationError as e:\n            raise ValueError(f\"Invalid CRUD methods in deleted_methods: {e}\")\n\n    delete_description = \"Delete a\"\n    if self.delete_schema:\n        delete_description = \"Soft delete a\"\n\n    if (\"create\" in included_methods) and (\"create\" not in deleted_methods):\n        self.router.add_api_route(\n            self._get_endpoint_path(operation=\"create\"),\n            self._create_item(),\n            methods=[\"POST\"],\n            include_in_schema=self.include_in_schema,\n            tags=self.tags,\n            dependencies=inject_dependencies(create_deps),\n            description=f\"Create a new {self.model.__name__} row in the database.\",\n        )\n\n    if (\"read\" in included_methods) and (\"read\" not in deleted_methods):\n        self.router.add_api_route(\n            self._get_endpoint_path(operation=\"read\"),\n            self._read_item(),\n            methods=[\"GET\"],\n            include_in_schema=self.include_in_schema,\n            tags=self.tags,\n            dependencies=inject_dependencies(read_deps),\n            response_model=self.select_schema if self.select_schema else None,\n            description=f\"Read a single {self.model.__name__} row from the database by its primary keys: {self.primary_key_names}.\",\n        )\n\n    if (\"read_multi\" in included_methods) and (\"read_multi\" not in deleted_methods):\n        if self.select_schema is not None:\n            response_model: Optional[\n                Type[Union[PaginatedListResponse[Any], ListResponse[Any]]]\n            ] = Union[\n                self.paginated_response_model,  # type: ignore\n                self.list_response_model,  # type: ignore\n            ]\n        else:\n            response_model = None\n\n        self.router.add_api_route(\n            self._get_endpoint_path(operation=\"read_multi\"),\n            self._read_items(),\n            methods=[\"GET\"],\n            include_in_schema=self.include_in_schema,\n            tags=self.tags,\n            dependencies=inject_dependencies(read_multi_deps),\n            response_model=response_model,\n            description=(\n                f\"Read multiple {self.model.__name__} rows from the database.\\n\\n\"\n                f\"**Pagination Options:**\\n\"\n                f\"- Use `page` &amp; `itemsPerPage` for paginated results\\n\"\n                f\"- Use `offset` &amp; `limit` for specific ranges\\n\\n\"\n                f\"**Sorting:**\\n\"\n                f\"- Use `sort` parameter to sort results by one or more fields\\n\"\n                f\"- Format: `field1,-field2` (comma-separated, `-` prefix for descending)\\n\"\n                f\"- Examples: `name` (ascending), `-age` (descending), `name,-age` (mixed)\\n\\n\"\n                f\"**Response Format:**\\n\"\n                f\"- Returns paginated response when using page/itemsPerPage\\n\"\n                f\"- Returns simple list response when using offset/limit\"\n            ),\n        )\n\n    if (\"update\" in included_methods) and (\"update\" not in deleted_methods):\n        self.router.add_api_route(\n            self._get_endpoint_path(operation=\"update\"),\n            self._update_item(),\n            methods=[\"PATCH\"],\n            include_in_schema=self.include_in_schema,\n            tags=self.tags,\n            dependencies=inject_dependencies(update_deps),\n            description=f\"Update an existing {self.model.__name__} row in the database by its primary keys: {self.primary_key_names}.\",\n        )\n\n    if (\"delete\" in included_methods) and (\"delete\" not in deleted_methods):\n        path = self._get_endpoint_path(operation=\"delete\")\n        self.router.add_api_route(\n            path,\n            self._delete_item(),\n            methods=[\"DELETE\"],\n            include_in_schema=self.include_in_schema,\n            tags=self.tags,\n            dependencies=inject_dependencies(delete_deps),\n            description=f\"{delete_description} {self.model.__name__} row from the database by its primary keys: {self.primary_key_names}.\",\n        )\n\n    if (\n        (\"db_delete\" in included_methods)\n        and (\"db_delete\" not in deleted_methods)\n        and self.delete_schema\n    ):\n        self.router.add_api_route(\n            self._get_endpoint_path(operation=\"db_delete\"),\n            self._db_delete(),\n            methods=[\"DELETE\"],\n            include_in_schema=self.include_in_schema,\n            tags=self.tags,\n            dependencies=inject_dependencies(db_delete_deps),\n            description=f\"Permanently delete a {self.model.__name__} row from the database by its primary keys: {self.primary_key_names}.\",\n        )\n</code></pre>"},{"location":"api/fastcrud/","title":"FastCRUD API Reference","text":"<p><code>FastCRUD</code> is a base class for CRUD operations on a model, utilizing Pydantic schemas for data validation and serialization.</p>"},{"location":"api/fastcrud/#class-definition","title":"Class Definition","text":"<p>               Bases: <code>Generic[ModelType, CreateSchemaType, UpdateSchemaType, UpdateSchemaInternalType, DeleteSchemaType, SelectSchemaType]</code></p> <p>Base class for CRUD operations on a model.</p> <p>This class provides a set of methods for create, read, update, and delete operations on a given SQLAlchemy model, utilizing Pydantic schemas for data validation and serialization.</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>type[ModelType]</code> <p>The SQLAlchemy model type.</p> required <code>is_deleted_column</code> <code>str</code> <p>Optional column name to use for indicating a soft delete. Defaults to <code>\"is_deleted\"</code>.</p> <code>'is_deleted'</code> <code>deleted_at_column</code> <code>str</code> <p>Optional column name to use for storing the timestamp of a soft delete. Defaults to <code>\"deleted_at\"</code>.</p> <code>'deleted_at'</code> <code>updated_at_column</code> <code>str</code> <p>Optional column name to use for storing the timestamp of an update. Defaults to <code>\"updated_at\"</code>.</p> <code>'updated_at'</code> <p>Methods:</p> Name Description <code>create</code> <p>Creates a new record in the database from the provided Pydantic schema.</p> <code>select</code> <p>Generates a SQL Alchemy <code>Select</code> statement with optional filtering and sorting.</p> <code>get</code> <p>Retrieves a single record based on filters. Supports advanced filtering through comparison operators like <code>__gt</code>, <code>__lt</code>, etc.</p> <code>exists</code> <p>Checks if a record exists based on the provided filters.</p> <code>count</code> <p>Counts the number of records matching the provided filters.</p> <code>get_multi</code> <p>Fetches multiple records with optional sorting, pagination, and model conversion.</p> <code>get_joined</code> <p>Performs a join operation with another model, supporting custom join conditions and selection of specific columns.</p> <code>get_multi_joined</code> <p>Fetches multiple records with a join on another model, offering pagination and sorting for the joined tables.</p> <code>get_multi_by_cursor</code> <p>Implements cursor-based pagination for fetching records, ideal for large datasets and infinite scrolling features.</p> <code>update</code> <p>Updates an existing record or multiple records based on specified filters.</p> <code>db_delete</code> <p>Hard deletes a record or multiple records from the database based on provided filters.</p> <code>delete</code> <p>Soft deletes a record if it has an <code>\"is_deleted\"</code> attribute (or other attribute as defined by <code>is_deleted_column</code>); otherwise, performs a hard delete.</p> <p>Examples:</p> Models and Schemas Used Below <code>customer/model.py</code> <pre><code>from sqlalchemy import Column, Integer, String\nfrom sqlalchemy.orm import DeclarativeBase\n\n\nclass Base(DeclarativeBase):\n    pass\n\n\nclass Customer(Base):\n    __tablename__ = \"customer\"\n    id = Column(Integer, primary_key=True)\n    name = Column(String)\n</code></pre> <code>product/model.py</code> <pre><code>from sqlalchemy import Column, Integer, Numeric, String\nfrom sqlalchemy.orm import DeclarativeBase\n\n\nclass Base(DeclarativeBase):\n    pass\n\n\nclass Product(Base):\n    __tablename__ = \"product\"\n    id = Column(Integer, primary_key=True)\n    name = Column(String)\n    price = Column(Numeric)\n</code></pre> <code>product/schemas.py</code> <pre><code>from pydantic import BaseModel\n\n\nclass ReadProductSchema(BaseModel):\n    id: int\n    name: str | None = None\n    price: float | None = None\n</code></pre> <code>order/model.py</code> <pre><code>from sqlalchemy import Column, ForeignKey, Integer\nfrom sqlalchemy.orm import DeclarativeBase\n\n\nclass Base(DeclarativeBase):\n    pass\n\n\nclass Order(Base):\n    __tablename__ = \"order\"\n    id = Column(Integer, primary_key=True)\n    customer_id = Column(Integer, ForeignKey(\"customer.id\"))\n    product_id = Column(Integer, ForeignKey(\"product.id\"))\n    quantity = Column(Integer)\n</code></pre> <code>order/schemas.py</code> <pre><code>from pydantic import BaseModel\n\n\nclass ReadOrderSchema(BaseModel):\n    id: int\n    customer_id: int | None = None\n    product_id: int | None = None\n    quantity: int | None = None\n</code></pre> <code>tier/model.py</code> <pre><code>from sqlalchemy import Column, Integer, String\nfrom sqlalchemy.orm import DeclarativeBase\n\n\nclass Base(DeclarativeBase):\n    pass\n\n\nclass Tier(Base):\n    __tablename__ = \"tier\"\n    id = Column(Integer, primary_key=True)\n    name = Column(String, unique=True)\n</code></pre> <code>tier/schemas.py</code> <pre><code>from pydantic import BaseModel\n\n\nclass ReadTierSchema(BaseModel):\n    id: int\n    name: str | None = None\n</code></pre> <code>department/model.py</code> <pre><code>from sqlalchemy import Column, Integer, String\nfrom sqlalchemy.orm import DeclarativeBase\n\n\nclass Base(DeclarativeBase):\n    pass\n\n\nclass Department(Base):\n    __tablename__ = \"department\"\n    id = Column(Integer, primary_key=True)\n    name = Column(String)\n</code></pre> <code>department/schemas.py</code> <pre><code>from pydantic import BaseModel\n\n\nclass ReadDepartmentSchema(BaseModel):\n    id: int\n    name: str | None = None\n</code></pre> <code>user/model.py</code> <pre><code>from sqlalchemy import (\n    Boolean,\n    Column,\n    DateTime,\n    ForeignKey,\n    Integer,\n    String,\n    func,\n)\nfrom sqlalchemy.orm import DeclarativeBase\n\n\nclass Base(DeclarativeBase):\n    pass\n\n\nclass User(Base):\n    __tablename__ = \"user\"\n    id = Column(Integer, primary_key=True)\n    name = Column(String)\n    username = Column(String)\n    email = Column(String)\n    age = Column(Integer)\n    role = Column(String)\n    tier_id = Column(Integer, ForeignKey(\"tier.id\"))\n    department_id = Column(Integer, ForeignKey(\"department.id\"))\n    manager_id = Column(Integer, ForeignKey(\"user.id\"))\n    is_active = Column(Boolean, default=True)\n    is_superuser = Column(Boolean, default=False)\n    registration_date = Column(DateTime, default=func.now())\n    archived = Column(Boolean, default=False)\n    archived_at = Column(DateTime)\n</code></pre> <code>user/schemas.py</code> <pre><code>import datetime\n\nfrom pydantic import BaseModel\n\n\nclass CreateUserSchema(BaseModel):\n    name: str | None = None\n    username: str | None = None\n    email: str | None = None\n    age: int | None = None\n    role: str | None = None\n    tier_id: int | None = None\n    department_id: int | None = None\n    manager_id: int | None = None\n    is_active: bool | None = None\n    is_superuser: bool | None = None\n\n\nclass ReadUserSchema(BaseModel):\n    id: int\n    name: str | None = None\n    username: str | None = None\n    email: str | None = None\n    age: int | None = None\n    role: str | None = None\n    tier_id: int | None = None\n    department_id: int | None = None\n    manager_id: int | None = None\n    is_active: bool\n    is_superuser: bool\n    registration_date: datetime.datetime\n    archived: bool\n    archived_at: datetime.datetime | None = None\n\n\nclass UpdateUserSchema(BaseModel):\n    name: str | None = None\n    username: str | None = None\n    email: str | None = None\n    age: int | None = None\n    role: str | None = None\n    tier_id: int | None = None\n    department_id: int | None = None\n    manager_id: int | None = None\n    is_active: bool | None = None\n    is_superuser: bool | None = None\n\n\nclass DeleteUserSchema(BaseModel):\n    pass\n</code></pre> <code>story/model.py</code> <pre><code>from sqlalchemy import Column, Integer, String\nfrom sqlalchemy.orm import DeclarativeBase\n\n\nclass Base(DeclarativeBase):\n    pass\n\n\nclass Story(Base):\n    __tablename__ = \"story\"\n    id = Column(Integer, primary_key=True)\n    name = Column(String)\n</code></pre> <code>story/schemas.py</code> <pre><code>from pydantic import BaseModel\n\n\nclass CreateStorySchema(BaseModel):\n    name: str | None = None\n\n\nclass ReadStorySchema(BaseModel):\n    id: int\n    name: str | None = None\n\n\nclass UpdateStorySchema(BaseModel):\n    name: str | None = None\n\n\nclass DeleteStorySchema(BaseModel):\n    pass\n</code></pre> <code>task/model.py</code> <pre><code>from sqlalchemy import Column, ForeignKey, Integer, String\nfrom sqlalchemy.orm import DeclarativeBase\n\n\nclass Base(DeclarativeBase):\n    pass\n\n\nclass Task(Base):\n    __tablename__ = \"task\"\n    id = Column(Integer, primary_key=True)\n    creator_id = Column(Integer, ForeignKey(\"user.id\"))\n    owner_id = Column(Integer, ForeignKey(\"user.id\"))\n    assigned_user_id = Column(Integer, ForeignKey(\"user.id\"))\n    story_id = Column(Integer, ForeignKey(\"story.id\"))\n    status = Column(String)\n    priority = Column(String)\n</code></pre> <code>task/schemas.py</code> <pre><code>from pydantic import BaseModel\n\n\nclass CreateTaskSchema(BaseModel):\n    creator_id: int | None = None\n    owner_id: int | None = None\n    assigned_user_id: int | None = None\n    story_id: int | None = None\n    status: str | None = None\n    priority: str | None = None\n\n\nclass ReadTaskSchema(BaseModel):\n    id: int\n    creator_id: int | None = None\n    owner_id: int | None = None\n    assigned_user_id: int | None = None\n    story_id: int | None = None\n    status: str | None = None\n    priority: str | None = None\n\n\nclass UpdateTaskSchema(BaseModel):\n    creator_id: int | None = None\n    owner_id: int | None = None\n    assigned_user_id: int | None = None\n    story_id: int | None = None\n    status: str | None = None\n    priority: str | None = None\n\n\nclass DeleteTaskSchema(BaseModel):\n    pass\n</code></pre> <code>profile/model.py</code> <pre><code>from sqlalchemy import Column, Integer, String\nfrom sqlalchemy.orm import DeclarativeBase\n\n\nclass Base(DeclarativeBase):\n    pass\n\n\nclass Profile(Base):\n    __tablename__ = \"profile\"\n    id = Column(Integer, primary_key=True)\n    bio = Column(String)\n</code></pre> <code>profile/schemas.py</code> <pre><code>from pydantic import BaseModel\n\n\nclass ReadProfileSchema(BaseModel):\n    id: int\n    bio: str | None = None\n</code></pre> <code>author/model.py</code> <pre><code>from sqlalchemy import Column, ForeignKey, Integer, String\nfrom sqlalchemy.orm import DeclarativeBase\n\n\nclass Base(DeclarativeBase):\n    pass\n\n\nclass Author(Base):\n    __tablename__ = \"author\"\n    id = Column(Integer, primary_key=True)\n    profile_id = Column(Integer, ForeignKey(\"profile.id\"))\n    name = Column(String)\n</code></pre> <code>author/schemas.py</code> <pre><code>from pydantic import BaseModel\n\n\nclass ReadAuthorSchema(BaseModel):\n    id: int\n    profile_id: int | None = None\n    name: str | None = None\n</code></pre> <code>article/model.py</code> <pre><code>from sqlalchemy import Column, ForeignKey, Integer, String\nfrom sqlalchemy.orm import DeclarativeBase\n\n\nclass Base(DeclarativeBase):\n    pass\n\n\nclass Article(Base):\n    __tablename__ = \"article\"\n    id = Column(Integer, primary_key=True)\n    author_id = Column(Integer, ForeignKey(\"author.id\"))\n    title = Column(String)\n    content = Column(String)\n</code></pre> <code>article/schemas.py</code> <pre><code>from pydantic import BaseModel\n\n\nclass ReadArticleSchema(BaseModel):\n    id: int\n    author_id: int | None = None\n    title: str | None = None\n    content: str | None = None\n</code></pre> <code>Project</code>, <code>Participant</code>, <code>ProjectsParticipantsAssociation</code> <pre><code># These models taken from tests/sqlalchemy/conftest.py\nclass Project(Base):\n    __tablename__ = \"projects\"\n    id = Column(Integer, primary_key=True)\n    name = Column(String(32), nullable=False)\n    description = Column(String(32))\n    participants = relationship(\n        \"Participant\",\n        secondary=\"projects_participants_association\",\n        back_populates=\"projects\",\n    )\n\n\nclass Participant(Base):\n    __tablename__ = \"participants\"\n    id = Column(Integer, primary_key=True)\n    name = Column(String(32), nullable=False)\n    role = Column(String(32))\n    projects = relationship(\n        \"Project\",\n        secondary=\"projects_participants_association\",\n        back_populates=\"participants\",\n    )\n\n\nclass ProjectsParticipantsAssociation(Base):\n    __tablename__ = \"projects_participants_association\"\n    project_id = Column(Integer, ForeignKey(\"projects.id\"), primary_key=True)\n    participant_id = Column(Integer, ForeignKey(\"participants.id\"), primary_key=True)\n</code></pre> <code>ReadProjectSchema</code> <pre><code>class ReadProjectSchema(BaseModel):\n    id: int\n    name: str\n    description: Optional[str] = None\n</code></pre>"},{"location":"api/fastcrud/#fastcrud.FastCRUD--example-1-basic-usage","title":"Example 1: Basic Usage","text":"<p>Create a FastCRUD instance for a <code>User</code> model and perform basic CRUD operations.</p> <pre><code># Assuming you have a User model (either SQLAlchemy or SQLModel)\n# pydantic schemas for creation, update and deletion and an async session `db`\nUserCRUD = FastCRUD[User, CreateUserSchema, UpdateUserSchema, None, DeleteUserSchema]\nuser_crud = UserCRUD(User)\n\n# If you don't care about typing, you can also just ignore the UserCRUD part\n# Straight up define user_crud with FastCRUD\nuser_crud = FastCRUD(User)\n\n# Create a new user\nnew_user = await user_crud.create(db, CreateUserSchema(name=\"Alice\"))\n# Read a user\nuser = await user_crud.get(db, id=new_user.id)\n# Update a user\nawait user_crud.update(db, UpdateUserSchema(email=\"alice@example.com\"), id=new_user.id)\n# Delete a user\nawait user_crud.delete(db, id=new_user.id)\n</code></pre>"},{"location":"api/fastcrud/#fastcrud.FastCRUD--example-2-advanced-filtering-and-pagination","title":"Example 2: Advanced Filtering and Pagination","text":"<p>Use advanced filtering, sorting, and pagination for fetching records.</p> <pre><code>product_crud = FastCRUD(Product)\nproducts = await product_crud.get_multi(\n    db,\n    offset=0,\n    limit=10,\n    sort_columns=['price'],\n    sort_orders=['asc'],\n)\n</code></pre>"},{"location":"api/fastcrud/#fastcrud.FastCRUD--example-3-join-operations-with-custom-schemas","title":"Example 3: Join Operations with Custom Schemas","text":"<p>Perform join operations between two models using custom schemas for selection.</p> <pre><code>order_crud = FastCRUD(Order)\norders = await order_crud.get_multi_joined(\n    db,\n    schema_to_select=ReadOrderSchema,\n    join_model=Product,\n    join_prefix=\"product_\",\n    join_schema_to_select=ReadProductSchema,\n    offset=0,\n    limit=5,\n)\n</code></pre>"},{"location":"api/fastcrud/#fastcrud.FastCRUD--example-4-cursor-pagination","title":"Example 4: Cursor Pagination","text":"<p>Implement cursor-based pagination for efficient data retrieval in large datasets.</p> <pre><code>class Comment(Base):\n    id = Column(Integer, primary_key=True)\n    user_id = Column(Integer, ForeignKey(\"user.id\"))\n    subject = Column(String)\n    body = Column(String)\n\ncomment_crud = FastCRUD(Comment)\n\nfirst_page = await comment_crud.get_multi_by_cursor(db, limit=10)\nnext_cursor = first_page['next_cursor']\nsecond_page = await comment_crud.get_multi_by_cursor(db, cursor=next_cursor, limit=10)\n</code></pre>"},{"location":"api/fastcrud/#fastcrud.FastCRUD--example-5-dynamic-filtering-and-counting","title":"Example 5: Dynamic Filtering and Counting","text":"<p>Dynamically filter records based on various criteria and count the results.</p> <pre><code>task_crud = FastCRUD(Task)\ncompleted_tasks = await task_crud.get_multi(\n    db,\n    status='completed',\n)\nhigh_priority_task_count = await task_crud.count(\n    db,\n    priority='high',\n)\n</code></pre>"},{"location":"api/fastcrud/#fastcrud.FastCRUD--example-6-using-custom-column-names-for-soft-delete","title":"Example 6: Using Custom Column Names for Soft Delete","text":"<p>If your model uses different column names for indicating a soft delete and its timestamp, you can specify these when creating the <code>FastCRUD</code> instance.</p> <pre><code>class User(Base):\n    __tablename__ = \"user\"\n    id = Column(Integer, primary_key=True)\n    name = Column(String)\n    ...\n    archived = Column(Boolean, default=False)\n    archived_at = Column(DateTime)\n\n\ncustom_user_crud = FastCRUD(\n    User,\n    is_deleted_column=\"archived\",\n    deleted_at_column=\"archived_at\",\n)\n# Now 'archived' and 'archived_at' will be used for soft delete operations.\n</code></pre> Source code in <code>fastcrud/crud/fast_crud.py</code> <pre><code>class FastCRUD(\n    Generic[\n        ModelType,\n        CreateSchemaType,\n        UpdateSchemaType,\n        UpdateSchemaInternalType,\n        DeleteSchemaType,\n        SelectSchemaType,\n    ]\n):\n    \"\"\"\n    Base class for CRUD operations on a model.\n\n    This class provides a set of methods for create, read, update, and delete operations on a given SQLAlchemy model,\n    utilizing Pydantic schemas for data validation and serialization.\n\n    Args:\n        model: The SQLAlchemy model type.\n        is_deleted_column: Optional column name to use for indicating a soft delete. Defaults to `\"is_deleted\"`.\n        deleted_at_column: Optional column name to use for storing the timestamp of a soft delete. Defaults to `\"deleted_at\"`.\n        updated_at_column: Optional column name to use for storing the timestamp of an update. Defaults to `\"updated_at\"`.\n\n    Methods:\n        create:\n            Creates a new record in the database from the provided Pydantic schema.\n\n        select:\n            Generates a SQL Alchemy `Select` statement with optional filtering and sorting.\n\n        get:\n            Retrieves a single record based on filters. Supports advanced filtering through comparison operators like `__gt`, `__lt`, etc.\n\n        exists:\n            Checks if a record exists based on the provided filters.\n\n        count:\n            Counts the number of records matching the provided filters.\n\n        get_multi:\n            Fetches multiple records with optional sorting, pagination, and model conversion.\n\n        get_joined:\n            Performs a join operation with another model, supporting custom join conditions and selection of specific columns.\n\n        get_multi_joined:\n            Fetches multiple records with a join on another model, offering pagination and sorting for the joined tables.\n\n        get_multi_by_cursor:\n            Implements cursor-based pagination for fetching records, ideal for large datasets and infinite scrolling features.\n\n        update:\n            Updates an existing record or multiple records based on specified filters.\n\n        db_delete:\n            Hard deletes a record or multiple records from the database based on provided filters.\n\n        delete:\n            Soft deletes a record if it has an `\"is_deleted\"` attribute (or other attribute as defined by `is_deleted_column`); otherwise, performs a hard delete.\n\n    Examples:\n        ??? example \"Models and Schemas Used Below\"\n\n            ??? example \"`customer/model.py`\"\n\n                ```python\n                --8&lt;--\n                fastcrud/examples/customer/model.py:imports\n                fastcrud/examples/customer/model.py:model\n                --8&lt;--\n                ```\n\n            ??? example \"`product/model.py`\"\n\n                ```python\n                --8&lt;--\n                fastcrud/examples/product/model.py:imports\n                fastcrud/examples/product/model.py:model\n                --8&lt;--\n                ```\n\n            ??? example \"`product/schemas.py`\"\n\n                ```python\n                --8&lt;--\n                fastcrud/examples/product/schemas.py:imports\n                fastcrud/examples/product/schemas.py:readschema\n                --8&lt;--\n                ```\n\n            ??? example \"`order/model.py`\"\n\n                ```python\n                --8&lt;--\n                fastcrud/examples/order/model.py:imports\n                fastcrud/examples/order/model.py:model\n                --8&lt;--\n                ```\n\n            ??? example \"`order/schemas.py`\"\n\n                ```python\n                --8&lt;--\n                fastcrud/examples/order/schemas.py:imports\n                fastcrud/examples/order/schemas.py:readschema\n                --8&lt;--\n                ```\n\n            ---\n\n            ??? example \"`tier/model.py`\"\n\n                ```python\n                --8&lt;--\n                fastcrud/examples/tier/model.py:imports\n                fastcrud/examples/tier/model.py:model\n                --8&lt;--\n                ```\n\n            ??? example \"`tier/schemas.py`\"\n\n                ```python\n                --8&lt;--\n                fastcrud/examples/tier/schemas.py:imports\n                fastcrud/examples/tier/schemas.py:readschema\n                --8&lt;--\n                ```\n\n            ??? example \"`department/model.py`\"\n\n                ```python\n                --8&lt;--\n                fastcrud/examples/department/model.py:imports\n                fastcrud/examples/department/model.py:model\n                --8&lt;--\n                ```\n\n            ??? example \"`department/schemas.py`\"\n\n                ```python\n                --8&lt;--\n                fastcrud/examples/department/schemas.py:imports\n                fastcrud/examples/department/schemas.py:readschema\n                --8&lt;--\n                ```\n\n            ??? example \"`user/model.py`\"\n\n                ```python\n                --8&lt;--\n                fastcrud/examples/user/model.py:imports\n                fastcrud/examples/user/model.py:model\n                --8&lt;--\n                ```\n\n            ??? example \"`user/schemas.py`\"\n\n                ```python\n                --8&lt;--\n                fastcrud/examples/user/schemas.py:imports\n                fastcrud/examples/user/schemas.py:createschema\n                fastcrud/examples/user/schemas.py:readschema\n                fastcrud/examples/user/schemas.py:updateschema\n                fastcrud/examples/user/schemas.py:deleteschema\n                --8&lt;--\n                ```\n\n            ??? example \"`story/model.py`\"\n\n                ```python\n                --8&lt;--\n                fastcrud/examples/story/model.py:imports\n                fastcrud/examples/story/model.py:model\n                --8&lt;--\n                ```\n\n            ??? example \"`story/schemas.py`\"\n\n                ```python\n                --8&lt;--\n                fastcrud/examples/story/schemas.py:imports\n                fastcrud/examples/story/schemas.py:createschema\n                fastcrud/examples/story/schemas.py:readschema\n                fastcrud/examples/story/schemas.py:updateschema\n                fastcrud/examples/story/schemas.py:deleteschema\n                --8&lt;--\n                ```\n\n            ??? example \"`task/model.py`\"\n\n                ```python\n                --8&lt;--\n                fastcrud/examples/task/model.py:imports\n                fastcrud/examples/task/model.py:model\n                --8&lt;--\n                ```\n\n            ??? example \"`task/schemas.py`\"\n\n                ```python\n                --8&lt;--\n                fastcrud/examples/task/schemas.py:imports\n                fastcrud/examples/task/schemas.py:createschema\n                fastcrud/examples/task/schemas.py:readschema\n                fastcrud/examples/task/schemas.py:updateschema\n                fastcrud/examples/task/schemas.py:deleteschema\n                --8&lt;--\n                ```\n\n            ---\n\n            ??? example \"`profile/model.py`\"\n\n                ```python\n                --8&lt;--\n                fastcrud/examples/profile/model.py:imports\n                fastcrud/examples/profile/model.py:model\n                --8&lt;--\n                ```\n\n            ??? example \"`profile/schemas.py`\"\n\n                ```python\n                --8&lt;--\n                fastcrud/examples/profile/schemas.py:imports\n                fastcrud/examples/profile/schemas.py:readschema\n                --8&lt;--\n                ```\n\n            ??? example \"`author/model.py`\"\n\n                ```python\n                --8&lt;--\n                fastcrud/examples/author/model.py:imports\n                fastcrud/examples/author/model.py:model\n                --8&lt;--\n                ```\n\n            ??? example \"`author/schemas.py`\"\n\n                ```python\n                --8&lt;--\n                fastcrud/examples/author/schemas.py:imports\n                fastcrud/examples/author/schemas.py:readschema\n                --8&lt;--\n                ```\n\n            ??? example \"`article/model.py`\"\n\n                ```python\n                --8&lt;--\n                fastcrud/examples/article/model.py:imports\n                fastcrud/examples/article/model.py:model\n                --8&lt;--\n                ```\n\n            ??? example \"`article/schemas.py`\"\n\n                ```python\n                --8&lt;--\n                fastcrud/examples/article/schemas.py:imports\n                fastcrud/examples/article/schemas.py:readschema\n                --8&lt;--\n                ```\n\n            ---\n\n            ??? example \"`Project`, `Participant`, `ProjectsParticipantsAssociation`\"\n\n                ```python\n                # These models taken from tests/sqlalchemy/conftest.py\n                --8&lt;--\n                tests/sqlalchemy/conftest.py:model_project\n                tests/sqlalchemy/conftest.py:model_participant\n                tests/sqlalchemy/conftest.py:model_proj_parts_assoc\n                --8&lt;--\n                ```\n\n            ??? example \"`ReadProjectSchema`\"\n\n                ```python\n                class ReadProjectSchema(BaseModel):\n                    id: int\n                    name: str\n                    description: Optional[str] = None\n                ```\n\n        Example 1: Basic Usage\n        ----------------------\n\n        Create a FastCRUD instance for a `User` model and perform basic CRUD operations.\n\n        ```python\n        # Assuming you have a User model (either SQLAlchemy or SQLModel)\n        # pydantic schemas for creation, update and deletion and an async session `db`\n        UserCRUD = FastCRUD[User, CreateUserSchema, UpdateUserSchema, None, DeleteUserSchema]\n        user_crud = UserCRUD(User)\n\n        # If you don't care about typing, you can also just ignore the UserCRUD part\n        # Straight up define user_crud with FastCRUD\n        user_crud = FastCRUD(User)\n\n        # Create a new user\n        new_user = await user_crud.create(db, CreateUserSchema(name=\"Alice\"))\n        # Read a user\n        user = await user_crud.get(db, id=new_user.id)\n        # Update a user\n        await user_crud.update(db, UpdateUserSchema(email=\"alice@example.com\"), id=new_user.id)\n        # Delete a user\n        await user_crud.delete(db, id=new_user.id)\n        ```\n\n        Example 2: Advanced Filtering and Pagination\n        --------------------------------------------\n\n        Use advanced filtering, sorting, and pagination for fetching records.\n\n        ```python\n        product_crud = FastCRUD(Product)\n        products = await product_crud.get_multi(\n            db,\n            offset=0,\n            limit=10,\n            sort_columns=['price'],\n            sort_orders=['asc'],\n        )\n        ```\n\n        Example 3: Join Operations with Custom Schemas\n        ----------------------------------------------\n\n        Perform join operations between two models using custom schemas for selection.\n\n        ```python\n        order_crud = FastCRUD(Order)\n        orders = await order_crud.get_multi_joined(\n            db,\n            schema_to_select=ReadOrderSchema,\n            join_model=Product,\n            join_prefix=\"product_\",\n            join_schema_to_select=ReadProductSchema,\n            offset=0,\n            limit=5,\n        )\n        ```\n\n        Example 4: Cursor Pagination\n        ----------------------------\n\n        Implement cursor-based pagination for efficient data retrieval in large datasets.\n\n        ```python\n        class Comment(Base):\n            id = Column(Integer, primary_key=True)\n            user_id = Column(Integer, ForeignKey(\"user.id\"))\n            subject = Column(String)\n            body = Column(String)\n\n        comment_crud = FastCRUD(Comment)\n\n        first_page = await comment_crud.get_multi_by_cursor(db, limit=10)\n        next_cursor = first_page['next_cursor']\n        second_page = await comment_crud.get_multi_by_cursor(db, cursor=next_cursor, limit=10)\n        ```\n\n        Example 5: Dynamic Filtering and Counting\n        -----------------------------------------\n        Dynamically filter records based on various criteria and count the results.\n\n        ```python\n        task_crud = FastCRUD(Task)\n        completed_tasks = await task_crud.get_multi(\n            db,\n            status='completed',\n        )\n        high_priority_task_count = await task_crud.count(\n            db,\n            priority='high',\n        )\n        ```\n\n        Example 6: Using Custom Column Names for Soft Delete\n        ----------------------------------------------------\n\n        If your model uses different column names for indicating a soft delete and its timestamp, you can specify these when creating the `FastCRUD` instance.\n\n        ```python\n        --8&lt;--\n        fastcrud/examples/user/model.py:model_common\n        --8&lt;--\n            ...\n        --8&lt;--\n        fastcrud/examples/user/model.py:model_archived\n        --8&lt;--\n\n\n        custom_user_crud = FastCRUD(\n            User,\n            is_deleted_column=\"archived\",\n            deleted_at_column=\"archived_at\",\n        )\n        # Now 'archived' and 'archived_at' will be used for soft delete operations.\n        ```\n    \"\"\"\n\n    def __init__(\n        self,\n        model: type[ModelType],\n        is_deleted_column: str = \"is_deleted\",\n        deleted_at_column: str = \"deleted_at\",\n        updated_at_column: str = \"updated_at\",\n        multi_response_key: str = \"data\",\n    ) -&gt; None:\n        self.model = model\n        self.model_col_names = [col.key for col in model.__table__.columns]\n        self.is_deleted_column = is_deleted_column\n        self.deleted_at_column = deleted_at_column\n        self.updated_at_column = updated_at_column\n        self.multi_response_key = multi_response_key\n        self._primary_keys = get_primary_key_columns(self.model)\n        self._filter_processor = FilterProcessor(self.model)\n        self._query_builder = SQLQueryBuilder(self.model)\n\n    @overload\n    async def create(\n        self,\n        db: AsyncSession,\n        object: CreateSchemaType,\n        *,\n        commit: bool = True,\n        schema_to_select: type[SelectSchemaType],\n        return_as_model: Literal[True],\n    ) -&gt; SelectSchemaType: ...\n\n    @overload\n    async def create(\n        self,\n        db: AsyncSession,\n        object: CreateSchemaType,\n        *,\n        commit: bool = True,\n        schema_to_select: None = None,\n        return_as_model: Literal[False] = False,\n    ) -&gt; Optional[dict[str, Any]]: ...\n\n    @overload\n    async def create(\n        self,\n        db: AsyncSession,\n        object: CreateSchemaType,\n        *,\n        commit: bool = True,\n        schema_to_select: Optional[type[SelectSchemaType]] = None,\n        return_as_model: bool = False,\n    ) -&gt; Union[ModelType, SelectSchemaType, dict[str, Any], None]: ...\n\n    async def create(\n        self,\n        db: AsyncSession,\n        object: CreateSchemaType,\n        commit: bool = True,\n        schema_to_select: Optional[type[SelectSchemaType]] = None,\n        return_as_model: bool = False,\n    ) -&gt; Union[ModelType, SelectSchemaType, dict, None]:\n        \"\"\"\n        Create a new record in the database.\n\n        Args:\n            db: The SQLAlchemy async session.\n            object: The Pydantic schema containing the data to be saved.\n            commit: If `True`, commits the transaction immediately. Default is `True`.\n            schema_to_select: Pydantic schema for selecting specific columns.\n            return_as_model: If `True`, returns data as an instance of `schema_to_select`.\n\n        Returns:\n            The created database object, or a Pydantic model if `schema_to_select` is provided:\n\n            - When `return_as_model=True` and `schema_to_select` is provided: `SelectSchemaType`\n            - When `return_as_model=False` and `schema_to_select` is provided: `Dict[str, Any]`\n            - When `schema_to_select` is not provided: `ModelType` (the raw SQLAlchemy model)\n        \"\"\"\n        if return_as_model and not schema_to_select:\n            raise ValueError(\n                \"schema_to_select must be provided when return_as_model is True.\"\n            )\n\n        object_dict = object.model_dump()\n        db_object: ModelType = self.model(**object_dict)\n        db.add(db_object)\n\n        if commit:\n            await db.commit()\n            await db.refresh(db_object)\n        else:\n            await db.flush()\n            await db.refresh(db_object)\n\n        if schema_to_select:\n            if not self._primary_keys:\n                raise ValueError(\"Cannot fetch created record without a primary key.\")\n\n            pks = {pk.name: getattr(db_object, pk.name) for pk in self._primary_keys}\n            return await self.get(\n                db=db,\n                schema_to_select=schema_to_select,\n                return_as_model=return_as_model,\n                **pks,\n            )\n\n        return db_object\n\n    async def select(\n        self,\n        schema_to_select: Optional[type[SelectSchemaType]] = None,\n        sort_columns: Optional[Union[str, list[str]]] = None,\n        sort_orders: Optional[Union[str, list[str]]] = None,\n        **kwargs: Any,\n    ) -&gt; Select:\n        \"\"\"\n        Constructs a SQL Alchemy `Select` statement with optional column selection, filtering, and sorting.\n\n        This method allows for advanced filtering through comparison operators, enabling queries to be refined beyond simple equality checks.\n\n        For filtering details see [the Advanced Filters documentation](../advanced/crud.md/#advanced-filters)\n\n        Args:\n            schema_to_select: Pydantic schema to determine which columns to include in the selection. If not provided, selects all columns of the model.\n            sort_columns: A single column name or list of column names to sort the query results by. Must be used in conjunction with `sort_orders`.\n            sort_orders: A single sort order (`\"asc\"` or `\"desc\"`) or a list of sort orders, corresponding to each column in `sort_columns`. If not specified, defaults to ascending order for all `sort_columns`.\n            **kwargs: Filters to apply to the query, including advanced comparison operators for more detailed querying.\n\n        Returns:\n            An SQL Alchemy `Select` statement object that can be executed or further modified.\n\n        Examples:\n            Selecting specific columns with filtering and sorting:\n\n            ```python\n            stmt = await user_crud.select(\n                schema_to_select=ReadUserSchema,\n                sort_columns=['age', 'name'],\n                sort_orders=['asc', 'desc'],\n                age__gt=18,\n            )\n            ```\n\n            Creating a statement to select all users without any filters:\n\n            ```python\n            stmt = await user_crud.select()\n            ```\n\n            Selecting users with a specific `role`, ordered by `name`:\n\n            ```python\n            stmt = await user_crud.select(\n                schema_to_select=UserReadSchema,\n                sort_columns='name',\n                role='admin',\n            )\n            ```\n\n        Note:\n            This method does not execute the generated SQL statement.\n            Use `db.execute(stmt)` to run the query and fetch results.\n        \"\"\"\n        to_select = extract_matching_columns_from_schema(\n            model=self.model, schema=schema_to_select\n        )\n        filters = self._filter_processor.parse_filters(**kwargs)\n        stmt = select(*to_select).filter(*filters)\n\n        if sort_columns:\n            stmt = self._query_builder.apply_sorting(stmt, sort_columns, sort_orders)\n        return stmt\n\n    @overload\n    async def get(\n        self,\n        db: AsyncSession,\n        *,\n        schema_to_select: type[SelectSchemaType],\n        return_as_model: Literal[True],\n        one_or_none: bool = False,\n        **kwargs: Any,\n    ) -&gt; Optional[SelectSchemaType]: ...\n\n    @overload\n    async def get(\n        self,\n        db: AsyncSession,\n        *,\n        schema_to_select: None = None,\n        return_as_model: Literal[False] = False,\n        one_or_none: bool = False,\n        **kwargs: Any,\n    ) -&gt; Optional[dict[str, Any]]: ...\n\n    @overload\n    async def get(\n        self,\n        db: AsyncSession,\n        *,\n        schema_to_select: Optional[type[SelectSchemaType]] = None,\n        return_as_model: bool = False,\n        one_or_none: bool = False,\n        **kwargs: Any,\n    ) -&gt; Optional[Union[dict[str, Any], SelectSchemaType]]: ...\n\n    async def get(\n        self,\n        db: AsyncSession,\n        schema_to_select: Optional[type[SelectSchemaType]] = None,\n        return_as_model: bool = False,\n        one_or_none: bool = False,\n        **kwargs: Any,\n    ) -&gt; Optional[Union[dict[str, Any], SelectSchemaType]]:\n        \"\"\"\n        Fetches a single record based on specified filters.\n\n        This method allows for advanced filtering through comparison operators, enabling queries to be refined beyond simple equality checks.\n\n        For filtering details see [the Advanced Filters documentation](../advanced/crud.md/#advanced-filters)\n\n        Args:\n            db: The database session to use for the operation.\n            schema_to_select: Optional Pydantic schema for selecting specific columns.\n            return_as_model: If `True`, converts the fetched data to Pydantic models based on `schema_to_select`. Defaults to `False`.\n            one_or_none: Flag to get strictly one or no result. Multiple results are not allowed.\n            **kwargs: Filters to apply to the query, using field names for direct matches or appending comparison operators for advanced queries.\n\n        Raises:\n            ValueError: If `return_as_model` is `True` but `schema_to_select` is not provided.\n\n        Returns:\n            A dictionary or a Pydantic model instance of the fetched database row, or `None` if no match is found:\n\n            - When `return_as_model=True` and `schema_to_select` is provided: `Optional[SelectSchemaType]`\n            - When `return_as_model=False`: `Optional[Dict[str, Any]]`\n\n        Examples:\n            Fetch a user by ID:\n\n            ```python\n            user = await user_crud.get(db, id=1)\n            ```\n\n            Fetch a user with an age greater than 30:\n\n            ```python\n            user = await user_crud.get(db, age__gt=30)\n            ```\n\n            Fetch a user with a registration date before Jan 1, 2020:\n\n            ```python\n            user = await user_crud.get(db, registration_date__lt=datetime(2020, 1, 1))\n            ```\n\n            Fetch a user not equal to a specific username:\n\n            ```python\n            user = await user_crud.get(db, username__ne='admin')\n            ```\n        \"\"\"\n        stmt = await self.select(schema_to_select=schema_to_select, **kwargs)\n\n        db_row = await db.execute(stmt)\n        result: Optional[Row] = db_row.one_or_none() if one_or_none else db_row.first()\n        if result is None:\n            return None\n        out: dict = dict(result._mapping)\n        if not return_as_model:\n            return out\n        if not schema_to_select:\n            raise ValueError(\n                \"schema_to_select must be provided when return_as_model is True.\"\n            )\n        return schema_to_select(**out)\n\n    def _get_pk_dict(self, instance):\n        return {pk.name: getattr(instance, pk.name) for pk in self._primary_keys}\n\n    @overload\n    async def upsert(\n        self,\n        db: AsyncSession,\n        instance: Union[UpdateSchemaType, CreateSchemaType],\n        *,\n        schema_to_select: type[SelectSchemaType],\n        return_as_model: Literal[True],\n    ) -&gt; Optional[SelectSchemaType]: ...\n\n    @overload\n    async def upsert(\n        self,\n        db: AsyncSession,\n        instance: Union[UpdateSchemaType, CreateSchemaType],\n        *,\n        schema_to_select: None = None,\n        return_as_model: Literal[False] = False,\n    ) -&gt; Optional[dict[str, Any]]: ...\n\n    @overload\n    async def upsert(\n        self,\n        db: AsyncSession,\n        instance: Union[UpdateSchemaType, CreateSchemaType],\n        *,\n        schema_to_select: Optional[type[SelectSchemaType]] = None,\n        return_as_model: bool = False,\n    ) -&gt; Union[SelectSchemaType, dict[str, Any], None]: ...\n\n    async def upsert(\n        self,\n        db: AsyncSession,\n        instance: Union[UpdateSchemaType, CreateSchemaType],\n        schema_to_select: Optional[type[SelectSchemaType]] = None,\n        return_as_model: bool = False,\n    ) -&gt; Union[SelectSchemaType, dict[str, Any], None]:\n        \"\"\"Update the instance or create it if it doesn't exists.\n\n        Note: This method will perform two transactions to the database (get and create or update).\n\n        Args:\n            db: The database session to use for the operation.\n            instance: A Pydantic schema representing the instance.\n            schema_to_select: Optional Pydantic schema for selecting specific columns. Defaults to `None`.\n            return_as_model: If `True`, converts the fetched data to Pydantic models based on `schema_to_select`. Defaults to `False`.\n\n        Returns:\n            The created or updated instance:\n\n            - When `return_as_model=True` and `schema_to_select` is provided: `SelectSchemaType`\n            - When `return_as_model=False`: `Dict[str, Any]`\n        \"\"\"\n        _pks = self._get_pk_dict(instance)\n        schema_to_select = schema_to_select or type(instance)  # type: ignore\n        db_instance = await self.get(\n            db,\n            schema_to_select=schema_to_select,  # type: ignore\n            return_as_model=return_as_model,\n            **_pks,\n        )\n        if db_instance is None:\n            db_instance = await self.create(db, instance)  # type: ignore\n            db_instance = schema_to_select.model_validate(  # type: ignore\n                db_instance, from_attributes=True\n            )\n        else:\n            await self.update(db, instance)  # type: ignore\n            db_instance = await self.get(\n                db,\n                schema_to_select=schema_to_select,  # type: ignore\n                return_as_model=return_as_model,\n                **_pks,\n            )\n\n        return db_instance\n\n    @overload\n    async def upsert_multi(\n        self,\n        db: AsyncSession,\n        instances: list[Union[UpdateSchemaType, CreateSchemaType]],\n        *,\n        commit: bool = False,\n        return_columns: Optional[list[str]] = None,\n        schema_to_select: type[SelectSchemaType],\n        return_as_model: Literal[True],\n        update_override: Optional[dict[str, Any]] = None,\n        **kwargs: Any,\n    ) -&gt; Optional[UpsertMultiResponseModel[SelectSchemaType]]: ...\n\n    @overload\n    async def upsert_multi(\n        self,\n        db: AsyncSession,\n        instances: list[Union[UpdateSchemaType, CreateSchemaType]],\n        *,\n        commit: bool = False,\n        return_columns: Optional[list[str]] = None,\n        schema_to_select: None = None,\n        return_as_model: Literal[False] = False,\n        update_override: Optional[dict[str, Any]] = None,\n        **kwargs: Any,\n    ) -&gt; Optional[UpsertMultiResponseDict]: ...\n\n    @overload\n    async def upsert_multi(\n        self,\n        db: AsyncSession,\n        instances: list[Union[UpdateSchemaType, CreateSchemaType]],\n        *,\n        commit: bool = False,\n        return_columns: Optional[list[str]] = None,\n        schema_to_select: Optional[type[SelectSchemaType]] = None,\n        return_as_model: bool = False,\n        update_override: Optional[dict[str, Any]] = None,\n        **kwargs: Any,\n    ) -&gt; Optional[\n        Union[UpsertMultiResponseDict, UpsertMultiResponseModel[SelectSchemaType]]\n    ]: ...\n\n    async def upsert_multi(\n        self,\n        db: AsyncSession,\n        instances: list[Union[UpdateSchemaType, CreateSchemaType]],\n        commit: bool = False,\n        return_columns: Optional[list[str]] = None,\n        schema_to_select: Optional[type[SelectSchemaType]] = None,\n        return_as_model: bool = False,\n        update_override: Optional[dict[str, Any]] = None,\n        **kwargs: Any,\n    ) -&gt; Optional[\n        Union[UpsertMultiResponseDict, UpsertMultiResponseModel[SelectSchemaType]]\n    ]:\n        \"\"\"\n        Upsert multiple records in the database. The underlying implementation varies based on the database dialect.\n\n        Args:\n            db: The database session to use for the operation.\n            instances: A list of Pydantic schemas representing the instances to upsert.\n            commit: If True, commits the transaction immediately. Default is False.\n            return_columns: Optional list of column names to return after the upsert operation.\n            schema_to_select: Optional Pydantic schema for selecting specific columns. Required if return_as_model is True.\n            return_as_model: If True, returns data as instances of the specified Pydantic model.\n            update_override: Optional dictionary to override the update values for the upsert operation.\n            **kwargs: Filters to identify the record(s) to update on conflict, supporting advanced comparison operators for refined querying.\n\n        Returns:\n            The upserted records as a dictionary containing the operation results:\n\n            - When `return_as_model=True` and `schema_to_select` is provided: `UpsertMultiResponseModel[SelectSchemaType]`\n              (`Dict[str, List[SelectSchemaType]]`)\n            - When `return_as_model=False`: `UpsertMultiResponseDict`\n              (`Dict[str, List[Dict[str, Any]]]`)\n\n            The dictionary contains keys like \"updated\" and \"created\" with lists of corresponding records.\n\n        Raises:\n            ValueError: If the MySQL dialect is used with filters, return_columns, schema_to_select, or return_as_model.\n            NotImplementedError: If the database dialect is not supported for upsert multi.\n        \"\"\"\n        if update_override is None:\n            update_override = {}\n        filters = self._filter_processor.parse_filters(**kwargs)\n\n        if db.bind.dialect.name == \"postgresql\":\n            statement, params = await upsert_multi_postgresql(\n                self.model,\n                [pk.name for pk in self._primary_keys],\n                instances,\n                filters,\n                update_override,\n            )\n        elif db.bind.dialect.name == \"sqlite\":\n            statement, params = await upsert_multi_sqlite(\n                self.model,\n                [pk.name for pk in self._primary_keys],\n                instances,\n                filters,\n                update_override,\n            )\n        elif db.bind.dialect.name in [\"mysql\", \"mariadb\"]:\n            if filters:\n                raise ValueError(\n                    \"MySQL does not support filtering on insert operations.\"\n                )\n            if return_columns or schema_to_select or return_as_model:\n                raise ValueError(\n                    \"MySQL does not support the returning clause for insert operations.\"\n                )\n            statement, params = await upsert_multi_mysql(\n                self.model,\n                instances,\n                update_override,\n                self.deleted_at_column,\n            )\n        else:  # pragma: no cover\n            raise NotImplementedError(\n                f\"Upsert multi is not implemented for {db.bind.dialect.name}\"\n            )\n\n        if return_as_model:\n            return_columns = self.model_col_names\n\n        if return_columns:\n            statement = statement.returning(*[column(name) for name in return_columns])\n            db_row = await db.execute(statement, params)\n            if commit:\n                await db.commit()\n            rows_data = [dict(row) for row in db_row.mappings()]\n            formatted_data = format_multi_response(\n                rows_data, schema_to_select, return_as_model\n            )\n            return {\"data\": formatted_data}\n\n        await db.execute(statement, params)\n        if commit:\n            await db.commit()\n        return None\n\n    async def exists(self, db: AsyncSession, **kwargs: Any) -&gt; bool:\n        \"\"\"\n        Checks if any records exist that match the given filter conditions.\n\n        For filtering details see [the Advanced Filters documentation](../advanced/crud.md/#advanced-filters)\n\n        Args:\n            db: The database session to use for the operation.\n            **kwargs: Filters to apply to the query, supporting both direct matches and advanced comparison operators for refined search criteria.\n\n        Returns:\n            `True` if at least one record matches the filter conditions, `False` otherwise.\n\n        Examples:\n            Check if a user with a specific ID exists:\n\n            ```python\n            exists = await user_crud.exists(db, id=1)\n            ```\n\n            Check if any user is older than 30:\n\n            ```python\n            exists = await user_crud.exists(db, age__gt=30)\n            ```\n\n            Check if any user was registered before Jan 1, 2020:\n\n            ```python\n            exists = await user_crud.exists(db, registration_date__lt=datetime(2020, 1, 1))\n            ```\n\n            Check if a username other than `admin` exists:\n\n            ```python\n            exists = await user_crud.exists(db, username__ne='admin')\n            ```\n        \"\"\"\n        filters = self._filter_processor.parse_filters(**kwargs)\n        stmt = select(self.model).filter(*filters).limit(1)\n\n        result = await db.execute(stmt)\n        return result.first() is not None\n\n    async def count(\n        self,\n        db: AsyncSession,\n        joins_config: Optional[list[JoinConfig]] = None,\n        distinct_on_primary: bool = False,\n        **kwargs: Any,\n    ) -&gt; int:\n        \"\"\"\n        Counts records that match specified filters.\n\n        For filtering details see [the Advanced Filters documentation](../advanced/crud.md/#advanced-filters)\n\n        Can also count records based on a configuration of joins, useful for complex queries involving relationships.\n\n        Args:\n            db: The database session to use for the operation.\n            joins_config: Optional configuration for applying joins in the count query.\n            distinct_on_primary: If True, counts only distinct base model rows when using joins.\n                This is particularly useful for one-to-many relationships to avoid inflated counts\n                from multiple joined rows per base row. Defaults to False.\n            **kwargs: Filters to apply for the count, including field names for equality checks or with comparison operators for advanced queries.\n\n        Returns:\n            The total number of records matching the filter conditions.\n\n        Examples:\n            Count users by ID:\n\n            ```python\n            count = await user_crud.count(db, id=1)\n            ```\n\n            Count users older than 30:\n\n            ```python\n            count = await user_crud.count(db, age__gt=30)\n            ```\n\n            Count users with a username other than `admin`:\n\n            ```python\n            count = await user_crud.count(db, username__ne='admin')\n            ```\n\n            Count projects with at least one participant (many-to-many relationship):\n\n            ```python\n            joins_config = [\n                JoinConfig(\n                    model=ProjectsParticipantsAssociation,\n                    join_on=Project.id == ProjectsParticipantsAssociation.project_id,\n                    join_type=\"inner\",\n                ),\n                JoinConfig(\n                    model=Participant,\n                    join_on=ProjectsParticipantsAssociation.participant_id == Participant.id,\n                    join_type=\"inner\",\n                ),\n            ]\n            project_crud = FastCRUD(Project)\n            count = await project_crud.count(db, joins_config=joins_config)\n            ```\n\n            Count projects by a specific participant name (filter applied on a joined model):\n\n            ```python\n            joins_config = [\n                JoinConfig(\n                    model=ProjectsParticipantsAssociation,\n                    join_on=Project.id == ProjectsParticipantsAssociation.project_id,\n                    join_type=\"inner\",\n                ),\n                JoinConfig(\n                    model=Participant,\n                    join_on=ProjectsParticipantsAssociation.participant_id == Participant.id,\n                    join_type=\"inner\",\n                    filters={'name': 'Jane Doe'},\n                ),\n            ]\n            count = await project_crud.count(db, joins_config=joins_config)\n            ```\n        \"\"\"\n        primary_filters = self._filter_processor.parse_filters(**kwargs)\n\n        if joins_config is not None:\n            primary_keys = list(get_primary_key_names(self.model))\n            if not any(primary_keys):  # pragma: no cover\n                raise ValueError(\n                    f\"The model '{self.model.__name__}' does not have a primary key defined, which is required for counting with joins.\"\n                )\n            to_select = [\n                getattr(self.model, pk).label(f\"distinct_{pk}\") for pk in primary_keys\n            ]\n            base_query = select(*to_select)\n            base_query = self._query_builder.prepare_joins(\n                base_query, joins_config, select_joined_columns=False\n            )\n            base_query = self._query_builder.apply_filters(base_query, primary_filters)\n\n            if distinct_on_primary:\n                base_query = base_query.distinct()\n                subquery = base_query.subquery()\n                count_query = select(func.count()).select_from(subquery)\n            else:\n                count_query = select(func.count()).select_from(base_query.subquery())\n        else:\n            count_query = select(func.count()).select_from(self.model)\n            count_query = self._query_builder.apply_filters(\n                count_query, primary_filters\n            )\n\n        total_count: Optional[int] = await db.scalar(count_query)\n        if total_count is None:\n            raise ValueError(\"Could not find the count.\")\n\n        return total_count\n\n    @overload\n    async def get_multi(\n        self,\n        db: AsyncSession,\n        *,\n        offset: int = 0,\n        limit: Optional[int] = 100,\n        schema_to_select: type[SelectSchemaType],\n        sort_columns: Optional[Union[str, list[str]]] = None,\n        sort_orders: Optional[Union[str, list[str]]] = None,\n        return_as_model: Literal[True],\n        return_total_count: bool = True,\n        **kwargs: Any,\n    ) -&gt; GetMultiResponseModel[SelectSchemaType]: ...\n\n    @overload\n    async def get_multi(\n        self,\n        db: AsyncSession,\n        *,\n        offset: int = 0,\n        limit: Optional[int] = 100,\n        schema_to_select: None = None,\n        sort_columns: Optional[Union[str, list[str]]] = None,\n        sort_orders: Optional[Union[str, list[str]]] = None,\n        return_as_model: Literal[False] = False,\n        return_total_count: bool = True,\n        **kwargs: Any,\n    ) -&gt; GetMultiResponseDict: ...\n\n    @overload\n    async def get_multi(\n        self,\n        db: AsyncSession,\n        *,\n        offset: int = 0,\n        limit: Optional[int] = 100,\n        schema_to_select: Optional[type[SelectSchemaType]] = None,\n        sort_columns: Optional[Union[str, list[str]]] = None,\n        sort_orders: Optional[Union[str, list[str]]] = None,\n        return_as_model: bool = False,\n        return_total_count: bool = True,\n        **kwargs: Any,\n    ) -&gt; Union[GetMultiResponseModel[SelectSchemaType], GetMultiResponseDict]: ...\n\n    async def get_multi(\n        self,\n        db: AsyncSession,\n        offset: int = 0,\n        limit: Optional[int] = 100,\n        schema_to_select: Optional[type[SelectSchemaType]] = None,\n        sort_columns: Optional[Union[str, list[str]]] = None,\n        sort_orders: Optional[Union[str, list[str]]] = None,\n        return_as_model: bool = False,\n        return_total_count: bool = True,\n        **kwargs: Any,\n    ) -&gt; Union[GetMultiResponseModel[SelectSchemaType], GetMultiResponseDict]:\n        \"\"\"\n        Fetches multiple records based on filters, supporting sorting, pagination.\n\n        For filtering details see [the Advanced Filters documentation](../advanced/crud.md/#advanced-filters)\n\n        Args:\n            db: The database session to use for the operation.\n            offset: Starting index for records to fetch, useful for pagination.\n            limit: Maximum number of records to fetch in one call. Use `None` for \"no limit\", fetching all matching rows. Note that in order to use `limit=None`, you'll have to provide a custom endpoint to facilitate it, which you should only do if you really seriously want to allow the user to get all the data at once.\n            schema_to_select: Optional Pydantic schema for selecting specific columns. Required if `return_as_model` is True.\n            sort_columns: Column names to sort the results by.\n            sort_orders: Corresponding sort orders (`\"asc\"`, `\"desc\"`) for each column in `sort_columns`.\n            return_as_model: If `True`, returns data as instances of the specified Pydantic model.\n            return_total_count: If `True`, also returns the total count of rows with the selected filters. Useful for pagination.\n            **kwargs: Filters to apply to the query, including advanced comparison operators for more detailed querying.\n\n        Returns:\n            A dictionary containing the data list and optionally the total count:\n            - With return_as_model=True: Dict with \"data\": List[SelectSchemaType]\n            - With return_as_model=False: Dict with \"data\": List[Dict[str, Any]]\n            - If return_total_count=True, includes \"total_count\": int\n\n        Raises:\n            ValueError: If `limit` or `offset` is negative, or if `schema_to_select` is required but not provided or invalid.\n\n        Examples:\n            Fetch the first 10 users:\n\n            ```python\n            users = await user_crud.get_multi(\n                db,\n                0,\n                10,\n            )\n            ```\n\n            Fetch next 10 users with sorted by username:\n\n            ```python\n            users = await user_crud.get_multi(\n                db,\n                10,\n                10,\n                sort_columns='username',\n                sort_orders='desc',\n            )\n            ```\n\n            Fetch 10 users older than 30, sorted by age in descending order:\n\n            ```python\n            users = await user_crud.get_multi(\n                db,\n                offset=0,\n                limit=10,\n                sort_columns='age',\n                sort_orders='desc',\n                age__gt=30,\n            )\n            ```\n\n            Fetch 10 users with a registration date before Jan 1, 2020:\n            ```python\n            users = await user_crud.get_multi(\n                db,\n                offset=0,\n                limit=10,\n                registration_date__lt=datetime(2020, 1, 1),\n            )\n            ```\n\n            Fetch 10 users with a username other than `admin`, returning as model instances (ensure appropriate schema is passed):\n\n            ```python\n            users = await user_crud.get_multi(\n                db,\n                offset=0,\n                limit=10,\n                schema_to_select=ReadUserSchema,\n                return_as_model=True,\n                username__ne='admin',\n            )\n            ```\n\n            Fetch users with filtering and multiple column sorting:\n\n            ```python\n            users = await user_crud.get_multi(\n                db,\n                0,\n                10,\n                sort_columns=['username', 'email'],\n                sort_orders=['asc', 'desc'],\n                is_active=True,\n            )\n            ```\n        \"\"\"\n        validate_pagination_params(offset, limit)\n        regular_filters, joined_filters_info = (\n            self._filter_processor.separate_joined_filters(**kwargs)\n        )\n\n        if joined_filters_info:\n            return await handle_joined_filters_delegation(\n                crud_instance=cast(CRUDInstance, self),\n                joined_filters_info=joined_filters_info,\n                db=db,\n                offset=offset,\n                limit=limit,\n                schema_to_select=schema_to_select,\n                sort_columns=sort_columns,\n                sort_orders=sort_orders,\n                return_as_model=return_as_model,\n                return_total_count=return_total_count,\n                **regular_filters,\n            )\n\n        stmt = await self.select(\n            schema_to_select=schema_to_select,\n            sort_columns=sort_columns,\n            sort_orders=sort_orders,\n            **kwargs,\n        )\n\n        stmt = self._query_builder.apply_pagination(stmt, offset, limit)\n        result = await db.execute(stmt)\n        data = [dict(row) for row in result.mappings()]\n        formatted_data = format_multi_response(data, schema_to_select, return_as_model)\n\n        response: dict[str, Any] = {self.multi_response_key: formatted_data}\n        if return_total_count:\n            total_count = await self.count(db=db, **kwargs)\n            response[\"total_count\"] = total_count\n\n        return response\n\n    async def get_joined(\n        self,\n        db: AsyncSession,\n        schema_to_select: Optional[type[SelectSchemaType]] = None,\n        join_model: Optional[ModelType] = None,\n        join_on: Optional[Union[Join, BinaryExpression]] = None,\n        join_prefix: Optional[str] = None,\n        join_schema_to_select: Optional[type[SelectSchemaType]] = None,\n        join_type: str = \"left\",\n        alias: Optional[AliasedClass] = None,\n        join_filters: Optional[dict] = None,\n        joins_config: Optional[list[JoinConfig]] = None,\n        nest_joins: bool = False,\n        relationship_type: Optional[str] = None,\n        **kwargs: Any,\n    ) -&gt; Optional[dict[str, Any]]:\n        \"\"\"\n        Fetches a single record with one or multiple joins on other models. If `join_on` is not provided, the method attempts\n        to automatically detect the join condition using foreign key relationships. For multiple joins, use `joins_config` to\n        specify each join configuration.\n\n        For filtering details see [the Advanced Filters documentation](../advanced/crud.md/#advanced-filters)\n\n        Args:\n            db: The SQLAlchemy async session.\n            schema_to_select: Pydantic schema for selecting specific columns from the primary model. Required if `return_as_model` is True.\n            join_model: The model to join with.\n            join_on: SQLAlchemy Join object for specifying the `ON` clause of the join. If `None`, the join condition is auto-detected based on foreign keys.\n            join_prefix: Optional prefix to be added to all columns of the joined model. If `None`, no prefix is added.\n            join_schema_to_select: Pydantic schema for selecting specific columns from the joined model.\n            join_type: Specifies the type of join operation to perform. Can be `\"left\"` for a left outer join or `\"inner\"` for an inner join.\n            alias: An instance of `AliasedClass` for the join model, useful for self-joins or multiple joins on the same model. Result of `aliased(join_model)`.\n            join_filters: Filters applied to the joined model, specified as a dictionary mapping column names to their expected values.\n            joins_config: A list of `JoinConfig` instances, each specifying a model to join with, join condition, optional prefix for column names, schema for selecting specific columns, and the type of join. This parameter enables support for multiple joins.\n            nest_joins: If `True`, nested data structures will be returned where joined model data are nested under the `join_prefix` as a dictionary.\n            relationship_type: Specifies the relationship type, such as `\"one-to-one\"` or `\"one-to-many\"`. Used to determine how to nest the joined data. If `None`, uses `\"one-to-one\"`.\n            **kwargs: Filters to apply to the primary model query, supporting advanced comparison operators for refined searching.\n\n        Returns:\n            A dictionary representing the joined record, or `None` if no record matches the criteria.\n\n        Raises:\n            ValueError: If both single join parameters and `joins_config` are used simultaneously.\n            ArgumentError: If any provided model in `joins_config` is not recognized or invalid.\n            NoResultFound: If no record matches the criteria with the provided filters.\n\n        Examples:\n            Simple example: Joining `User` and `Tier` models without explicitly providing `join_on`\n\n            ```python\n            result = await user_crud.get_joined(\n                db=session,\n                schema_to_select=ReadUserSchema,\n                join_model=Tier,\n                join_schema_to_select=ReadTierSchema,\n            )\n            ```\n\n            Fetch a user and their associated tier, filtering by user ID:\n\n            ```python\n            result = await user_crud.get_joined(\n                db,\n                schema_to_select=ReadUserSchema,\n                join_model=Tier,\n                join_schema_to_select=ReadTierSchema,\n                id=1,\n            )\n            ```\n\n            Fetch a user and their associated tier, where the user's age is greater than 30:\n\n            ```python\n            result = await user_crud.get_joined(\n                db,\n                schema_to_select=ReadUserSchema,\n                join_model=Tier,\n                join_schema_to_select=ReadTierSchema,\n                age__gt=30,\n            )\n            ```\n\n            Fetch a user and their associated tier, excluding users with the `admin` username:\n\n            ```python\n            result = await user_crud.get_joined(\n                db,\n                schema_to_select=ReadUserSchema,\n                join_model=Tier,\n                join_schema_to_select=ReadTierSchema,\n                username__ne='admin',\n            )\n            ```\n\n            Complex example: Joining with a custom join condition, additional filter parameters, and a prefix\n\n            ```python\n            from sqlalchemy import and_\n            result = await user_crud.get_joined(\n                db=session,\n                schema_to_select=ReadUserSchema,\n                join_model=Tier,\n                join_on=and_(User.tier_id == Tier.id, User.is_superuser == True),\n                join_prefix=\"tier_\",\n                join_schema_to_select=ReadTierSchema,\n                username=\"john_doe\",\n            )\n            ```\n\n            Example of using `joins_config` for multiple joins:\n\n            ```python\n            from fastcrud import JoinConfig\n\n            # Using same User/Tier/Department models/schemas as above.\n\n            result = await user_crud.get_joined(\n                db=session,\n                schema_to_select=ReadUserSchema,\n                joins_config=[\n                    JoinConfig(\n                        model=Tier,\n                        join_on=User.tier_id == Tier.id,\n                        join_prefix=\"tier_\",\n                        schema_to_select=ReadTierSchema,\n                        join_type=\"left\",\n                    ),\n                    JoinConfig(\n                        model=Department,\n                        join_on=User.department_id == Department.id,\n                        join_prefix=\"dept_\",\n                        schema_to_select=ReadDepartmentSchema,\n                        join_type=\"inner\",\n                    ),\n                ],\n            )\n            ```\n\n            Using `alias` for joining the same model multiple times:\n            ```python\n            from fastcrud import aliased\n\n            owner_alias = aliased(ModelTest, name=\"owner\")\n            user_alias = aliased(ModelTest, name=\"user\")\n\n            result = await crud.get_joined(\n                db=session,\n                schema_to_select=BookingSchema,\n                joins_config=[\n                    JoinConfig(\n                        model=ModelTest,\n                        join_on=BookingModel.owner_id == owner_alias.id,\n                        join_prefix=\"owner_\",\n                        alias=owner_alias,\n                        schema_to_select=UserSchema,\n                    ),\n                    JoinConfig(\n                        model=ModelTest,\n                        join_on=BookingModel.user_id == user_alias.id,\n                        join_prefix=\"user_\",\n                        alias=user_alias,\n                        schema_to_select=UserSchema,\n                    ),\n                ],\n                id=1,\n            )\n            ```\n\n            Fetching a single project and its associated participants where a participant has a specific role:\n\n            ```python\n            joins_config = [\n                JoinConfig(\n                    model=ProjectsParticipantsAssociation,\n                    join_on=Project.id == ProjectsParticipantsAssociation.project_id,\n                    join_type=\"inner\",\n                ),\n                JoinConfig(\n                    model=Participant,\n                    join_on=ProjectsParticipantsAssociation.participant_id == Participant.id,\n                    join_type=\"inner\",\n                    filters={'role': 'Designer'},\n                ),\n            ]\n\n            project_crud = FastCRUD(Project)\n\n            project = await project_crud.get_joined(\n                db=session,\n                schema_to_select=ReadProjectSchema,\n                joins_config=joins_config,\n            )\n            ```\n\n            Example of using `joins_config` for multiple joins with nested joins enabled:\n\n            ```python\n            from fastcrud import JoinConfig\n\n            result = await user_crud.get_joined(\n                db=session,\n                schema_to_select=ReadUserSchema,\n                joins_config=[\n                    JoinConfig(\n                        model=Tier,\n                        join_on=User.tier_id == Tier.id,\n                        join_prefix=\"tier_\",\n                        schema_to_select=ReadTierSchema,\n                        join_type=\"left\",\n                    ),\n                    JoinConfig(\n                        model=Department,\n                        join_on=User.department_id == Department.id,\n                        join_prefix=\"dept_\",\n                        schema_to_select=ReadDepartmentSchema,\n                        join_type=\"inner\",\n                    ),\n                ],\n                nest_joins=True,\n            )\n            # Expect 'result' to have 'tier' and 'dept' as nested dictionaries\n            ```\n\n            Example using one-to-one relationship:\n\n            ```python\n            author_crud = FastCRUD(Author)\n            result = await author_crud.get_joined(\n                db=session,\n                schema_to_select=ReadAuthorSchema,\n                join_model=Profile,\n                join_on=Author.profile_id == Profile.id,\n                join_schema_to_select=ReadProfileSchema,\n                nest_joins=True,\n                relationship_type='one-to-one', # note that this is the default behavior\n            )\n            # Expect 'result' to have 'profile' as a nested dictionary\n            ```\n\n            Example using one-to-many relationship:\n\n            ```python\n            result = await author_crud.get_joined(\n                db=session,\n                schema_to_select=ReadAuthorSchema,\n                join_model=Article,\n                join_on=Author.id == Article.author_id,\n                join_schema_to_select=ReadArticleSchema,\n                nest_joins=True,\n                relationship_type='one-to-many',\n            )\n            # Expect 'result' to have 'posts' as a nested list of dictionaries\n            ```\n        \"\"\"\n        if joins_config and (\n            join_model or join_prefix or join_on or join_schema_to_select or alias\n        ):\n            raise ValueError(\n                \"Cannot use both single join parameters and joins_config simultaneously.\"\n            )\n        elif not joins_config and not join_model:\n            raise ValueError(\"You need one of join_model or joins_config.\")\n\n        primary_select = extract_matching_columns_from_schema(\n            model=self.model,\n            schema=schema_to_select,\n        )\n        stmt = self._query_builder.build_base_select(primary_select)\n\n        join_definitions = joins_config if joins_config else []\n        if join_model:\n            join_definitions.append(\n                JoinConfig(\n                    model=join_model,\n                    join_on=join_on\n                    if join_on is not None\n                    else auto_detect_join_condition(self.model, join_model),\n                    join_prefix=join_prefix,\n                    schema_to_select=join_schema_to_select,\n                    join_type=join_type,\n                    alias=alias,\n                    filters=join_filters,\n                    relationship_type=relationship_type,\n                )\n            )\n\n        stmt = self._query_builder.prepare_joins(\n            stmt=stmt, joins_config=join_definitions, use_temporary_prefix=nest_joins\n        )\n        primary_filters = self._filter_processor.parse_filters(**kwargs)\n        stmt = self._query_builder.apply_filters(stmt, primary_filters)\n\n        db_rows = await db.execute(stmt)\n        if any(join.relationship_type == \"one-to-many\" for join in join_definitions):\n            if nest_joins is False:  # pragma: no cover\n                raise ValueError(\n                    \"Cannot use one-to-many relationship with nest_joins=False\"\n                )\n            results = db_rows.fetchall()\n            data_list = [dict(row._mapping) for row in results]\n        else:\n            result = db_rows.first()\n            if result is not None:\n                data_list = [dict(result._mapping)]\n            else:\n                data_list = []\n\n        return process_joined_data(data_list, join_definitions, nest_joins, self.model)\n\n    @overload\n    async def get_multi_joined(\n        self,\n        db: AsyncSession,\n        schema_to_select: type[SelectSchemaType],\n        return_as_model: Literal[True],\n        join_model: Optional[type[ModelType]] = None,\n        join_on: Optional[Any] = None,\n        join_prefix: Optional[str] = None,\n        join_schema_to_select: Optional[type[SelectSchemaType]] = None,\n        join_type: str = \"left\",\n        alias: Optional[AliasedClass[Any]] = None,\n        join_filters: Optional[dict] = None,\n        nest_joins: bool = False,\n        offset: int = 0,\n        limit: Optional[int] = 100,\n        sort_columns: Optional[Union[str, list[str]]] = None,\n        sort_orders: Optional[Union[str, list[str]]] = None,\n        joins_config: Optional[list[JoinConfig]] = None,\n        counts_config: Optional[list[CountConfig]] = None,\n        return_total_count: bool = True,\n        relationship_type: Optional[str] = None,\n        nested_schema_to_select: Optional[dict[str, type[SelectSchemaType]]] = None,\n        **kwargs: Any,\n    ) -&gt; GetMultiResponseModel[SelectSchemaType]: ...\n\n    @overload\n    async def get_multi_joined(\n        self,\n        db: AsyncSession,\n        schema_to_select: None = None,\n        return_as_model: Literal[False] = False,\n        join_model: Optional[type[ModelType]] = None,\n        join_on: Optional[Any] = None,\n        join_prefix: Optional[str] = None,\n        join_schema_to_select: Optional[type[SelectSchemaType]] = None,\n        join_type: str = \"left\",\n        alias: Optional[AliasedClass[Any]] = None,\n        join_filters: Optional[dict] = None,\n        nest_joins: bool = False,\n        offset: int = 0,\n        limit: Optional[int] = 100,\n        sort_columns: Optional[Union[str, list[str]]] = None,\n        sort_orders: Optional[Union[str, list[str]]] = None,\n        joins_config: Optional[list[JoinConfig]] = None,\n        counts_config: Optional[list[CountConfig]] = None,\n        return_total_count: bool = True,\n        relationship_type: Optional[str] = None,\n        nested_schema_to_select: Optional[dict[str, type[SelectSchemaType]]] = None,\n        **kwargs: Any,\n    ) -&gt; GetMultiResponseDict: ...\n\n    @overload\n    async def get_multi_joined(\n        self,\n        db: AsyncSession,\n        *,\n        schema_to_select: Optional[type[SelectSchemaType]] = None,\n        return_as_model: bool = False,\n        join_model: Optional[type[ModelType]] = None,\n        join_on: Optional[Any] = None,\n        join_prefix: Optional[str] = None,\n        join_schema_to_select: Optional[type[SelectSchemaType]] = None,\n        join_type: str = \"left\",\n        alias: Optional[AliasedClass[Any]] = None,\n        join_filters: Optional[dict] = None,\n        nest_joins: bool = False,\n        offset: int = 0,\n        limit: Optional[int] = 100,\n        sort_columns: Optional[Union[str, list[str]]] = None,\n        sort_orders: Optional[Union[str, list[str]]] = None,\n        joins_config: Optional[list[JoinConfig]] = None,\n        counts_config: Optional[list[CountConfig]] = None,\n        return_total_count: bool = True,\n        relationship_type: Optional[str] = None,\n        nested_schema_to_select: Optional[dict[str, type[SelectSchemaType]]] = None,\n        **kwargs: Any,\n    ) -&gt; Union[GetMultiResponseModel[SelectSchemaType], GetMultiResponseDict]: ...\n\n    async def get_multi_joined(\n        self,\n        db: AsyncSession,\n        schema_to_select: Optional[type[SelectSchemaType]] = None,\n        return_as_model: bool = False,\n        join_model: Optional[type[ModelType]] = None,\n        join_on: Optional[Any] = None,\n        join_prefix: Optional[str] = None,\n        join_schema_to_select: Optional[type[SelectSchemaType]] = None,\n        join_type: str = \"left\",\n        alias: Optional[AliasedClass[Any]] = None,\n        join_filters: Optional[dict] = None,\n        nest_joins: bool = False,\n        offset: int = 0,\n        limit: Optional[int] = 100,\n        sort_columns: Optional[Union[str, list[str]]] = None,\n        sort_orders: Optional[Union[str, list[str]]] = None,\n        joins_config: Optional[list[JoinConfig]] = None,\n        counts_config: Optional[list[CountConfig]] = None,\n        return_total_count: bool = True,\n        relationship_type: Optional[str] = None,\n        nested_schema_to_select: Optional[dict[str, type[SelectSchemaType]]] = None,\n        **kwargs: Any,\n    ) -&gt; Union[GetMultiResponseModel[SelectSchemaType], GetMultiResponseDict]:\n        \"\"\"\n        Fetch multiple records with a join on another model, allowing for pagination, optional sorting, and model conversion.\n\n        For filtering details see [the Advanced Filters documentation](../advanced/crud.md/#advanced-filters)\n\n        Args:\n            db: The SQLAlchemy async session.\n            schema_to_select: Pydantic schema for selecting specific columns from the primary model. Required if `return_as_model` is True.\n            join_model: The model to join with.\n            join_on: SQLAlchemy Join object for specifying the `ON` clause of the join. If `None`, the join condition is auto-detected based on foreign keys.\n            join_prefix: Optional prefix to be added to all columns of the joined model. If `None`, no prefix is added.\n            join_schema_to_select: Pydantic schema for selecting specific columns from the joined model.\n            join_type: Specifies the type of join operation to perform. Can be `\"left\"` for a left outer join or `\"inner\"` for an inner join.\n            alias: An instance of `AliasedClass` for the join model, useful for self-joins or multiple joins on the same model. Result of `aliased(join_model)`.\n            join_filters: Filters applied to the joined model, specified as a dictionary mapping column names to their expected values.\n            nest_joins: If `True`, nested data structures will be returned where joined model data are nested under the `join_prefix` as a dictionary.\n            offset: The offset (number of records to skip) for pagination.\n            limit: Maximum number of records to fetch in one call. Use `None` for \"no limit\", fetching all matching rows. Note that in order to use `limit=None`, you'll have to provide a custom endpoint to facilitate it, which you should only do if you really seriously want to allow the user to get all the data at once.\n            sort_columns: A single column name or a list of column names on which to apply sorting.\n            sort_orders: A single sort order (`\"asc\"` or `\"desc\"`) or a list of sort orders corresponding to the columns in `sort_columns`. If not provided, defaults to `\"asc\"` for each column.\n            return_as_model: If `True`, converts the fetched data to Pydantic models based on `schema_to_select`. Defaults to `False`.\n            joins_config: List of `JoinConfig` instances for specifying multiple joins. Each instance defines a model to join with, join condition, optional prefix for column names, schema for selecting specific columns, and join type.\n            counts_config: List of `CountConfig` instances for counting related objects. Each instance defines a model to count, join condition, and optional alias for the count column. Useful for many-to-many relationships.\n            return_total_count: If `True`, also returns the total count of rows with the selected filters. Useful for pagination.\n            relationship_type: Specifies the relationship type, such as `\"one-to-one\"` or `\"one-to-many\"`. Used to determine how to nest the joined data. If `None`, uses `\"one-to-one\"`.\n            nested_schema_to_select: A dictionary mapping join prefixes to their corresponding Pydantic schemas for nested data conversion. If not provided, schemas are auto-detected from `joins_config`.\n            **kwargs: Filters to apply to the primary query, including advanced comparison operators for refined searching.\n\n        Returns:\n            A dictionary containing the fetched rows under `\"data\"` key and total count under `\"total_count\"`:\n\n            - When `return_as_model=True` and `schema_to_select` is provided: `GetMultiResponseModel[SelectSchemaType]`\n              (`Dict[str, Union[List[SelectSchemaType], int]]`)\n            - When `return_as_model=False`: `GetMultiResponseDict`\n              (`Dict[str, Union[List[Dict[str, Any]], int]]`)\n\n        Raises:\n            ValueError: If either `limit` or `offset` are negative, or if `schema_to_select` is required but not provided or invalid.\n                        Also if both `joins_config` and any of the single join parameters are provided or none of `joins_config` and `join_model` is provided.\n\n        Examples:\n            Fetching multiple `User` records joined with `Tier` records, using left join, returning raw data:\n\n            ```python\n            users = await user_crud.get_multi_joined(\n                db=session,\n                schema_to_select=ReadUserSchema,\n                join_model=Tier,\n                join_prefix=\"tier_\",\n                join_schema_to_select=ReadTierSchema,\n                offset=0,\n                limit=10,\n            )\n            ```\n\n            Fetch users joined with their tiers, sorted by username, where user's age is greater than 30:\n\n            ```python\n            users = await user_crud.get_multi_joined(\n                db,\n                schema_to_select=ReadUserSchema,\n                join_model=Tier,\n                join_schema_to_select=ReadTierSchema,\n                sort_columns='username',\n                sort_orders='asc',\n                age__gt=30,\n            )\n            ```\n\n            Fetch users joined with their tiers, excluding users with `admin` username, returning as model instances:\n\n            ```python\n            users = await user_crud.get_multi_joined(\n                db,\n                schema_to_select=ReadUserSchema,\n                join_model=Tier,\n                join_schema_to_select=ReadTierSchema,\n                return_as_model=True,\n                username__ne='admin',\n            )\n            ```\n\n            Fetching and sorting by username in descending order, returning as Pydantic model:\n\n            ```python\n            users = await user_crud.get_multi_joined(\n                db=session,\n                schema_to_select=ReadUserSchema,\n                join_model=Tier,\n                join_prefix=\"tier_\",\n                join_schema_to_select=ReadTierSchema,\n                offset=0,\n                limit=10,\n                sort_columns=['username'],\n                sort_orders=['desc'],\n                return_as_model=True,\n            )\n            ```\n\n            Fetching with complex conditions and custom join, returning as Pydantic model:\n\n            ```python\n            users = await user_crud.get_multi_joined(\n                db=session,\n                schema_to_select=ReadUserSchema,\n                join_model=Tier,\n                join_on=User.tier_id == Tier.id,\n                join_prefix=\"tier_\",\n                join_schema_to_select=ReadTierSchema,\n                offset=0,\n                limit=10,\n                return_as_model=True,\n                is_active=True,\n            )\n            ```\n\n            Example using `joins_config` for multiple joins:\n\n            ```python\n            from fastcrud import JoinConfig\n\n            users = await user_crud.get_multi_joined(\n                db=session,\n                schema_to_select=ReadUserSchema,\n                joins_config=[\n                    JoinConfig(\n                        model=Tier,\n                        join_on=User.tier_id == Tier.id,\n                        join_prefix=\"tier_\",\n                        schema_to_select=ReadTierSchema,\n                        join_type=\"left\",\n                    ),\n                    JoinConfig(\n                        model=Department,\n                        join_on=User.department_id == Department.id,\n                        join_prefix=\"dept_\",\n                        schema_to_select=ReadDepartmentSchema,\n                        join_type=\"inner\",\n                    ),\n                ],\n                offset=0,\n                limit=10,\n                sort_columns='username',\n                sort_orders='asc',\n            )\n            ```\n\n            Example using `alias` for multiple joins, with pagination, sorting, and model conversion:\n            ```python\n            from fastcrud import JoinConfig, FastCRUD, aliased\n\n            # Aliasing for self-joins or multiple joins on the same table\n            owner_alias = aliased(ModelTest, name=\"owner\")\n            user_alias = aliased(ModelTest, name=\"user\")\n\n            # Initialize your FastCRUD instance for BookingModel\n            crud = FastCRUD(BookingModel)\n\n            result = await crud.get_multi_joined(\n                db=session,\n                schema_to_select=BookingSchema,  # Primary model schema\n                joins_config=[\n                    JoinConfig(\n                        model=ModelTest,\n                        join_on=BookingModel.owner_id == owner_alias.id,\n                        join_prefix=\"owner_\",\n                        schema_to_select=UserSchema,  # Schema for the joined model\n                        alias=owner_alias,\n                    ),\n                    JoinConfig(\n                        model=ModelTest,\n                        join_on=BookingModel.user_id == user_alias.id,\n                        join_prefix=\"user_\",\n                        schema_to_select=UserSchema,\n                        alias=user_alias,\n                    )\n                ],\n                offset=10,  # Skip the first 10 records\n                limit=5,  # Fetch up to 5 records\n                sort_columns=['booking_date'],  # Sort by booking_date\n                sort_orders=['desc'],  # In descending order\n            )\n            ```\n\n            Fetching multiple project records and their associated participants where participants have a specific role:\n\n            ```python\n            joins_config = [\n                JoinConfig(\n                    model=ProjectsParticipantsAssociation,\n                    join_on=Project.id == ProjectsParticipantsAssociation.project_id,\n                    join_type=\"inner\",\n                ),\n                JoinConfig(\n                    model=Participant,\n                    join_on=ProjectsParticipantsAssociation.participant_id == Participant.id,\n                    join_type=\"inner\",\n                    filters={'role': 'Developer'},\n                ),\n            ]\n\n            project_crud = FastCRUD(Project)\n\n            projects = await project_crud.get_multi_joined(\n                db=session,\n                schema_to_select=ReadProjectSchema,\n                limit=10,\n                joins_config=joins_config,\n            )\n            ```\n\n            Fetching a list of stories, each with nested details of associated tasks and task creators, using nested joins:\n\n            ```python\n            story_crud = FastCRUD(Story)\n            stories = await story_crud.get_multi_joined(\n                db=session,\n                schema_to_select=ReadStorySchema,\n                joins_config=[\n                    JoinConfig(\n                        model=Task,\n                        join_on=Story.id == Task.story_id,\n                        join_prefix=\"task_\",\n                        schema_to_select=ReadTaskSchema,\n                        join_type=\"left\",\n                    ),\n                    JoinConfig(\n                        model=User,\n                        join_on=Task.creator_id == User.id,\n                        join_prefix=\"creator_\",\n                        schema_to_select=ReadUserSchema,\n                        join_type=\"left\",\n                        alias=aliased(User, name=\"task_creator\"),\n                    ),\n                ],\n                nest_joins=True,\n                offset=0,\n                limit=5,\n                sort_columns='name',\n                sort_orders='asc',\n            )\n            ```\n\n            Example using one-to-one relationship:\n\n            ```python\n            author_crud = FastCRUD(Author)\n            results = await author_crud.get_multi_joined(\n                db=session,\n                schema_to_select=ReadAuthorSchema,\n                join_model=Profile,\n                join_on=Author.profile_id == Profile.id,\n                join_schema_to_select=ReadProfileSchema,\n                nest_joins=True,\n                offset=0,\n                limit=10,\n                relationship_type='one-to-one', # note that this is the default behavior\n            )\n            # Expect 'profile' to be nested as a dictionary under each user\n            ```\n\n            Example using one-to-many relationship:\n\n            ```python\n            results = await author_crud.get_multi_joined(\n                db=session,\n                schema_to_select=ReadAuthorSchema,\n                join_model=Article,\n                join_on=Author.id == Article.author_id,\n                join_schema_to_select=ReadArticleSchema,\n                nest_joins=True,\n                offset=0,\n                limit=10,\n                relationship_type='one-to-many',\n            )\n            # Expect 'posts' to be nested as a list of dictionaries under each user\n            ```\n\n            Example using counts_config to count related objects (e.g., many-to-many relationships):\n\n            ```python\n            from fastcrud import FastCRUD, CountConfig\n\n            search_crud = FastCRUD(Search)\n\n            # Count videos for each search through a many-to-many relationship\n            results = await search_crud.get_multi_joined(\n                db=session,\n                counts_config=[\n                    CountConfig(\n                        model=Video,\n                        join_on=(Video.id == VideoSearchAssociation.video_id)\n                               &amp; (VideoSearchAssociation.search_id == Search.id),\n                        alias='videos_count'\n                    )\n                ],\n            )\n            # Results will include 'videos_count' field for each search\n            # Example result:\n            # {\n            #     \"data\": [\n            #         {\"id\": 1, \"term\": \"cats\", \"videos_count\": 5},\n            #         {\"id\": 2, \"term\": \"dogs\", \"videos_count\": 3},\n            #         {\"id\": 3, \"term\": \"birds\", \"videos_count\": 0}\n            #     ],\n            #     \"total_count\": 3\n            # }\n            ```\n        \"\"\"\n        config = validate_joined_query_params(\n            primary_model=self.model,\n            joins_config=joins_config,\n            join_model=join_model,\n            join_prefix=join_prefix,\n            join_on=join_on,\n            join_schema_to_select=join_schema_to_select,\n            alias=alias,\n            relationship_type=relationship_type,\n            join_type=join_type,\n            join_filters=join_filters,\n            counts_config=counts_config,\n            limit=limit,\n            offset=offset,\n        )\n\n        stmt = build_joined_query(\n            model=self.model,\n            query_builder=self._query_builder,\n            filter_processor=self._filter_processor,\n            config=config,\n            schema_to_select=schema_to_select,\n            nest_joins=nest_joins,\n            **kwargs,\n        )\n        raw_data = await execute_joined_query(\n            db=db,\n            stmt=stmt,\n            query_builder=self._query_builder,\n            limit=limit,\n            offset=offset,\n            sort_columns=sort_columns,\n            sort_orders=sort_orders,\n        )\n\n        return await format_joined_response(\n            primary_model=self.model,\n            raw_data=raw_data,\n            config=config,\n            schema_to_select=schema_to_select,\n            return_as_model=return_as_model,\n            nest_joins=nest_joins,\n            return_total_count=return_total_count,\n            db=db,\n            nested_schema_to_select=nested_schema_to_select,\n            count_func=self.count if return_total_count else None,\n            **kwargs,\n        )\n\n    @overload\n    async def get_multi_by_cursor(\n        self,\n        db: AsyncSession,\n        *,\n        cursor: Any = None,\n        limit: int = 100,\n        schema_to_select: type[SelectSchemaType],\n        sort_column: str = \"id\",\n        sort_order: str = \"asc\",\n        return_as_model: Literal[True],\n        **kwargs: Any,\n    ) -&gt; dict[str, Union[list[SelectSchemaType], Any]]: ...\n\n    @overload\n    async def get_multi_by_cursor(\n        self,\n        db: AsyncSession,\n        *,\n        cursor: Any = None,\n        limit: int = 100,\n        schema_to_select: None = None,\n        sort_column: str = \"id\",\n        sort_order: str = \"asc\",\n        return_as_model: Literal[False] = False,\n        **kwargs: Any,\n    ) -&gt; dict[str, Union[list[dict[str, Any]], Any]]: ...\n\n    @overload\n    async def get_multi_by_cursor(\n        self,\n        db: AsyncSession,\n        *,\n        cursor: Any = None,\n        limit: int = 100,\n        schema_to_select: Optional[type[SelectSchemaType]] = None,\n        sort_column: str = \"id\",\n        sort_order: str = \"asc\",\n        return_as_model: bool = False,\n        **kwargs: Any,\n    ) -&gt; dict[str, Union[list[Union[dict[str, Any], SelectSchemaType]], Any]]: ...\n\n    async def get_multi_by_cursor(\n        self,\n        db: AsyncSession,\n        cursor: Any = None,\n        limit: int = 100,\n        schema_to_select: Optional[type[SelectSchemaType]] = None,\n        sort_column: str = \"id\",\n        sort_order: str = \"asc\",\n        return_as_model: bool = False,\n        **kwargs: Any,\n    ) -&gt; dict[str, Any]:\n        \"\"\"\n        Implements cursor-based pagination for fetching records. This method is designed for efficient data retrieval in large datasets and is ideal for features like infinite scrolling.\n\n        For filtering details see [the Advanced Filters documentation](../advanced/crud.md/#advanced-filters)\n\n        Args:\n            db: The SQLAlchemy async session.\n            cursor: The cursor value to start fetching records from. Defaults to `None`.\n            limit: Maximum number of rows to fetch.\n            schema_to_select: Pydantic schema for selecting specific columns. Required if `return_as_model` is True.\n            sort_column: Column name to use for sorting and cursor pagination.\n            sort_order: Sorting direction, either `\"asc\"` or `\"desc\"`.\n            return_as_model: If `True`, converts the fetched data to Pydantic models based on `schema_to_select`. Defaults to `False`.\n            **kwargs: Filters to apply to the query, including advanced comparison operators for detailed querying.\n\n        Returns:\n            A dictionary containing the fetched rows under `\"data\"` key and the next cursor value under `\"next_cursor\"`:\n\n            - When `return_as_model=True` and `schema_to_select` is provided: `Dict[str, Union[List[SelectSchemaType], Any]]`\n            - When `return_as_model=False`: `Dict[str, Union[List[Dict[str, Any]], Any]]`\n\n        Examples:\n            Fetch the first set of records (e.g., the first page in an infinite scrolling scenario):\n\n            ```python\n            first_page = await user_crud.get_multi_by_cursor(\n                db,\n                limit=10,\n                sort_column='registration_date',\n            )\n\n            # Fetch the next set of records using the cursor from the first page\n            second_page = await user_crud.get_multi_by_cursor(\n                db,\n                cursor=next_cursor,\n                limit=10,\n                sort_column='registration_date',\n                sort_order='desc',\n            )\n            ```\n\n            Fetch records as Pydantic models with cursor pagination:\n\n            ```python\n            # Returns typed Pydantic models\n            first_page = await user_crud.get_multi_by_cursor(\n                db,\n                schema_to_select=ReadUserSchema,\n                return_as_model=True,\n                limit=10,\n                sort_column='registration_date',\n                age__gt=30,\n            )\n            ```\n\n            Fetch records excluding a specific username using cursor-based pagination:\n\n            ```python\n            result = await user_crud.get_multi_by_cursor(\n                db,\n                limit=10,\n                sort_column='username',\n                sort_order='asc',\n                username__ne='admin',\n            )\n            ```\n\n            Fetch records as Pydantic model instances using cursor-based pagination:\n\n            ```python\n            result = await user_crud.get_multi_by_cursor(\n                db,\n                limit=10,\n                schema_to_select=ReadUserSchema,\n                return_as_model=True,\n                sort_column='created_at',\n                sort_order='desc',\n            )\n            ```\n\n        Note:\n            This method is designed for efficient pagination in large datasets and is ideal for infinite scrolling features.\n            Make sure the column used for cursor pagination is indexed for performance.\n        \"\"\"\n        if limit == 0:\n            return {\"data\": [], \"next_cursor\": None}\n\n        stmt = await self.select(schema_to_select=schema_to_select, **kwargs)\n\n        if cursor:\n            cursor_filter = []\n            if sort_order == \"asc\":\n                cursor_filter = self._filter_processor.parse_filters(\n                    **{f\"{sort_column}__gt\": cursor}\n                )\n            else:\n                cursor_filter = self._filter_processor.parse_filters(\n                    **{f\"{sort_column}__lt\": cursor}\n                )\n            stmt = self._query_builder.apply_filters(stmt, cursor_filter)\n\n        stmt = self._query_builder.apply_sorting(stmt, sort_column, sort_order)\n        stmt = self._query_builder.apply_pagination(stmt, 0, limit)\n\n        result = await db.execute(stmt)\n        data = [dict(row) for row in result.mappings()]\n        next_cursor = data[-1][sort_column] if len(data) == limit else None\n\n        formatted_data = format_multi_response(data, schema_to_select, return_as_model)\n\n        return {\"data\": formatted_data, \"next_cursor\": next_cursor}\n\n    @overload\n    async def update(\n        self,\n        db: AsyncSession,\n        object: Union[UpdateSchemaType, dict[str, Any]],\n        *,\n        allow_multiple: bool = False,\n        commit: bool = True,\n        return_columns: Optional[list[str]] = None,\n        schema_to_select: type[SelectSchemaType],\n        return_as_model: Literal[True],\n        one_or_none: bool = False,\n        **kwargs: Any,\n    ) -&gt; Optional[SelectSchemaType]: ...\n\n    @overload\n    async def update(\n        self,\n        db: AsyncSession,\n        object: Union[UpdateSchemaType, dict[str, Any]],\n        *,\n        allow_multiple: bool = False,\n        commit: bool = True,\n        return_columns: Optional[list[str]] = None,\n        schema_to_select: None = None,\n        return_as_model: Literal[False] = False,\n        one_or_none: bool = False,\n        **kwargs: Any,\n    ) -&gt; Optional[dict[str, Any]]: ...\n\n    @overload\n    async def update(\n        self,\n        db: AsyncSession,\n        object: Union[UpdateSchemaType, dict[str, Any]],\n        *,\n        allow_multiple: bool = False,\n        commit: bool = True,\n        return_columns: Optional[list[str]] = None,\n        schema_to_select: Optional[type[SelectSchemaType]] = None,\n        return_as_model: bool = False,\n        one_or_none: bool = False,\n        **kwargs: Any,\n    ) -&gt; Optional[Union[dict[str, Any], SelectSchemaType]]: ...\n\n    async def update(\n        self,\n        db: AsyncSession,\n        object: Union[UpdateSchemaType, dict[str, Any]],\n        allow_multiple: bool = False,\n        commit: bool = True,\n        return_columns: Optional[list[str]] = None,\n        schema_to_select: Optional[type[SelectSchemaType]] = None,\n        return_as_model: bool = False,\n        one_or_none: bool = False,\n        **kwargs: Any,\n    ) -&gt; Optional[Union[dict, SelectSchemaType]]:\n        \"\"\"\n        Updates an existing record or multiple records in the database based on specified filters. This method allows for precise targeting of records to update.\n\n        For filtering details see [the Advanced Filters documentation](../advanced/crud.md/#advanced-filters)\n\n        Args:\n            db: The database session to use for the operation.\n            object: A Pydantic schema or dictionary containing the update data.\n            allow_multiple: If `True`, allows updating multiple records that match the filters. If `False`, raises an error if more than one record matches the filters.\n            commit: If `True`, commits the transaction immediately. Default is `True`.\n            return_columns: A list of column names to return after the update. If `return_as_model` is True, all columns are returned.\n            schema_to_select: Pydantic schema for selecting specific columns from the updated record(s). Required if `return_as_model` is `True`.\n            return_as_model: If `True`, returns the updated record(s) as Pydantic model instances based on `schema_to_select`. Default is False.\n            one_or_none: If `True`, returns a single record if only one record matches the filters. Default is `False`.\n            **kwargs: Filters to identify the record(s) to update, supporting advanced comparison operators for refined querying.\n\n        Returns:\n            The updated record(s) as a dictionary or Pydantic model instance or `None`:\n\n            - When `return_as_model=True` and `schema_to_select` is provided: `Optional[SelectSchemaType]`\n            - When `return_as_model=False`: `Optional[Dict[str, Any]]`\n\n        Raises:\n            MultipleResultsFound: If `allow_multiple` is `False` and more than one record matches the filters.\n            NoResultFound: If no record matches the filters. (on version 0.15.3)\n            ValueError: If extra fields not present in the model are provided in the update data.\n            ValueError: If `return_as_model` is `True` but `schema_to_select` is not provided.\n\n        Examples:\n            Update a user's email based on their ID:\n\n            ```python\n            await user_crud.update(db, {'email': 'new_email@example.com'}, id=1)\n            ```\n\n            Update users to be inactive where age is greater than 30 and allow updates to multiple records:\n\n            ```python\n            await user_crud.update(\n                db,\n                {'is_active': False},\n                allow_multiple=True,\n                age__gt=30,\n            )\n            ```\n\n            Update a user's username excluding specific user ID and prevent multiple updates:\n\n            ```python\n            await user_crud.update(\n                db,\n                {'username': 'new_username'},\n                allow_multiple=False,\n                id__ne=1,\n            )\n            ```\n\n            Update a user's email and return the updated record as a Pydantic model instance:\n\n            ```python\n            user = await user_crud.update(\n                db,\n                {'email': 'new_email@example.com'},\n                schema_to_select=ReadUserSchema,\n                return_as_model=True,\n                id=1,\n            )\n            ```\n\n            Update a user's email and return the updated record as a dictionary:\n            ```python\n            user = await user_crud.update(\n                db,\n                {'email': 'new_email@example.com'},\n                return_columns=['id', 'email'],\n                id=1,\n            )\n            ```\n        \"\"\"\n        await validate_update_delete_operation(\n            self.count, db, allow_multiple, \"update\", **kwargs\n        )\n        update_data = prepare_update_data(\n            object, self.model_col_names, self.updated_at_column, self.model\n        )\n\n        filters = self._filter_processor.parse_filters(**kwargs)\n        stmt = update(self.model).filter(*filters).values(update_data)\n\n        if return_as_model:\n            return_columns = self.model_col_names\n\n        return await execute_update_and_return_response(\n            db=db,\n            stmt=stmt,\n            commit=commit,\n            return_columns=return_columns,\n            schema_to_select=schema_to_select,\n            return_as_model=return_as_model,\n            allow_multiple=allow_multiple,\n            one_or_none=one_or_none,\n        )\n\n    async def db_delete(\n        self,\n        db: AsyncSession,\n        allow_multiple: bool = False,\n        commit: bool = True,\n        filters: Optional[DeleteSchemaType] = None,\n        **kwargs: Any,\n    ) -&gt; None:\n        \"\"\"\n        Deletes a record or multiple records from the database based on specified filters.\n\n        For filtering details see [the Advanced Filters documentation](../advanced/crud.md/#advanced-filters)\n\n        Args:\n            db: The database session to use for the operation.\n            allow_multiple: If `True`, allows deleting multiple records that match the filters. If `False`, raises an error if more than one record matches the filters.\n            commit: If `True`, commits the transaction immediately. Default is `True`.\n            filters: Optional Pydantic schema instance containing filters to identify the record(s) to delete.\n            **kwargs: Additional filters to identify the record(s) to delete, including advanced comparison operators for detailed querying.\n\n        Returns:\n            None\n\n        Raises:\n            ValueError: If no filters are provided (to prevent accidental deletion of all records).\n            MultipleResultsFound: If `allow_multiple` is `False` and more than one record matches the filters.\n\n        Examples:\n            Delete a user based on their ID using kwargs:\n\n            ```python\n            await user_crud.db_delete(db, id=1)\n            ```\n\n            Delete a user using a Pydantic schema:\n\n            ```python\n            delete_filters = DeleteUserSchema(id=1)\n            await user_crud.db_delete(db, filters=delete_filters)\n            ```\n\n            Delete users older than 30 years and allow deletion of multiple records:\n\n            ```python\n            await user_crud.db_delete(\n                db,\n                allow_multiple=True,\n                age__gt=30,\n            )\n            ```\n\n            Delete a user with a specific username, ensuring only one record is deleted:\n\n            ```python\n            await user_crud.db_delete(\n                db,\n                allow_multiple=False,\n                username='unique_username',\n            )\n            ```\n\n            Combine schema filters with kwargs:\n\n            ```python\n            delete_filters = DeleteUserSchema(status='inactive')\n            await user_crud.db_delete(\n                db,\n                filters=delete_filters,\n                allow_multiple=True,\n                created_at__lt=datetime(2020, 1, 1),\n            )\n            ```\n        \"\"\"\n        combined_filters = {}\n        if filters:\n            combined_filters.update(filters.model_dump(exclude_unset=True))\n        combined_filters.update(kwargs)\n\n        if not combined_filters:\n            raise ValueError(\n                \"No filters provided. To prevent accidental deletion of all records, at least one filter must be specified.\"\n            )\n\n        if (\n            not allow_multiple\n            and (total_count := await self.count(db, **combined_filters)) &gt; 1\n        ):\n            raise MultipleResultsFound(\n                f\"Expected exactly one record to delete, found {total_count}.\"\n            )\n\n        parsed_filters = self._filter_processor.parse_filters(**combined_filters)\n        stmt = delete(self.model).filter(*parsed_filters)\n        await db.execute(stmt)\n        if commit:\n            await db.commit()\n\n    async def delete(\n        self,\n        db: AsyncSession,\n        db_row: Optional[Row] = None,\n        allow_multiple: bool = False,\n        commit: bool = True,\n        filters: Optional[DeleteSchemaType] = None,\n        **kwargs: Any,\n    ) -&gt; None:\n        \"\"\"\n        Soft deletes a record or optionally multiple records if it has an `\"is_deleted\"` attribute, otherwise performs a hard delete, based on specified filters.\n\n        For filtering details see [the Advanced Filters documentation](../advanced/crud.md/#advanced-filters)\n\n        Args:\n            db: The database session to use for the operation.\n            db_row: Optional existing database row to delete. If provided, the method will attempt to delete this specific row, ignoring other filters.\n            allow_multiple: If `True`, allows deleting multiple records that match the filters. If `False`, raises an error if more than one record matches the filters.\n            commit: If `True`, commits the transaction immediately. Default is `True`.\n            filters: Optional Pydantic schema instance containing filters to identify the record(s) to delete.\n            **kwargs: Additional filters to identify the record(s) to delete, supporting advanced comparison operators for refined querying.\n\n        Raises:\n            ValueError: If no filters are provided and db_row is None (to prevent accidental deletion of all records).\n            MultipleResultsFound: If `allow_multiple` is `False` and more than one record matches the filters.\n            NoResultFound: If no record matches the filters.\n\n        Returns:\n            None\n\n        Examples:\n            Soft delete a specific user by ID using kwargs:\n\n            ```python\n            await user_crud.delete(db, id=1)\n            ```\n\n            Soft delete a user using a Pydantic schema:\n\n            ```python\n            delete_filters = DeleteUserSchema(id=1)\n            await user_crud.delete(db, filters=delete_filters)\n            ```\n\n            Soft delete users with account registration dates before 2020, allowing deletion of multiple records:\n\n            ```python\n            await user_crud.delete(\n                db,\n                allow_multiple=True,\n                creation_date__lt=datetime(2020, 1, 1),\n            )\n            ```\n\n            Soft delete a user with a specific email, ensuring only one record is deleted:\n\n            ```python\n            await user_crud.delete(\n                db,\n                allow_multiple=False,\n                email='unique@example.com',\n            )\n            ```\n\n            Combine schema filters with kwargs:\n\n            ```python\n            delete_filters = DeleteUserSchema(status='inactive')\n            await user_crud.delete(\n                db,\n                filters=delete_filters,\n                allow_multiple=True,\n                last_login__lt=datetime(2023, 1, 1),\n            )\n            ```\n        \"\"\"\n        combined_filters = {}\n        if filters:\n            combined_filters.update(filters.model_dump(exclude_unset=True))\n        combined_filters.update(kwargs)\n\n        if db_row:\n            has_soft_delete = hasattr(db_row, self.is_deleted_column) and hasattr(\n                db_row, self.deleted_at_column\n            )\n            if has_soft_delete:\n                setattr(db_row, self.is_deleted_column, True)\n                setattr(db_row, self.deleted_at_column, datetime.now(timezone.utc))\n            else:\n                await db.delete(db_row)\n            if commit:\n                await db.commit()\n            return\n\n        if not combined_filters:\n            raise ValueError(\n                \"No filters provided. To prevent accidental deletion of all records, at least one filter must be specified.\"\n            )\n\n        await validate_update_delete_operation(\n            self.count, db, allow_multiple, \"delete\", **combined_filters\n        )\n\n        parsed_filters = self._filter_processor.parse_filters(**combined_filters)\n\n        update_values: dict[str, Union[bool, datetime]] = {}\n        if self.deleted_at_column in self.model_col_names:\n            update_values[self.deleted_at_column] = datetime.now(timezone.utc)\n        if self.is_deleted_column in self.model_col_names:\n            update_values[self.is_deleted_column] = True\n\n        if update_values:\n            update_stmt = (\n                update(self.model).filter(*parsed_filters).values(**update_values)\n            )\n            await db.execute(update_stmt)\n\n        else:\n            delete_stmt = self.model.__table__.delete().where(*parsed_filters)\n            await db.execute(delete_stmt)\n        if commit:\n            await db.commit()\n</code></pre>"},{"location":"api/fastcrud/#fastcrud.FastCRUD.count","title":"<code>count(db, joins_config=None, distinct_on_primary=False, **kwargs)</code>  <code>async</code>","text":"<p>Counts records that match specified filters.</p> <p>For filtering details see the Advanced Filters documentation</p> <p>Can also count records based on a configuration of joins, useful for complex queries involving relationships.</p> <p>Parameters:</p> Name Type Description Default <code>db</code> <code>AsyncSession</code> <p>The database session to use for the operation.</p> required <code>joins_config</code> <code>Optional[list[JoinConfig]]</code> <p>Optional configuration for applying joins in the count query.</p> <code>None</code> <code>distinct_on_primary</code> <code>bool</code> <p>If True, counts only distinct base model rows when using joins. This is particularly useful for one-to-many relationships to avoid inflated counts from multiple joined rows per base row. Defaults to False.</p> <code>False</code> <code>**kwargs</code> <code>Any</code> <p>Filters to apply for the count, including field names for equality checks or with comparison operators for advanced queries.</p> <code>{}</code> <p>Returns:</p> Type Description <code>int</code> <p>The total number of records matching the filter conditions.</p> <p>Examples:</p> <p>Count users by ID:</p> <pre><code>count = await user_crud.count(db, id=1)\n</code></pre> <p>Count users older than 30:</p> <pre><code>count = await user_crud.count(db, age__gt=30)\n</code></pre> <p>Count users with a username other than <code>admin</code>:</p> <pre><code>count = await user_crud.count(db, username__ne='admin')\n</code></pre> <p>Count projects with at least one participant (many-to-many relationship):</p> <pre><code>joins_config = [\n    JoinConfig(\n        model=ProjectsParticipantsAssociation,\n        join_on=Project.id == ProjectsParticipantsAssociation.project_id,\n        join_type=\"inner\",\n    ),\n    JoinConfig(\n        model=Participant,\n        join_on=ProjectsParticipantsAssociation.participant_id == Participant.id,\n        join_type=\"inner\",\n    ),\n]\nproject_crud = FastCRUD(Project)\ncount = await project_crud.count(db, joins_config=joins_config)\n</code></pre> <p>Count projects by a specific participant name (filter applied on a joined model):</p> <pre><code>joins_config = [\n    JoinConfig(\n        model=ProjectsParticipantsAssociation,\n        join_on=Project.id == ProjectsParticipantsAssociation.project_id,\n        join_type=\"inner\",\n    ),\n    JoinConfig(\n        model=Participant,\n        join_on=ProjectsParticipantsAssociation.participant_id == Participant.id,\n        join_type=\"inner\",\n        filters={'name': 'Jane Doe'},\n    ),\n]\ncount = await project_crud.count(db, joins_config=joins_config)\n</code></pre> Source code in <code>fastcrud/crud/fast_crud.py</code> <pre><code>async def count(\n    self,\n    db: AsyncSession,\n    joins_config: Optional[list[JoinConfig]] = None,\n    distinct_on_primary: bool = False,\n    **kwargs: Any,\n) -&gt; int:\n    \"\"\"\n    Counts records that match specified filters.\n\n    For filtering details see [the Advanced Filters documentation](../advanced/crud.md/#advanced-filters)\n\n    Can also count records based on a configuration of joins, useful for complex queries involving relationships.\n\n    Args:\n        db: The database session to use for the operation.\n        joins_config: Optional configuration for applying joins in the count query.\n        distinct_on_primary: If True, counts only distinct base model rows when using joins.\n            This is particularly useful for one-to-many relationships to avoid inflated counts\n            from multiple joined rows per base row. Defaults to False.\n        **kwargs: Filters to apply for the count, including field names for equality checks or with comparison operators for advanced queries.\n\n    Returns:\n        The total number of records matching the filter conditions.\n\n    Examples:\n        Count users by ID:\n\n        ```python\n        count = await user_crud.count(db, id=1)\n        ```\n\n        Count users older than 30:\n\n        ```python\n        count = await user_crud.count(db, age__gt=30)\n        ```\n\n        Count users with a username other than `admin`:\n\n        ```python\n        count = await user_crud.count(db, username__ne='admin')\n        ```\n\n        Count projects with at least one participant (many-to-many relationship):\n\n        ```python\n        joins_config = [\n            JoinConfig(\n                model=ProjectsParticipantsAssociation,\n                join_on=Project.id == ProjectsParticipantsAssociation.project_id,\n                join_type=\"inner\",\n            ),\n            JoinConfig(\n                model=Participant,\n                join_on=ProjectsParticipantsAssociation.participant_id == Participant.id,\n                join_type=\"inner\",\n            ),\n        ]\n        project_crud = FastCRUD(Project)\n        count = await project_crud.count(db, joins_config=joins_config)\n        ```\n\n        Count projects by a specific participant name (filter applied on a joined model):\n\n        ```python\n        joins_config = [\n            JoinConfig(\n                model=ProjectsParticipantsAssociation,\n                join_on=Project.id == ProjectsParticipantsAssociation.project_id,\n                join_type=\"inner\",\n            ),\n            JoinConfig(\n                model=Participant,\n                join_on=ProjectsParticipantsAssociation.participant_id == Participant.id,\n                join_type=\"inner\",\n                filters={'name': 'Jane Doe'},\n            ),\n        ]\n        count = await project_crud.count(db, joins_config=joins_config)\n        ```\n    \"\"\"\n    primary_filters = self._filter_processor.parse_filters(**kwargs)\n\n    if joins_config is not None:\n        primary_keys = list(get_primary_key_names(self.model))\n        if not any(primary_keys):  # pragma: no cover\n            raise ValueError(\n                f\"The model '{self.model.__name__}' does not have a primary key defined, which is required for counting with joins.\"\n            )\n        to_select = [\n            getattr(self.model, pk).label(f\"distinct_{pk}\") for pk in primary_keys\n        ]\n        base_query = select(*to_select)\n        base_query = self._query_builder.prepare_joins(\n            base_query, joins_config, select_joined_columns=False\n        )\n        base_query = self._query_builder.apply_filters(base_query, primary_filters)\n\n        if distinct_on_primary:\n            base_query = base_query.distinct()\n            subquery = base_query.subquery()\n            count_query = select(func.count()).select_from(subquery)\n        else:\n            count_query = select(func.count()).select_from(base_query.subquery())\n    else:\n        count_query = select(func.count()).select_from(self.model)\n        count_query = self._query_builder.apply_filters(\n            count_query, primary_filters\n        )\n\n    total_count: Optional[int] = await db.scalar(count_query)\n    if total_count is None:\n        raise ValueError(\"Could not find the count.\")\n\n    return total_count\n</code></pre>"},{"location":"api/fastcrud/#fastcrud.FastCRUD.create","title":"<code>create(db, object, commit=True, schema_to_select=None, return_as_model=False)</code>  <code>async</code>","text":"<pre><code>create(\n    db: AsyncSession,\n    object: CreateSchemaType,\n    *,\n    commit: bool = True,\n    schema_to_select: type[SelectSchemaType],\n    return_as_model: Literal[True],\n) -&gt; SelectSchemaType\n</code></pre><pre><code>create(\n    db: AsyncSession,\n    object: CreateSchemaType,\n    *,\n    commit: bool = True,\n    schema_to_select: None = None,\n    return_as_model: Literal[False] = False,\n) -&gt; Optional[dict[str, Any]]\n</code></pre><pre><code>create(\n    db: AsyncSession,\n    object: CreateSchemaType,\n    *,\n    commit: bool = True,\n    schema_to_select: Optional[\n        type[SelectSchemaType]\n    ] = None,\n    return_as_model: bool = False,\n) -&gt; Union[\n    ModelType, SelectSchemaType, dict[str, Any], None\n]\n</code></pre> <p>Create a new record in the database.</p> <p>Parameters:</p> Name Type Description Default <code>db</code> <code>AsyncSession</code> <p>The SQLAlchemy async session.</p> required <code>object</code> <code>CreateSchemaType</code> <p>The Pydantic schema containing the data to be saved.</p> required <code>commit</code> <code>bool</code> <p>If <code>True</code>, commits the transaction immediately. Default is <code>True</code>.</p> <code>True</code> <code>schema_to_select</code> <code>Optional[type[SelectSchemaType]]</code> <p>Pydantic schema for selecting specific columns.</p> <code>None</code> <code>return_as_model</code> <code>bool</code> <p>If <code>True</code>, returns data as an instance of <code>schema_to_select</code>.</p> <code>False</code> <p>Returns:</p> Type Description <code>Union[ModelType, SelectSchemaType, dict, None]</code> <p>The created database object, or a Pydantic model if <code>schema_to_select</code> is provided:</p> <code>Union[ModelType, SelectSchemaType, dict, None]</code> <ul> <li>When <code>return_as_model=True</code> and <code>schema_to_select</code> is provided: <code>SelectSchemaType</code></li> </ul> <code>Union[ModelType, SelectSchemaType, dict, None]</code> <ul> <li>When <code>return_as_model=False</code> and <code>schema_to_select</code> is provided: <code>Dict[str, Any]</code></li> </ul> <code>Union[ModelType, SelectSchemaType, dict, None]</code> <ul> <li>When <code>schema_to_select</code> is not provided: <code>ModelType</code> (the raw SQLAlchemy model)</li> </ul> Source code in <code>fastcrud/crud/fast_crud.py</code> <pre><code>async def create(\n    self,\n    db: AsyncSession,\n    object: CreateSchemaType,\n    commit: bool = True,\n    schema_to_select: Optional[type[SelectSchemaType]] = None,\n    return_as_model: bool = False,\n) -&gt; Union[ModelType, SelectSchemaType, dict, None]:\n    \"\"\"\n    Create a new record in the database.\n\n    Args:\n        db: The SQLAlchemy async session.\n        object: The Pydantic schema containing the data to be saved.\n        commit: If `True`, commits the transaction immediately. Default is `True`.\n        schema_to_select: Pydantic schema for selecting specific columns.\n        return_as_model: If `True`, returns data as an instance of `schema_to_select`.\n\n    Returns:\n        The created database object, or a Pydantic model if `schema_to_select` is provided:\n\n        - When `return_as_model=True` and `schema_to_select` is provided: `SelectSchemaType`\n        - When `return_as_model=False` and `schema_to_select` is provided: `Dict[str, Any]`\n        - When `schema_to_select` is not provided: `ModelType` (the raw SQLAlchemy model)\n    \"\"\"\n    if return_as_model and not schema_to_select:\n        raise ValueError(\n            \"schema_to_select must be provided when return_as_model is True.\"\n        )\n\n    object_dict = object.model_dump()\n    db_object: ModelType = self.model(**object_dict)\n    db.add(db_object)\n\n    if commit:\n        await db.commit()\n        await db.refresh(db_object)\n    else:\n        await db.flush()\n        await db.refresh(db_object)\n\n    if schema_to_select:\n        if not self._primary_keys:\n            raise ValueError(\"Cannot fetch created record without a primary key.\")\n\n        pks = {pk.name: getattr(db_object, pk.name) for pk in self._primary_keys}\n        return await self.get(\n            db=db,\n            schema_to_select=schema_to_select,\n            return_as_model=return_as_model,\n            **pks,\n        )\n\n    return db_object\n</code></pre>"},{"location":"api/fastcrud/#fastcrud.FastCRUD.db_delete","title":"<code>db_delete(db, allow_multiple=False, commit=True, filters=None, **kwargs)</code>  <code>async</code>","text":"<p>Deletes a record or multiple records from the database based on specified filters.</p> <p>For filtering details see the Advanced Filters documentation</p> <p>Parameters:</p> Name Type Description Default <code>db</code> <code>AsyncSession</code> <p>The database session to use for the operation.</p> required <code>allow_multiple</code> <code>bool</code> <p>If <code>True</code>, allows deleting multiple records that match the filters. If <code>False</code>, raises an error if more than one record matches the filters.</p> <code>False</code> <code>commit</code> <code>bool</code> <p>If <code>True</code>, commits the transaction immediately. Default is <code>True</code>.</p> <code>True</code> <code>filters</code> <code>Optional[DeleteSchemaType]</code> <p>Optional Pydantic schema instance containing filters to identify the record(s) to delete.</p> <code>None</code> <code>**kwargs</code> <code>Any</code> <p>Additional filters to identify the record(s) to delete, including advanced comparison operators for detailed querying.</p> <code>{}</code> <p>Returns:</p> Type Description <code>None</code> <p>None</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If no filters are provided (to prevent accidental deletion of all records).</p> <code>MultipleResultsFound</code> <p>If <code>allow_multiple</code> is <code>False</code> and more than one record matches the filters.</p> <p>Examples:</p> <p>Delete a user based on their ID using kwargs:</p> <pre><code>await user_crud.db_delete(db, id=1)\n</code></pre> <p>Delete a user using a Pydantic schema:</p> <pre><code>delete_filters = DeleteUserSchema(id=1)\nawait user_crud.db_delete(db, filters=delete_filters)\n</code></pre> <p>Delete users older than 30 years and allow deletion of multiple records:</p> <pre><code>await user_crud.db_delete(\n    db,\n    allow_multiple=True,\n    age__gt=30,\n)\n</code></pre> <p>Delete a user with a specific username, ensuring only one record is deleted:</p> <pre><code>await user_crud.db_delete(\n    db,\n    allow_multiple=False,\n    username='unique_username',\n)\n</code></pre> <p>Combine schema filters with kwargs:</p> <pre><code>delete_filters = DeleteUserSchema(status='inactive')\nawait user_crud.db_delete(\n    db,\n    filters=delete_filters,\n    allow_multiple=True,\n    created_at__lt=datetime(2020, 1, 1),\n)\n</code></pre> Source code in <code>fastcrud/crud/fast_crud.py</code> <pre><code>async def db_delete(\n    self,\n    db: AsyncSession,\n    allow_multiple: bool = False,\n    commit: bool = True,\n    filters: Optional[DeleteSchemaType] = None,\n    **kwargs: Any,\n) -&gt; None:\n    \"\"\"\n    Deletes a record or multiple records from the database based on specified filters.\n\n    For filtering details see [the Advanced Filters documentation](../advanced/crud.md/#advanced-filters)\n\n    Args:\n        db: The database session to use for the operation.\n        allow_multiple: If `True`, allows deleting multiple records that match the filters. If `False`, raises an error if more than one record matches the filters.\n        commit: If `True`, commits the transaction immediately. Default is `True`.\n        filters: Optional Pydantic schema instance containing filters to identify the record(s) to delete.\n        **kwargs: Additional filters to identify the record(s) to delete, including advanced comparison operators for detailed querying.\n\n    Returns:\n        None\n\n    Raises:\n        ValueError: If no filters are provided (to prevent accidental deletion of all records).\n        MultipleResultsFound: If `allow_multiple` is `False` and more than one record matches the filters.\n\n    Examples:\n        Delete a user based on their ID using kwargs:\n\n        ```python\n        await user_crud.db_delete(db, id=1)\n        ```\n\n        Delete a user using a Pydantic schema:\n\n        ```python\n        delete_filters = DeleteUserSchema(id=1)\n        await user_crud.db_delete(db, filters=delete_filters)\n        ```\n\n        Delete users older than 30 years and allow deletion of multiple records:\n\n        ```python\n        await user_crud.db_delete(\n            db,\n            allow_multiple=True,\n            age__gt=30,\n        )\n        ```\n\n        Delete a user with a specific username, ensuring only one record is deleted:\n\n        ```python\n        await user_crud.db_delete(\n            db,\n            allow_multiple=False,\n            username='unique_username',\n        )\n        ```\n\n        Combine schema filters with kwargs:\n\n        ```python\n        delete_filters = DeleteUserSchema(status='inactive')\n        await user_crud.db_delete(\n            db,\n            filters=delete_filters,\n            allow_multiple=True,\n            created_at__lt=datetime(2020, 1, 1),\n        )\n        ```\n    \"\"\"\n    combined_filters = {}\n    if filters:\n        combined_filters.update(filters.model_dump(exclude_unset=True))\n    combined_filters.update(kwargs)\n\n    if not combined_filters:\n        raise ValueError(\n            \"No filters provided. To prevent accidental deletion of all records, at least one filter must be specified.\"\n        )\n\n    if (\n        not allow_multiple\n        and (total_count := await self.count(db, **combined_filters)) &gt; 1\n    ):\n        raise MultipleResultsFound(\n            f\"Expected exactly one record to delete, found {total_count}.\"\n        )\n\n    parsed_filters = self._filter_processor.parse_filters(**combined_filters)\n    stmt = delete(self.model).filter(*parsed_filters)\n    await db.execute(stmt)\n    if commit:\n        await db.commit()\n</code></pre>"},{"location":"api/fastcrud/#fastcrud.FastCRUD.delete","title":"<code>delete(db, db_row=None, allow_multiple=False, commit=True, filters=None, **kwargs)</code>  <code>async</code>","text":"<p>Soft deletes a record or optionally multiple records if it has an <code>\"is_deleted\"</code> attribute, otherwise performs a hard delete, based on specified filters.</p> <p>For filtering details see the Advanced Filters documentation</p> <p>Parameters:</p> Name Type Description Default <code>db</code> <code>AsyncSession</code> <p>The database session to use for the operation.</p> required <code>db_row</code> <code>Optional[Row]</code> <p>Optional existing database row to delete. If provided, the method will attempt to delete this specific row, ignoring other filters.</p> <code>None</code> <code>allow_multiple</code> <code>bool</code> <p>If <code>True</code>, allows deleting multiple records that match the filters. If <code>False</code>, raises an error if more than one record matches the filters.</p> <code>False</code> <code>commit</code> <code>bool</code> <p>If <code>True</code>, commits the transaction immediately. Default is <code>True</code>.</p> <code>True</code> <code>filters</code> <code>Optional[DeleteSchemaType]</code> <p>Optional Pydantic schema instance containing filters to identify the record(s) to delete.</p> <code>None</code> <code>**kwargs</code> <code>Any</code> <p>Additional filters to identify the record(s) to delete, supporting advanced comparison operators for refined querying.</p> <code>{}</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If no filters are provided and db_row is None (to prevent accidental deletion of all records).</p> <code>MultipleResultsFound</code> <p>If <code>allow_multiple</code> is <code>False</code> and more than one record matches the filters.</p> <code>NoResultFound</code> <p>If no record matches the filters.</p> <p>Returns:</p> Type Description <code>None</code> <p>None</p> <p>Examples:</p> <p>Soft delete a specific user by ID using kwargs:</p> <pre><code>await user_crud.delete(db, id=1)\n</code></pre> <p>Soft delete a user using a Pydantic schema:</p> <pre><code>delete_filters = DeleteUserSchema(id=1)\nawait user_crud.delete(db, filters=delete_filters)\n</code></pre> <p>Soft delete users with account registration dates before 2020, allowing deletion of multiple records:</p> <pre><code>await user_crud.delete(\n    db,\n    allow_multiple=True,\n    creation_date__lt=datetime(2020, 1, 1),\n)\n</code></pre> <p>Soft delete a user with a specific email, ensuring only one record is deleted:</p> <pre><code>await user_crud.delete(\n    db,\n    allow_multiple=False,\n    email='unique@example.com',\n)\n</code></pre> <p>Combine schema filters with kwargs:</p> <pre><code>delete_filters = DeleteUserSchema(status='inactive')\nawait user_crud.delete(\n    db,\n    filters=delete_filters,\n    allow_multiple=True,\n    last_login__lt=datetime(2023, 1, 1),\n)\n</code></pre> Source code in <code>fastcrud/crud/fast_crud.py</code> <pre><code>async def delete(\n    self,\n    db: AsyncSession,\n    db_row: Optional[Row] = None,\n    allow_multiple: bool = False,\n    commit: bool = True,\n    filters: Optional[DeleteSchemaType] = None,\n    **kwargs: Any,\n) -&gt; None:\n    \"\"\"\n    Soft deletes a record or optionally multiple records if it has an `\"is_deleted\"` attribute, otherwise performs a hard delete, based on specified filters.\n\n    For filtering details see [the Advanced Filters documentation](../advanced/crud.md/#advanced-filters)\n\n    Args:\n        db: The database session to use for the operation.\n        db_row: Optional existing database row to delete. If provided, the method will attempt to delete this specific row, ignoring other filters.\n        allow_multiple: If `True`, allows deleting multiple records that match the filters. If `False`, raises an error if more than one record matches the filters.\n        commit: If `True`, commits the transaction immediately. Default is `True`.\n        filters: Optional Pydantic schema instance containing filters to identify the record(s) to delete.\n        **kwargs: Additional filters to identify the record(s) to delete, supporting advanced comparison operators for refined querying.\n\n    Raises:\n        ValueError: If no filters are provided and db_row is None (to prevent accidental deletion of all records).\n        MultipleResultsFound: If `allow_multiple` is `False` and more than one record matches the filters.\n        NoResultFound: If no record matches the filters.\n\n    Returns:\n        None\n\n    Examples:\n        Soft delete a specific user by ID using kwargs:\n\n        ```python\n        await user_crud.delete(db, id=1)\n        ```\n\n        Soft delete a user using a Pydantic schema:\n\n        ```python\n        delete_filters = DeleteUserSchema(id=1)\n        await user_crud.delete(db, filters=delete_filters)\n        ```\n\n        Soft delete users with account registration dates before 2020, allowing deletion of multiple records:\n\n        ```python\n        await user_crud.delete(\n            db,\n            allow_multiple=True,\n            creation_date__lt=datetime(2020, 1, 1),\n        )\n        ```\n\n        Soft delete a user with a specific email, ensuring only one record is deleted:\n\n        ```python\n        await user_crud.delete(\n            db,\n            allow_multiple=False,\n            email='unique@example.com',\n        )\n        ```\n\n        Combine schema filters with kwargs:\n\n        ```python\n        delete_filters = DeleteUserSchema(status='inactive')\n        await user_crud.delete(\n            db,\n            filters=delete_filters,\n            allow_multiple=True,\n            last_login__lt=datetime(2023, 1, 1),\n        )\n        ```\n    \"\"\"\n    combined_filters = {}\n    if filters:\n        combined_filters.update(filters.model_dump(exclude_unset=True))\n    combined_filters.update(kwargs)\n\n    if db_row:\n        has_soft_delete = hasattr(db_row, self.is_deleted_column) and hasattr(\n            db_row, self.deleted_at_column\n        )\n        if has_soft_delete:\n            setattr(db_row, self.is_deleted_column, True)\n            setattr(db_row, self.deleted_at_column, datetime.now(timezone.utc))\n        else:\n            await db.delete(db_row)\n        if commit:\n            await db.commit()\n        return\n\n    if not combined_filters:\n        raise ValueError(\n            \"No filters provided. To prevent accidental deletion of all records, at least one filter must be specified.\"\n        )\n\n    await validate_update_delete_operation(\n        self.count, db, allow_multiple, \"delete\", **combined_filters\n    )\n\n    parsed_filters = self._filter_processor.parse_filters(**combined_filters)\n\n    update_values: dict[str, Union[bool, datetime]] = {}\n    if self.deleted_at_column in self.model_col_names:\n        update_values[self.deleted_at_column] = datetime.now(timezone.utc)\n    if self.is_deleted_column in self.model_col_names:\n        update_values[self.is_deleted_column] = True\n\n    if update_values:\n        update_stmt = (\n            update(self.model).filter(*parsed_filters).values(**update_values)\n        )\n        await db.execute(update_stmt)\n\n    else:\n        delete_stmt = self.model.__table__.delete().where(*parsed_filters)\n        await db.execute(delete_stmt)\n    if commit:\n        await db.commit()\n</code></pre>"},{"location":"api/fastcrud/#fastcrud.FastCRUD.exists","title":"<code>exists(db, **kwargs)</code>  <code>async</code>","text":"<p>Checks if any records exist that match the given filter conditions.</p> <p>For filtering details see the Advanced Filters documentation</p> <p>Parameters:</p> Name Type Description Default <code>db</code> <code>AsyncSession</code> <p>The database session to use for the operation.</p> required <code>**kwargs</code> <code>Any</code> <p>Filters to apply to the query, supporting both direct matches and advanced comparison operators for refined search criteria.</p> <code>{}</code> <p>Returns:</p> Type Description <code>bool</code> <p><code>True</code> if at least one record matches the filter conditions, <code>False</code> otherwise.</p> <p>Examples:</p> <p>Check if a user with a specific ID exists:</p> <pre><code>exists = await user_crud.exists(db, id=1)\n</code></pre> <p>Check if any user is older than 30:</p> <pre><code>exists = await user_crud.exists(db, age__gt=30)\n</code></pre> <p>Check if any user was registered before Jan 1, 2020:</p> <pre><code>exists = await user_crud.exists(db, registration_date__lt=datetime(2020, 1, 1))\n</code></pre> <p>Check if a username other than <code>admin</code> exists:</p> <pre><code>exists = await user_crud.exists(db, username__ne='admin')\n</code></pre> Source code in <code>fastcrud/crud/fast_crud.py</code> <pre><code>async def exists(self, db: AsyncSession, **kwargs: Any) -&gt; bool:\n    \"\"\"\n    Checks if any records exist that match the given filter conditions.\n\n    For filtering details see [the Advanced Filters documentation](../advanced/crud.md/#advanced-filters)\n\n    Args:\n        db: The database session to use for the operation.\n        **kwargs: Filters to apply to the query, supporting both direct matches and advanced comparison operators for refined search criteria.\n\n    Returns:\n        `True` if at least one record matches the filter conditions, `False` otherwise.\n\n    Examples:\n        Check if a user with a specific ID exists:\n\n        ```python\n        exists = await user_crud.exists(db, id=1)\n        ```\n\n        Check if any user is older than 30:\n\n        ```python\n        exists = await user_crud.exists(db, age__gt=30)\n        ```\n\n        Check if any user was registered before Jan 1, 2020:\n\n        ```python\n        exists = await user_crud.exists(db, registration_date__lt=datetime(2020, 1, 1))\n        ```\n\n        Check if a username other than `admin` exists:\n\n        ```python\n        exists = await user_crud.exists(db, username__ne='admin')\n        ```\n    \"\"\"\n    filters = self._filter_processor.parse_filters(**kwargs)\n    stmt = select(self.model).filter(*filters).limit(1)\n\n    result = await db.execute(stmt)\n    return result.first() is not None\n</code></pre>"},{"location":"api/fastcrud/#fastcrud.FastCRUD.get","title":"<code>get(db, schema_to_select=None, return_as_model=False, one_or_none=False, **kwargs)</code>  <code>async</code>","text":"<pre><code>get(\n    db: AsyncSession,\n    *,\n    schema_to_select: type[SelectSchemaType],\n    return_as_model: Literal[True],\n    one_or_none: bool = False,\n    **kwargs: Any,\n) -&gt; Optional[SelectSchemaType]\n</code></pre><pre><code>get(\n    db: AsyncSession,\n    *,\n    schema_to_select: None = None,\n    return_as_model: Literal[False] = False,\n    one_or_none: bool = False,\n    **kwargs: Any,\n) -&gt; Optional[dict[str, Any]]\n</code></pre><pre><code>get(\n    db: AsyncSession,\n    *,\n    schema_to_select: Optional[\n        type[SelectSchemaType]\n    ] = None,\n    return_as_model: bool = False,\n    one_or_none: bool = False,\n    **kwargs: Any,\n) -&gt; Optional[Union[dict[str, Any], SelectSchemaType]]\n</code></pre> <p>Fetches a single record based on specified filters.</p> <p>This method allows for advanced filtering through comparison operators, enabling queries to be refined beyond simple equality checks.</p> <p>For filtering details see the Advanced Filters documentation</p> <p>Parameters:</p> Name Type Description Default <code>db</code> <code>AsyncSession</code> <p>The database session to use for the operation.</p> required <code>schema_to_select</code> <code>Optional[type[SelectSchemaType]]</code> <p>Optional Pydantic schema for selecting specific columns.</p> <code>None</code> <code>return_as_model</code> <code>bool</code> <p>If <code>True</code>, converts the fetched data to Pydantic models based on <code>schema_to_select</code>. Defaults to <code>False</code>.</p> <code>False</code> <code>one_or_none</code> <code>bool</code> <p>Flag to get strictly one or no result. Multiple results are not allowed.</p> <code>False</code> <code>**kwargs</code> <code>Any</code> <p>Filters to apply to the query, using field names for direct matches or appending comparison operators for advanced queries.</p> <code>{}</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If <code>return_as_model</code> is <code>True</code> but <code>schema_to_select</code> is not provided.</p> <p>Returns:</p> Type Description <code>Optional[Union[dict[str, Any], SelectSchemaType]]</code> <p>A dictionary or a Pydantic model instance of the fetched database row, or <code>None</code> if no match is found:</p> <code>Optional[Union[dict[str, Any], SelectSchemaType]]</code> <ul> <li>When <code>return_as_model=True</code> and <code>schema_to_select</code> is provided: <code>Optional[SelectSchemaType]</code></li> </ul> <code>Optional[Union[dict[str, Any], SelectSchemaType]]</code> <ul> <li>When <code>return_as_model=False</code>: <code>Optional[Dict[str, Any]]</code></li> </ul> <p>Examples:</p> <p>Fetch a user by ID:</p> <pre><code>user = await user_crud.get(db, id=1)\n</code></pre> <p>Fetch a user with an age greater than 30:</p> <pre><code>user = await user_crud.get(db, age__gt=30)\n</code></pre> <p>Fetch a user with a registration date before Jan 1, 2020:</p> <pre><code>user = await user_crud.get(db, registration_date__lt=datetime(2020, 1, 1))\n</code></pre> <p>Fetch a user not equal to a specific username:</p> <pre><code>user = await user_crud.get(db, username__ne='admin')\n</code></pre> Source code in <code>fastcrud/crud/fast_crud.py</code> <pre><code>async def get(\n    self,\n    db: AsyncSession,\n    schema_to_select: Optional[type[SelectSchemaType]] = None,\n    return_as_model: bool = False,\n    one_or_none: bool = False,\n    **kwargs: Any,\n) -&gt; Optional[Union[dict[str, Any], SelectSchemaType]]:\n    \"\"\"\n    Fetches a single record based on specified filters.\n\n    This method allows for advanced filtering through comparison operators, enabling queries to be refined beyond simple equality checks.\n\n    For filtering details see [the Advanced Filters documentation](../advanced/crud.md/#advanced-filters)\n\n    Args:\n        db: The database session to use for the operation.\n        schema_to_select: Optional Pydantic schema for selecting specific columns.\n        return_as_model: If `True`, converts the fetched data to Pydantic models based on `schema_to_select`. Defaults to `False`.\n        one_or_none: Flag to get strictly one or no result. Multiple results are not allowed.\n        **kwargs: Filters to apply to the query, using field names for direct matches or appending comparison operators for advanced queries.\n\n    Raises:\n        ValueError: If `return_as_model` is `True` but `schema_to_select` is not provided.\n\n    Returns:\n        A dictionary or a Pydantic model instance of the fetched database row, or `None` if no match is found:\n\n        - When `return_as_model=True` and `schema_to_select` is provided: `Optional[SelectSchemaType]`\n        - When `return_as_model=False`: `Optional[Dict[str, Any]]`\n\n    Examples:\n        Fetch a user by ID:\n\n        ```python\n        user = await user_crud.get(db, id=1)\n        ```\n\n        Fetch a user with an age greater than 30:\n\n        ```python\n        user = await user_crud.get(db, age__gt=30)\n        ```\n\n        Fetch a user with a registration date before Jan 1, 2020:\n\n        ```python\n        user = await user_crud.get(db, registration_date__lt=datetime(2020, 1, 1))\n        ```\n\n        Fetch a user not equal to a specific username:\n\n        ```python\n        user = await user_crud.get(db, username__ne='admin')\n        ```\n    \"\"\"\n    stmt = await self.select(schema_to_select=schema_to_select, **kwargs)\n\n    db_row = await db.execute(stmt)\n    result: Optional[Row] = db_row.one_or_none() if one_or_none else db_row.first()\n    if result is None:\n        return None\n    out: dict = dict(result._mapping)\n    if not return_as_model:\n        return out\n    if not schema_to_select:\n        raise ValueError(\n            \"schema_to_select must be provided when return_as_model is True.\"\n        )\n    return schema_to_select(**out)\n</code></pre>"},{"location":"api/fastcrud/#fastcrud.FastCRUD.get_joined","title":"<code>get_joined(db, schema_to_select=None, join_model=None, join_on=None, join_prefix=None, join_schema_to_select=None, join_type='left', alias=None, join_filters=None, joins_config=None, nest_joins=False, relationship_type=None, **kwargs)</code>  <code>async</code>","text":"<p>Fetches a single record with one or multiple joins on other models. If <code>join_on</code> is not provided, the method attempts to automatically detect the join condition using foreign key relationships. For multiple joins, use <code>joins_config</code> to specify each join configuration.</p> <p>For filtering details see the Advanced Filters documentation</p> <p>Parameters:</p> Name Type Description Default <code>db</code> <code>AsyncSession</code> <p>The SQLAlchemy async session.</p> required <code>schema_to_select</code> <code>Optional[type[SelectSchemaType]]</code> <p>Pydantic schema for selecting specific columns from the primary model. Required if <code>return_as_model</code> is True.</p> <code>None</code> <code>join_model</code> <code>Optional[ModelType]</code> <p>The model to join with.</p> <code>None</code> <code>join_on</code> <code>Optional[Union[Join, BinaryExpression]]</code> <p>SQLAlchemy Join object for specifying the <code>ON</code> clause of the join. If <code>None</code>, the join condition is auto-detected based on foreign keys.</p> <code>None</code> <code>join_prefix</code> <code>Optional[str]</code> <p>Optional prefix to be added to all columns of the joined model. If <code>None</code>, no prefix is added.</p> <code>None</code> <code>join_schema_to_select</code> <code>Optional[type[SelectSchemaType]]</code> <p>Pydantic schema for selecting specific columns from the joined model.</p> <code>None</code> <code>join_type</code> <code>str</code> <p>Specifies the type of join operation to perform. Can be <code>\"left\"</code> for a left outer join or <code>\"inner\"</code> for an inner join.</p> <code>'left'</code> <code>alias</code> <code>Optional[AliasedClass]</code> <p>An instance of <code>AliasedClass</code> for the join model, useful for self-joins or multiple joins on the same model. Result of <code>aliased(join_model)</code>.</p> <code>None</code> <code>join_filters</code> <code>Optional[dict]</code> <p>Filters applied to the joined model, specified as a dictionary mapping column names to their expected values.</p> <code>None</code> <code>joins_config</code> <code>Optional[list[JoinConfig]]</code> <p>A list of <code>JoinConfig</code> instances, each specifying a model to join with, join condition, optional prefix for column names, schema for selecting specific columns, and the type of join. This parameter enables support for multiple joins.</p> <code>None</code> <code>nest_joins</code> <code>bool</code> <p>If <code>True</code>, nested data structures will be returned where joined model data are nested under the <code>join_prefix</code> as a dictionary.</p> <code>False</code> <code>relationship_type</code> <code>Optional[str]</code> <p>Specifies the relationship type, such as <code>\"one-to-one\"</code> or <code>\"one-to-many\"</code>. Used to determine how to nest the joined data. If <code>None</code>, uses <code>\"one-to-one\"</code>.</p> <code>None</code> <code>**kwargs</code> <code>Any</code> <p>Filters to apply to the primary model query, supporting advanced comparison operators for refined searching.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Optional[dict[str, Any]]</code> <p>A dictionary representing the joined record, or <code>None</code> if no record matches the criteria.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If both single join parameters and <code>joins_config</code> are used simultaneously.</p> <code>ArgumentError</code> <p>If any provided model in <code>joins_config</code> is not recognized or invalid.</p> <code>NoResultFound</code> <p>If no record matches the criteria with the provided filters.</p> <p>Examples:</p> <p>Simple example: Joining <code>User</code> and <code>Tier</code> models without explicitly providing <code>join_on</code></p> <pre><code>result = await user_crud.get_joined(\n    db=session,\n    schema_to_select=ReadUserSchema,\n    join_model=Tier,\n    join_schema_to_select=ReadTierSchema,\n)\n</code></pre> <p>Fetch a user and their associated tier, filtering by user ID:</p> <pre><code>result = await user_crud.get_joined(\n    db,\n    schema_to_select=ReadUserSchema,\n    join_model=Tier,\n    join_schema_to_select=ReadTierSchema,\n    id=1,\n)\n</code></pre> <p>Fetch a user and their associated tier, where the user's age is greater than 30:</p> <pre><code>result = await user_crud.get_joined(\n    db,\n    schema_to_select=ReadUserSchema,\n    join_model=Tier,\n    join_schema_to_select=ReadTierSchema,\n    age__gt=30,\n)\n</code></pre> <p>Fetch a user and their associated tier, excluding users with the <code>admin</code> username:</p> <pre><code>result = await user_crud.get_joined(\n    db,\n    schema_to_select=ReadUserSchema,\n    join_model=Tier,\n    join_schema_to_select=ReadTierSchema,\n    username__ne='admin',\n)\n</code></pre> <p>Complex example: Joining with a custom join condition, additional filter parameters, and a prefix</p> <pre><code>from sqlalchemy import and_\nresult = await user_crud.get_joined(\n    db=session,\n    schema_to_select=ReadUserSchema,\n    join_model=Tier,\n    join_on=and_(User.tier_id == Tier.id, User.is_superuser == True),\n    join_prefix=\"tier_\",\n    join_schema_to_select=ReadTierSchema,\n    username=\"john_doe\",\n)\n</code></pre> <p>Example of using <code>joins_config</code> for multiple joins:</p> <pre><code>from fastcrud import JoinConfig\n\n# Using same User/Tier/Department models/schemas as above.\n\nresult = await user_crud.get_joined(\n    db=session,\n    schema_to_select=ReadUserSchema,\n    joins_config=[\n        JoinConfig(\n            model=Tier,\n            join_on=User.tier_id == Tier.id,\n            join_prefix=\"tier_\",\n            schema_to_select=ReadTierSchema,\n            join_type=\"left\",\n        ),\n        JoinConfig(\n            model=Department,\n            join_on=User.department_id == Department.id,\n            join_prefix=\"dept_\",\n            schema_to_select=ReadDepartmentSchema,\n            join_type=\"inner\",\n        ),\n    ],\n)\n</code></pre> <p>Using <code>alias</code> for joining the same model multiple times: <pre><code>from fastcrud import aliased\n\nowner_alias = aliased(ModelTest, name=\"owner\")\nuser_alias = aliased(ModelTest, name=\"user\")\n\nresult = await crud.get_joined(\n    db=session,\n    schema_to_select=BookingSchema,\n    joins_config=[\n        JoinConfig(\n            model=ModelTest,\n            join_on=BookingModel.owner_id == owner_alias.id,\n            join_prefix=\"owner_\",\n            alias=owner_alias,\n            schema_to_select=UserSchema,\n        ),\n        JoinConfig(\n            model=ModelTest,\n            join_on=BookingModel.user_id == user_alias.id,\n            join_prefix=\"user_\",\n            alias=user_alias,\n            schema_to_select=UserSchema,\n        ),\n    ],\n    id=1,\n)\n</code></pre></p> <p>Fetching a single project and its associated participants where a participant has a specific role:</p> <pre><code>joins_config = [\n    JoinConfig(\n        model=ProjectsParticipantsAssociation,\n        join_on=Project.id == ProjectsParticipantsAssociation.project_id,\n        join_type=\"inner\",\n    ),\n    JoinConfig(\n        model=Participant,\n        join_on=ProjectsParticipantsAssociation.participant_id == Participant.id,\n        join_type=\"inner\",\n        filters={'role': 'Designer'},\n    ),\n]\n\nproject_crud = FastCRUD(Project)\n\nproject = await project_crud.get_joined(\n    db=session,\n    schema_to_select=ReadProjectSchema,\n    joins_config=joins_config,\n)\n</code></pre> <p>Example of using <code>joins_config</code> for multiple joins with nested joins enabled:</p> <pre><code>from fastcrud import JoinConfig\n\nresult = await user_crud.get_joined(\n    db=session,\n    schema_to_select=ReadUserSchema,\n    joins_config=[\n        JoinConfig(\n            model=Tier,\n            join_on=User.tier_id == Tier.id,\n            join_prefix=\"tier_\",\n            schema_to_select=ReadTierSchema,\n            join_type=\"left\",\n        ),\n        JoinConfig(\n            model=Department,\n            join_on=User.department_id == Department.id,\n            join_prefix=\"dept_\",\n            schema_to_select=ReadDepartmentSchema,\n            join_type=\"inner\",\n        ),\n    ],\n    nest_joins=True,\n)\n# Expect 'result' to have 'tier' and 'dept' as nested dictionaries\n</code></pre> <p>Example using one-to-one relationship:</p> <pre><code>author_crud = FastCRUD(Author)\nresult = await author_crud.get_joined(\n    db=session,\n    schema_to_select=ReadAuthorSchema,\n    join_model=Profile,\n    join_on=Author.profile_id == Profile.id,\n    join_schema_to_select=ReadProfileSchema,\n    nest_joins=True,\n    relationship_type='one-to-one', # note that this is the default behavior\n)\n# Expect 'result' to have 'profile' as a nested dictionary\n</code></pre> <p>Example using one-to-many relationship:</p> <pre><code>result = await author_crud.get_joined(\n    db=session,\n    schema_to_select=ReadAuthorSchema,\n    join_model=Article,\n    join_on=Author.id == Article.author_id,\n    join_schema_to_select=ReadArticleSchema,\n    nest_joins=True,\n    relationship_type='one-to-many',\n)\n# Expect 'result' to have 'posts' as a nested list of dictionaries\n</code></pre> Source code in <code>fastcrud/crud/fast_crud.py</code> <pre><code>async def get_joined(\n    self,\n    db: AsyncSession,\n    schema_to_select: Optional[type[SelectSchemaType]] = None,\n    join_model: Optional[ModelType] = None,\n    join_on: Optional[Union[Join, BinaryExpression]] = None,\n    join_prefix: Optional[str] = None,\n    join_schema_to_select: Optional[type[SelectSchemaType]] = None,\n    join_type: str = \"left\",\n    alias: Optional[AliasedClass] = None,\n    join_filters: Optional[dict] = None,\n    joins_config: Optional[list[JoinConfig]] = None,\n    nest_joins: bool = False,\n    relationship_type: Optional[str] = None,\n    **kwargs: Any,\n) -&gt; Optional[dict[str, Any]]:\n    \"\"\"\n    Fetches a single record with one or multiple joins on other models. If `join_on` is not provided, the method attempts\n    to automatically detect the join condition using foreign key relationships. For multiple joins, use `joins_config` to\n    specify each join configuration.\n\n    For filtering details see [the Advanced Filters documentation](../advanced/crud.md/#advanced-filters)\n\n    Args:\n        db: The SQLAlchemy async session.\n        schema_to_select: Pydantic schema for selecting specific columns from the primary model. Required if `return_as_model` is True.\n        join_model: The model to join with.\n        join_on: SQLAlchemy Join object for specifying the `ON` clause of the join. If `None`, the join condition is auto-detected based on foreign keys.\n        join_prefix: Optional prefix to be added to all columns of the joined model. If `None`, no prefix is added.\n        join_schema_to_select: Pydantic schema for selecting specific columns from the joined model.\n        join_type: Specifies the type of join operation to perform. Can be `\"left\"` for a left outer join or `\"inner\"` for an inner join.\n        alias: An instance of `AliasedClass` for the join model, useful for self-joins or multiple joins on the same model. Result of `aliased(join_model)`.\n        join_filters: Filters applied to the joined model, specified as a dictionary mapping column names to their expected values.\n        joins_config: A list of `JoinConfig` instances, each specifying a model to join with, join condition, optional prefix for column names, schema for selecting specific columns, and the type of join. This parameter enables support for multiple joins.\n        nest_joins: If `True`, nested data structures will be returned where joined model data are nested under the `join_prefix` as a dictionary.\n        relationship_type: Specifies the relationship type, such as `\"one-to-one\"` or `\"one-to-many\"`. Used to determine how to nest the joined data. If `None`, uses `\"one-to-one\"`.\n        **kwargs: Filters to apply to the primary model query, supporting advanced comparison operators for refined searching.\n\n    Returns:\n        A dictionary representing the joined record, or `None` if no record matches the criteria.\n\n    Raises:\n        ValueError: If both single join parameters and `joins_config` are used simultaneously.\n        ArgumentError: If any provided model in `joins_config` is not recognized or invalid.\n        NoResultFound: If no record matches the criteria with the provided filters.\n\n    Examples:\n        Simple example: Joining `User` and `Tier` models without explicitly providing `join_on`\n\n        ```python\n        result = await user_crud.get_joined(\n            db=session,\n            schema_to_select=ReadUserSchema,\n            join_model=Tier,\n            join_schema_to_select=ReadTierSchema,\n        )\n        ```\n\n        Fetch a user and their associated tier, filtering by user ID:\n\n        ```python\n        result = await user_crud.get_joined(\n            db,\n            schema_to_select=ReadUserSchema,\n            join_model=Tier,\n            join_schema_to_select=ReadTierSchema,\n            id=1,\n        )\n        ```\n\n        Fetch a user and their associated tier, where the user's age is greater than 30:\n\n        ```python\n        result = await user_crud.get_joined(\n            db,\n            schema_to_select=ReadUserSchema,\n            join_model=Tier,\n            join_schema_to_select=ReadTierSchema,\n            age__gt=30,\n        )\n        ```\n\n        Fetch a user and their associated tier, excluding users with the `admin` username:\n\n        ```python\n        result = await user_crud.get_joined(\n            db,\n            schema_to_select=ReadUserSchema,\n            join_model=Tier,\n            join_schema_to_select=ReadTierSchema,\n            username__ne='admin',\n        )\n        ```\n\n        Complex example: Joining with a custom join condition, additional filter parameters, and a prefix\n\n        ```python\n        from sqlalchemy import and_\n        result = await user_crud.get_joined(\n            db=session,\n            schema_to_select=ReadUserSchema,\n            join_model=Tier,\n            join_on=and_(User.tier_id == Tier.id, User.is_superuser == True),\n            join_prefix=\"tier_\",\n            join_schema_to_select=ReadTierSchema,\n            username=\"john_doe\",\n        )\n        ```\n\n        Example of using `joins_config` for multiple joins:\n\n        ```python\n        from fastcrud import JoinConfig\n\n        # Using same User/Tier/Department models/schemas as above.\n\n        result = await user_crud.get_joined(\n            db=session,\n            schema_to_select=ReadUserSchema,\n            joins_config=[\n                JoinConfig(\n                    model=Tier,\n                    join_on=User.tier_id == Tier.id,\n                    join_prefix=\"tier_\",\n                    schema_to_select=ReadTierSchema,\n                    join_type=\"left\",\n                ),\n                JoinConfig(\n                    model=Department,\n                    join_on=User.department_id == Department.id,\n                    join_prefix=\"dept_\",\n                    schema_to_select=ReadDepartmentSchema,\n                    join_type=\"inner\",\n                ),\n            ],\n        )\n        ```\n\n        Using `alias` for joining the same model multiple times:\n        ```python\n        from fastcrud import aliased\n\n        owner_alias = aliased(ModelTest, name=\"owner\")\n        user_alias = aliased(ModelTest, name=\"user\")\n\n        result = await crud.get_joined(\n            db=session,\n            schema_to_select=BookingSchema,\n            joins_config=[\n                JoinConfig(\n                    model=ModelTest,\n                    join_on=BookingModel.owner_id == owner_alias.id,\n                    join_prefix=\"owner_\",\n                    alias=owner_alias,\n                    schema_to_select=UserSchema,\n                ),\n                JoinConfig(\n                    model=ModelTest,\n                    join_on=BookingModel.user_id == user_alias.id,\n                    join_prefix=\"user_\",\n                    alias=user_alias,\n                    schema_to_select=UserSchema,\n                ),\n            ],\n            id=1,\n        )\n        ```\n\n        Fetching a single project and its associated participants where a participant has a specific role:\n\n        ```python\n        joins_config = [\n            JoinConfig(\n                model=ProjectsParticipantsAssociation,\n                join_on=Project.id == ProjectsParticipantsAssociation.project_id,\n                join_type=\"inner\",\n            ),\n            JoinConfig(\n                model=Participant,\n                join_on=ProjectsParticipantsAssociation.participant_id == Participant.id,\n                join_type=\"inner\",\n                filters={'role': 'Designer'},\n            ),\n        ]\n\n        project_crud = FastCRUD(Project)\n\n        project = await project_crud.get_joined(\n            db=session,\n            schema_to_select=ReadProjectSchema,\n            joins_config=joins_config,\n        )\n        ```\n\n        Example of using `joins_config` for multiple joins with nested joins enabled:\n\n        ```python\n        from fastcrud import JoinConfig\n\n        result = await user_crud.get_joined(\n            db=session,\n            schema_to_select=ReadUserSchema,\n            joins_config=[\n                JoinConfig(\n                    model=Tier,\n                    join_on=User.tier_id == Tier.id,\n                    join_prefix=\"tier_\",\n                    schema_to_select=ReadTierSchema,\n                    join_type=\"left\",\n                ),\n                JoinConfig(\n                    model=Department,\n                    join_on=User.department_id == Department.id,\n                    join_prefix=\"dept_\",\n                    schema_to_select=ReadDepartmentSchema,\n                    join_type=\"inner\",\n                ),\n            ],\n            nest_joins=True,\n        )\n        # Expect 'result' to have 'tier' and 'dept' as nested dictionaries\n        ```\n\n        Example using one-to-one relationship:\n\n        ```python\n        author_crud = FastCRUD(Author)\n        result = await author_crud.get_joined(\n            db=session,\n            schema_to_select=ReadAuthorSchema,\n            join_model=Profile,\n            join_on=Author.profile_id == Profile.id,\n            join_schema_to_select=ReadProfileSchema,\n            nest_joins=True,\n            relationship_type='one-to-one', # note that this is the default behavior\n        )\n        # Expect 'result' to have 'profile' as a nested dictionary\n        ```\n\n        Example using one-to-many relationship:\n\n        ```python\n        result = await author_crud.get_joined(\n            db=session,\n            schema_to_select=ReadAuthorSchema,\n            join_model=Article,\n            join_on=Author.id == Article.author_id,\n            join_schema_to_select=ReadArticleSchema,\n            nest_joins=True,\n            relationship_type='one-to-many',\n        )\n        # Expect 'result' to have 'posts' as a nested list of dictionaries\n        ```\n    \"\"\"\n    if joins_config and (\n        join_model or join_prefix or join_on or join_schema_to_select or alias\n    ):\n        raise ValueError(\n            \"Cannot use both single join parameters and joins_config simultaneously.\"\n        )\n    elif not joins_config and not join_model:\n        raise ValueError(\"You need one of join_model or joins_config.\")\n\n    primary_select = extract_matching_columns_from_schema(\n        model=self.model,\n        schema=schema_to_select,\n    )\n    stmt = self._query_builder.build_base_select(primary_select)\n\n    join_definitions = joins_config if joins_config else []\n    if join_model:\n        join_definitions.append(\n            JoinConfig(\n                model=join_model,\n                join_on=join_on\n                if join_on is not None\n                else auto_detect_join_condition(self.model, join_model),\n                join_prefix=join_prefix,\n                schema_to_select=join_schema_to_select,\n                join_type=join_type,\n                alias=alias,\n                filters=join_filters,\n                relationship_type=relationship_type,\n            )\n        )\n\n    stmt = self._query_builder.prepare_joins(\n        stmt=stmt, joins_config=join_definitions, use_temporary_prefix=nest_joins\n    )\n    primary_filters = self._filter_processor.parse_filters(**kwargs)\n    stmt = self._query_builder.apply_filters(stmt, primary_filters)\n\n    db_rows = await db.execute(stmt)\n    if any(join.relationship_type == \"one-to-many\" for join in join_definitions):\n        if nest_joins is False:  # pragma: no cover\n            raise ValueError(\n                \"Cannot use one-to-many relationship with nest_joins=False\"\n            )\n        results = db_rows.fetchall()\n        data_list = [dict(row._mapping) for row in results]\n    else:\n        result = db_rows.first()\n        if result is not None:\n            data_list = [dict(result._mapping)]\n        else:\n            data_list = []\n\n    return process_joined_data(data_list, join_definitions, nest_joins, self.model)\n</code></pre>"},{"location":"api/fastcrud/#fastcrud.FastCRUD.get_multi","title":"<code>get_multi(db, offset=0, limit=100, schema_to_select=None, sort_columns=None, sort_orders=None, return_as_model=False, return_total_count=True, **kwargs)</code>  <code>async</code>","text":"<pre><code>get_multi(\n    db: AsyncSession,\n    *,\n    offset: int = 0,\n    limit: Optional[int] = 100,\n    schema_to_select: type[SelectSchemaType],\n    sort_columns: Optional[Union[str, list[str]]] = None,\n    sort_orders: Optional[Union[str, list[str]]] = None,\n    return_as_model: Literal[True],\n    return_total_count: bool = True,\n    **kwargs: Any,\n) -&gt; GetMultiResponseModel[SelectSchemaType]\n</code></pre><pre><code>get_multi(\n    db: AsyncSession,\n    *,\n    offset: int = 0,\n    limit: Optional[int] = 100,\n    schema_to_select: None = None,\n    sort_columns: Optional[Union[str, list[str]]] = None,\n    sort_orders: Optional[Union[str, list[str]]] = None,\n    return_as_model: Literal[False] = False,\n    return_total_count: bool = True,\n    **kwargs: Any,\n) -&gt; GetMultiResponseDict\n</code></pre><pre><code>get_multi(\n    db: AsyncSession,\n    *,\n    offset: int = 0,\n    limit: Optional[int] = 100,\n    schema_to_select: Optional[\n        type[SelectSchemaType]\n    ] = None,\n    sort_columns: Optional[Union[str, list[str]]] = None,\n    sort_orders: Optional[Union[str, list[str]]] = None,\n    return_as_model: bool = False,\n    return_total_count: bool = True,\n    **kwargs: Any,\n) -&gt; Union[\n    GetMultiResponseModel[SelectSchemaType],\n    GetMultiResponseDict,\n]\n</code></pre> <p>Fetches multiple records based on filters, supporting sorting, pagination.</p> <p>For filtering details see the Advanced Filters documentation</p> <p>Parameters:</p> Name Type Description Default <code>db</code> <code>AsyncSession</code> <p>The database session to use for the operation.</p> required <code>offset</code> <code>int</code> <p>Starting index for records to fetch, useful for pagination.</p> <code>0</code> <code>limit</code> <code>Optional[int]</code> <p>Maximum number of records to fetch in one call. Use <code>None</code> for \"no limit\", fetching all matching rows. Note that in order to use <code>limit=None</code>, you'll have to provide a custom endpoint to facilitate it, which you should only do if you really seriously want to allow the user to get all the data at once.</p> <code>100</code> <code>schema_to_select</code> <code>Optional[type[SelectSchemaType]]</code> <p>Optional Pydantic schema for selecting specific columns. Required if <code>return_as_model</code> is True.</p> <code>None</code> <code>sort_columns</code> <code>Optional[Union[str, list[str]]]</code> <p>Column names to sort the results by.</p> <code>None</code> <code>sort_orders</code> <code>Optional[Union[str, list[str]]]</code> <p>Corresponding sort orders (<code>\"asc\"</code>, <code>\"desc\"</code>) for each column in <code>sort_columns</code>.</p> <code>None</code> <code>return_as_model</code> <code>bool</code> <p>If <code>True</code>, returns data as instances of the specified Pydantic model.</p> <code>False</code> <code>return_total_count</code> <code>bool</code> <p>If <code>True</code>, also returns the total count of rows with the selected filters. Useful for pagination.</p> <code>True</code> <code>**kwargs</code> <code>Any</code> <p>Filters to apply to the query, including advanced comparison operators for more detailed querying.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Union[GetMultiResponseModel[SelectSchemaType], GetMultiResponseDict]</code> <p>A dictionary containing the data list and optionally the total count:</p> <code>Union[GetMultiResponseModel[SelectSchemaType], GetMultiResponseDict]</code> <ul> <li>With return_as_model=True: Dict with \"data\": List[SelectSchemaType]</li> </ul> <code>Union[GetMultiResponseModel[SelectSchemaType], GetMultiResponseDict]</code> <ul> <li>With return_as_model=False: Dict with \"data\": List[Dict[str, Any]]</li> </ul> <code>Union[GetMultiResponseModel[SelectSchemaType], GetMultiResponseDict]</code> <ul> <li>If return_total_count=True, includes \"total_count\": int</li> </ul> <p>Raises:</p> Type Description <code>ValueError</code> <p>If <code>limit</code> or <code>offset</code> is negative, or if <code>schema_to_select</code> is required but not provided or invalid.</p> <p>Examples:</p> <p>Fetch the first 10 users:</p> <pre><code>users = await user_crud.get_multi(\n    db,\n    0,\n    10,\n)\n</code></pre> <p>Fetch next 10 users with sorted by username:</p> <pre><code>users = await user_crud.get_multi(\n    db,\n    10,\n    10,\n    sort_columns='username',\n    sort_orders='desc',\n)\n</code></pre> <p>Fetch 10 users older than 30, sorted by age in descending order:</p> <pre><code>users = await user_crud.get_multi(\n    db,\n    offset=0,\n    limit=10,\n    sort_columns='age',\n    sort_orders='desc',\n    age__gt=30,\n)\n</code></pre> <p>Fetch 10 users with a registration date before Jan 1, 2020: <pre><code>users = await user_crud.get_multi(\n    db,\n    offset=0,\n    limit=10,\n    registration_date__lt=datetime(2020, 1, 1),\n)\n</code></pre></p> <p>Fetch 10 users with a username other than <code>admin</code>, returning as model instances (ensure appropriate schema is passed):</p> <pre><code>users = await user_crud.get_multi(\n    db,\n    offset=0,\n    limit=10,\n    schema_to_select=ReadUserSchema,\n    return_as_model=True,\n    username__ne='admin',\n)\n</code></pre> <p>Fetch users with filtering and multiple column sorting:</p> <pre><code>users = await user_crud.get_multi(\n    db,\n    0,\n    10,\n    sort_columns=['username', 'email'],\n    sort_orders=['asc', 'desc'],\n    is_active=True,\n)\n</code></pre> Source code in <code>fastcrud/crud/fast_crud.py</code> <pre><code>async def get_multi(\n    self,\n    db: AsyncSession,\n    offset: int = 0,\n    limit: Optional[int] = 100,\n    schema_to_select: Optional[type[SelectSchemaType]] = None,\n    sort_columns: Optional[Union[str, list[str]]] = None,\n    sort_orders: Optional[Union[str, list[str]]] = None,\n    return_as_model: bool = False,\n    return_total_count: bool = True,\n    **kwargs: Any,\n) -&gt; Union[GetMultiResponseModel[SelectSchemaType], GetMultiResponseDict]:\n    \"\"\"\n    Fetches multiple records based on filters, supporting sorting, pagination.\n\n    For filtering details see [the Advanced Filters documentation](../advanced/crud.md/#advanced-filters)\n\n    Args:\n        db: The database session to use for the operation.\n        offset: Starting index for records to fetch, useful for pagination.\n        limit: Maximum number of records to fetch in one call. Use `None` for \"no limit\", fetching all matching rows. Note that in order to use `limit=None`, you'll have to provide a custom endpoint to facilitate it, which you should only do if you really seriously want to allow the user to get all the data at once.\n        schema_to_select: Optional Pydantic schema for selecting specific columns. Required if `return_as_model` is True.\n        sort_columns: Column names to sort the results by.\n        sort_orders: Corresponding sort orders (`\"asc\"`, `\"desc\"`) for each column in `sort_columns`.\n        return_as_model: If `True`, returns data as instances of the specified Pydantic model.\n        return_total_count: If `True`, also returns the total count of rows with the selected filters. Useful for pagination.\n        **kwargs: Filters to apply to the query, including advanced comparison operators for more detailed querying.\n\n    Returns:\n        A dictionary containing the data list and optionally the total count:\n        - With return_as_model=True: Dict with \"data\": List[SelectSchemaType]\n        - With return_as_model=False: Dict with \"data\": List[Dict[str, Any]]\n        - If return_total_count=True, includes \"total_count\": int\n\n    Raises:\n        ValueError: If `limit` or `offset` is negative, or if `schema_to_select` is required but not provided or invalid.\n\n    Examples:\n        Fetch the first 10 users:\n\n        ```python\n        users = await user_crud.get_multi(\n            db,\n            0,\n            10,\n        )\n        ```\n\n        Fetch next 10 users with sorted by username:\n\n        ```python\n        users = await user_crud.get_multi(\n            db,\n            10,\n            10,\n            sort_columns='username',\n            sort_orders='desc',\n        )\n        ```\n\n        Fetch 10 users older than 30, sorted by age in descending order:\n\n        ```python\n        users = await user_crud.get_multi(\n            db,\n            offset=0,\n            limit=10,\n            sort_columns='age',\n            sort_orders='desc',\n            age__gt=30,\n        )\n        ```\n\n        Fetch 10 users with a registration date before Jan 1, 2020:\n        ```python\n        users = await user_crud.get_multi(\n            db,\n            offset=0,\n            limit=10,\n            registration_date__lt=datetime(2020, 1, 1),\n        )\n        ```\n\n        Fetch 10 users with a username other than `admin`, returning as model instances (ensure appropriate schema is passed):\n\n        ```python\n        users = await user_crud.get_multi(\n            db,\n            offset=0,\n            limit=10,\n            schema_to_select=ReadUserSchema,\n            return_as_model=True,\n            username__ne='admin',\n        )\n        ```\n\n        Fetch users with filtering and multiple column sorting:\n\n        ```python\n        users = await user_crud.get_multi(\n            db,\n            0,\n            10,\n            sort_columns=['username', 'email'],\n            sort_orders=['asc', 'desc'],\n            is_active=True,\n        )\n        ```\n    \"\"\"\n    validate_pagination_params(offset, limit)\n    regular_filters, joined_filters_info = (\n        self._filter_processor.separate_joined_filters(**kwargs)\n    )\n\n    if joined_filters_info:\n        return await handle_joined_filters_delegation(\n            crud_instance=cast(CRUDInstance, self),\n            joined_filters_info=joined_filters_info,\n            db=db,\n            offset=offset,\n            limit=limit,\n            schema_to_select=schema_to_select,\n            sort_columns=sort_columns,\n            sort_orders=sort_orders,\n            return_as_model=return_as_model,\n            return_total_count=return_total_count,\n            **regular_filters,\n        )\n\n    stmt = await self.select(\n        schema_to_select=schema_to_select,\n        sort_columns=sort_columns,\n        sort_orders=sort_orders,\n        **kwargs,\n    )\n\n    stmt = self._query_builder.apply_pagination(stmt, offset, limit)\n    result = await db.execute(stmt)\n    data = [dict(row) for row in result.mappings()]\n    formatted_data = format_multi_response(data, schema_to_select, return_as_model)\n\n    response: dict[str, Any] = {self.multi_response_key: formatted_data}\n    if return_total_count:\n        total_count = await self.count(db=db, **kwargs)\n        response[\"total_count\"] = total_count\n\n    return response\n</code></pre>"},{"location":"api/fastcrud/#fastcrud.FastCRUD.get_multi_by_cursor","title":"<code>get_multi_by_cursor(db, cursor=None, limit=100, schema_to_select=None, sort_column='id', sort_order='asc', return_as_model=False, **kwargs)</code>  <code>async</code>","text":"<pre><code>get_multi_by_cursor(\n    db: AsyncSession,\n    *,\n    cursor: Any = None,\n    limit: int = 100,\n    schema_to_select: type[SelectSchemaType],\n    sort_column: str = \"id\",\n    sort_order: str = \"asc\",\n    return_as_model: Literal[True],\n    **kwargs: Any,\n) -&gt; dict[str, Union[list[SelectSchemaType], Any]]\n</code></pre><pre><code>get_multi_by_cursor(\n    db: AsyncSession,\n    *,\n    cursor: Any = None,\n    limit: int = 100,\n    schema_to_select: None = None,\n    sort_column: str = \"id\",\n    sort_order: str = \"asc\",\n    return_as_model: Literal[False] = False,\n    **kwargs: Any,\n) -&gt; dict[str, Union[list[dict[str, Any]], Any]]\n</code></pre><pre><code>get_multi_by_cursor(\n    db: AsyncSession,\n    *,\n    cursor: Any = None,\n    limit: int = 100,\n    schema_to_select: Optional[\n        type[SelectSchemaType]\n    ] = None,\n    sort_column: str = \"id\",\n    sort_order: str = \"asc\",\n    return_as_model: bool = False,\n    **kwargs: Any,\n) -&gt; dict[\n    str,\n    Union[\n        list[Union[dict[str, Any], SelectSchemaType]], Any\n    ],\n]\n</code></pre> <p>Implements cursor-based pagination for fetching records. This method is designed for efficient data retrieval in large datasets and is ideal for features like infinite scrolling.</p> <p>For filtering details see the Advanced Filters documentation</p> <p>Parameters:</p> Name Type Description Default <code>db</code> <code>AsyncSession</code> <p>The SQLAlchemy async session.</p> required <code>cursor</code> <code>Any</code> <p>The cursor value to start fetching records from. Defaults to <code>None</code>.</p> <code>None</code> <code>limit</code> <code>int</code> <p>Maximum number of rows to fetch.</p> <code>100</code> <code>schema_to_select</code> <code>Optional[type[SelectSchemaType]]</code> <p>Pydantic schema for selecting specific columns. Required if <code>return_as_model</code> is True.</p> <code>None</code> <code>sort_column</code> <code>str</code> <p>Column name to use for sorting and cursor pagination.</p> <code>'id'</code> <code>sort_order</code> <code>str</code> <p>Sorting direction, either <code>\"asc\"</code> or <code>\"desc\"</code>.</p> <code>'asc'</code> <code>return_as_model</code> <code>bool</code> <p>If <code>True</code>, converts the fetched data to Pydantic models based on <code>schema_to_select</code>. Defaults to <code>False</code>.</p> <code>False</code> <code>**kwargs</code> <code>Any</code> <p>Filters to apply to the query, including advanced comparison operators for detailed querying.</p> <code>{}</code> <p>Returns:</p> Type Description <code>dict[str, Any]</code> <p>A dictionary containing the fetched rows under <code>\"data\"</code> key and the next cursor value under <code>\"next_cursor\"</code>:</p> <code>dict[str, Any]</code> <ul> <li>When <code>return_as_model=True</code> and <code>schema_to_select</code> is provided: <code>Dict[str, Union[List[SelectSchemaType], Any]]</code></li> </ul> <code>dict[str, Any]</code> <ul> <li>When <code>return_as_model=False</code>: <code>Dict[str, Union[List[Dict[str, Any]], Any]]</code></li> </ul> <p>Examples:</p> <p>Fetch the first set of records (e.g., the first page in an infinite scrolling scenario):</p> <pre><code>first_page = await user_crud.get_multi_by_cursor(\n    db,\n    limit=10,\n    sort_column='registration_date',\n)\n\n# Fetch the next set of records using the cursor from the first page\nsecond_page = await user_crud.get_multi_by_cursor(\n    db,\n    cursor=next_cursor,\n    limit=10,\n    sort_column='registration_date',\n    sort_order='desc',\n)\n</code></pre> <p>Fetch records as Pydantic models with cursor pagination:</p> <pre><code># Returns typed Pydantic models\nfirst_page = await user_crud.get_multi_by_cursor(\n    db,\n    schema_to_select=ReadUserSchema,\n    return_as_model=True,\n    limit=10,\n    sort_column='registration_date',\n    age__gt=30,\n)\n</code></pre> <p>Fetch records excluding a specific username using cursor-based pagination:</p> <pre><code>result = await user_crud.get_multi_by_cursor(\n    db,\n    limit=10,\n    sort_column='username',\n    sort_order='asc',\n    username__ne='admin',\n)\n</code></pre> <p>Fetch records as Pydantic model instances using cursor-based pagination:</p> <pre><code>result = await user_crud.get_multi_by_cursor(\n    db,\n    limit=10,\n    schema_to_select=ReadUserSchema,\n    return_as_model=True,\n    sort_column='created_at',\n    sort_order='desc',\n)\n</code></pre> Note <p>This method is designed for efficient pagination in large datasets and is ideal for infinite scrolling features. Make sure the column used for cursor pagination is indexed for performance.</p> Source code in <code>fastcrud/crud/fast_crud.py</code> <pre><code>async def get_multi_by_cursor(\n    self,\n    db: AsyncSession,\n    cursor: Any = None,\n    limit: int = 100,\n    schema_to_select: Optional[type[SelectSchemaType]] = None,\n    sort_column: str = \"id\",\n    sort_order: str = \"asc\",\n    return_as_model: bool = False,\n    **kwargs: Any,\n) -&gt; dict[str, Any]:\n    \"\"\"\n    Implements cursor-based pagination for fetching records. This method is designed for efficient data retrieval in large datasets and is ideal for features like infinite scrolling.\n\n    For filtering details see [the Advanced Filters documentation](../advanced/crud.md/#advanced-filters)\n\n    Args:\n        db: The SQLAlchemy async session.\n        cursor: The cursor value to start fetching records from. Defaults to `None`.\n        limit: Maximum number of rows to fetch.\n        schema_to_select: Pydantic schema for selecting specific columns. Required if `return_as_model` is True.\n        sort_column: Column name to use for sorting and cursor pagination.\n        sort_order: Sorting direction, either `\"asc\"` or `\"desc\"`.\n        return_as_model: If `True`, converts the fetched data to Pydantic models based on `schema_to_select`. Defaults to `False`.\n        **kwargs: Filters to apply to the query, including advanced comparison operators for detailed querying.\n\n    Returns:\n        A dictionary containing the fetched rows under `\"data\"` key and the next cursor value under `\"next_cursor\"`:\n\n        - When `return_as_model=True` and `schema_to_select` is provided: `Dict[str, Union[List[SelectSchemaType], Any]]`\n        - When `return_as_model=False`: `Dict[str, Union[List[Dict[str, Any]], Any]]`\n\n    Examples:\n        Fetch the first set of records (e.g., the first page in an infinite scrolling scenario):\n\n        ```python\n        first_page = await user_crud.get_multi_by_cursor(\n            db,\n            limit=10,\n            sort_column='registration_date',\n        )\n\n        # Fetch the next set of records using the cursor from the first page\n        second_page = await user_crud.get_multi_by_cursor(\n            db,\n            cursor=next_cursor,\n            limit=10,\n            sort_column='registration_date',\n            sort_order='desc',\n        )\n        ```\n\n        Fetch records as Pydantic models with cursor pagination:\n\n        ```python\n        # Returns typed Pydantic models\n        first_page = await user_crud.get_multi_by_cursor(\n            db,\n            schema_to_select=ReadUserSchema,\n            return_as_model=True,\n            limit=10,\n            sort_column='registration_date',\n            age__gt=30,\n        )\n        ```\n\n        Fetch records excluding a specific username using cursor-based pagination:\n\n        ```python\n        result = await user_crud.get_multi_by_cursor(\n            db,\n            limit=10,\n            sort_column='username',\n            sort_order='asc',\n            username__ne='admin',\n        )\n        ```\n\n        Fetch records as Pydantic model instances using cursor-based pagination:\n\n        ```python\n        result = await user_crud.get_multi_by_cursor(\n            db,\n            limit=10,\n            schema_to_select=ReadUserSchema,\n            return_as_model=True,\n            sort_column='created_at',\n            sort_order='desc',\n        )\n        ```\n\n    Note:\n        This method is designed for efficient pagination in large datasets and is ideal for infinite scrolling features.\n        Make sure the column used for cursor pagination is indexed for performance.\n    \"\"\"\n    if limit == 0:\n        return {\"data\": [], \"next_cursor\": None}\n\n    stmt = await self.select(schema_to_select=schema_to_select, **kwargs)\n\n    if cursor:\n        cursor_filter = []\n        if sort_order == \"asc\":\n            cursor_filter = self._filter_processor.parse_filters(\n                **{f\"{sort_column}__gt\": cursor}\n            )\n        else:\n            cursor_filter = self._filter_processor.parse_filters(\n                **{f\"{sort_column}__lt\": cursor}\n            )\n        stmt = self._query_builder.apply_filters(stmt, cursor_filter)\n\n    stmt = self._query_builder.apply_sorting(stmt, sort_column, sort_order)\n    stmt = self._query_builder.apply_pagination(stmt, 0, limit)\n\n    result = await db.execute(stmt)\n    data = [dict(row) for row in result.mappings()]\n    next_cursor = data[-1][sort_column] if len(data) == limit else None\n\n    formatted_data = format_multi_response(data, schema_to_select, return_as_model)\n\n    return {\"data\": formatted_data, \"next_cursor\": next_cursor}\n</code></pre>"},{"location":"api/fastcrud/#fastcrud.FastCRUD.get_multi_joined","title":"<code>get_multi_joined(db, schema_to_select=None, return_as_model=False, join_model=None, join_on=None, join_prefix=None, join_schema_to_select=None, join_type='left', alias=None, join_filters=None, nest_joins=False, offset=0, limit=100, sort_columns=None, sort_orders=None, joins_config=None, counts_config=None, return_total_count=True, relationship_type=None, nested_schema_to_select=None, **kwargs)</code>  <code>async</code>","text":"<pre><code>get_multi_joined(\n    db: AsyncSession,\n    schema_to_select: type[SelectSchemaType],\n    return_as_model: Literal[True],\n    join_model: Optional[type[ModelType]] = None,\n    join_on: Optional[Any] = None,\n    join_prefix: Optional[str] = None,\n    join_schema_to_select: Optional[\n        type[SelectSchemaType]\n    ] = None,\n    join_type: str = \"left\",\n    alias: Optional[AliasedClass[Any]] = None,\n    join_filters: Optional[dict] = None,\n    nest_joins: bool = False,\n    offset: int = 0,\n    limit: Optional[int] = 100,\n    sort_columns: Optional[Union[str, list[str]]] = None,\n    sort_orders: Optional[Union[str, list[str]]] = None,\n    joins_config: Optional[list[JoinConfig]] = None,\n    counts_config: Optional[list[CountConfig]] = None,\n    return_total_count: bool = True,\n    relationship_type: Optional[str] = None,\n    nested_schema_to_select: Optional[\n        dict[str, type[SelectSchemaType]]\n    ] = None,\n    **kwargs: Any,\n) -&gt; GetMultiResponseModel[SelectSchemaType]\n</code></pre><pre><code>get_multi_joined(\n    db: AsyncSession,\n    schema_to_select: None = None,\n    return_as_model: Literal[False] = False,\n    join_model: Optional[type[ModelType]] = None,\n    join_on: Optional[Any] = None,\n    join_prefix: Optional[str] = None,\n    join_schema_to_select: Optional[\n        type[SelectSchemaType]\n    ] = None,\n    join_type: str = \"left\",\n    alias: Optional[AliasedClass[Any]] = None,\n    join_filters: Optional[dict] = None,\n    nest_joins: bool = False,\n    offset: int = 0,\n    limit: Optional[int] = 100,\n    sort_columns: Optional[Union[str, list[str]]] = None,\n    sort_orders: Optional[Union[str, list[str]]] = None,\n    joins_config: Optional[list[JoinConfig]] = None,\n    counts_config: Optional[list[CountConfig]] = None,\n    return_total_count: bool = True,\n    relationship_type: Optional[str] = None,\n    nested_schema_to_select: Optional[\n        dict[str, type[SelectSchemaType]]\n    ] = None,\n    **kwargs: Any,\n) -&gt; GetMultiResponseDict\n</code></pre><pre><code>get_multi_joined(\n    db: AsyncSession,\n    *,\n    schema_to_select: Optional[\n        type[SelectSchemaType]\n    ] = None,\n    return_as_model: bool = False,\n    join_model: Optional[type[ModelType]] = None,\n    join_on: Optional[Any] = None,\n    join_prefix: Optional[str] = None,\n    join_schema_to_select: Optional[\n        type[SelectSchemaType]\n    ] = None,\n    join_type: str = \"left\",\n    alias: Optional[AliasedClass[Any]] = None,\n    join_filters: Optional[dict] = None,\n    nest_joins: bool = False,\n    offset: int = 0,\n    limit: Optional[int] = 100,\n    sort_columns: Optional[Union[str, list[str]]] = None,\n    sort_orders: Optional[Union[str, list[str]]] = None,\n    joins_config: Optional[list[JoinConfig]] = None,\n    counts_config: Optional[list[CountConfig]] = None,\n    return_total_count: bool = True,\n    relationship_type: Optional[str] = None,\n    nested_schema_to_select: Optional[\n        dict[str, type[SelectSchemaType]]\n    ] = None,\n    **kwargs: Any,\n) -&gt; Union[\n    GetMultiResponseModel[SelectSchemaType],\n    GetMultiResponseDict,\n]\n</code></pre> <p>Fetch multiple records with a join on another model, allowing for pagination, optional sorting, and model conversion.</p> <p>For filtering details see the Advanced Filters documentation</p> <p>Parameters:</p> Name Type Description Default <code>db</code> <code>AsyncSession</code> <p>The SQLAlchemy async session.</p> required <code>schema_to_select</code> <code>Optional[type[SelectSchemaType]]</code> <p>Pydantic schema for selecting specific columns from the primary model. Required if <code>return_as_model</code> is True.</p> <code>None</code> <code>join_model</code> <code>Optional[type[ModelType]]</code> <p>The model to join with.</p> <code>None</code> <code>join_on</code> <code>Optional[Any]</code> <p>SQLAlchemy Join object for specifying the <code>ON</code> clause of the join. If <code>None</code>, the join condition is auto-detected based on foreign keys.</p> <code>None</code> <code>join_prefix</code> <code>Optional[str]</code> <p>Optional prefix to be added to all columns of the joined model. If <code>None</code>, no prefix is added.</p> <code>None</code> <code>join_schema_to_select</code> <code>Optional[type[SelectSchemaType]]</code> <p>Pydantic schema for selecting specific columns from the joined model.</p> <code>None</code> <code>join_type</code> <code>str</code> <p>Specifies the type of join operation to perform. Can be <code>\"left\"</code> for a left outer join or <code>\"inner\"</code> for an inner join.</p> <code>'left'</code> <code>alias</code> <code>Optional[AliasedClass[Any]]</code> <p>An instance of <code>AliasedClass</code> for the join model, useful for self-joins or multiple joins on the same model. Result of <code>aliased(join_model)</code>.</p> <code>None</code> <code>join_filters</code> <code>Optional[dict]</code> <p>Filters applied to the joined model, specified as a dictionary mapping column names to their expected values.</p> <code>None</code> <code>nest_joins</code> <code>bool</code> <p>If <code>True</code>, nested data structures will be returned where joined model data are nested under the <code>join_prefix</code> as a dictionary.</p> <code>False</code> <code>offset</code> <code>int</code> <p>The offset (number of records to skip) for pagination.</p> <code>0</code> <code>limit</code> <code>Optional[int]</code> <p>Maximum number of records to fetch in one call. Use <code>None</code> for \"no limit\", fetching all matching rows. Note that in order to use <code>limit=None</code>, you'll have to provide a custom endpoint to facilitate it, which you should only do if you really seriously want to allow the user to get all the data at once.</p> <code>100</code> <code>sort_columns</code> <code>Optional[Union[str, list[str]]]</code> <p>A single column name or a list of column names on which to apply sorting.</p> <code>None</code> <code>sort_orders</code> <code>Optional[Union[str, list[str]]]</code> <p>A single sort order (<code>\"asc\"</code> or <code>\"desc\"</code>) or a list of sort orders corresponding to the columns in <code>sort_columns</code>. If not provided, defaults to <code>\"asc\"</code> for each column.</p> <code>None</code> <code>return_as_model</code> <code>bool</code> <p>If <code>True</code>, converts the fetched data to Pydantic models based on <code>schema_to_select</code>. Defaults to <code>False</code>.</p> <code>False</code> <code>joins_config</code> <code>Optional[list[JoinConfig]]</code> <p>List of <code>JoinConfig</code> instances for specifying multiple joins. Each instance defines a model to join with, join condition, optional prefix for column names, schema for selecting specific columns, and join type.</p> <code>None</code> <code>counts_config</code> <code>Optional[list[CountConfig]]</code> <p>List of <code>CountConfig</code> instances for counting related objects. Each instance defines a model to count, join condition, and optional alias for the count column. Useful for many-to-many relationships.</p> <code>None</code> <code>return_total_count</code> <code>bool</code> <p>If <code>True</code>, also returns the total count of rows with the selected filters. Useful for pagination.</p> <code>True</code> <code>relationship_type</code> <code>Optional[str]</code> <p>Specifies the relationship type, such as <code>\"one-to-one\"</code> or <code>\"one-to-many\"</code>. Used to determine how to nest the joined data. If <code>None</code>, uses <code>\"one-to-one\"</code>.</p> <code>None</code> <code>nested_schema_to_select</code> <code>Optional[dict[str, type[SelectSchemaType]]]</code> <p>A dictionary mapping join prefixes to their corresponding Pydantic schemas for nested data conversion. If not provided, schemas are auto-detected from <code>joins_config</code>.</p> <code>None</code> <code>**kwargs</code> <code>Any</code> <p>Filters to apply to the primary query, including advanced comparison operators for refined searching.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Union[GetMultiResponseModel[SelectSchemaType], GetMultiResponseDict]</code> <p>A dictionary containing the fetched rows under <code>\"data\"</code> key and total count under <code>\"total_count\"</code>:</p> <code>Union[GetMultiResponseModel[SelectSchemaType], GetMultiResponseDict]</code> <ul> <li>When <code>return_as_model=True</code> and <code>schema_to_select</code> is provided: <code>GetMultiResponseModel[SelectSchemaType]</code> (<code>Dict[str, Union[List[SelectSchemaType], int]]</code>)</li> </ul> <code>Union[GetMultiResponseModel[SelectSchemaType], GetMultiResponseDict]</code> <ul> <li>When <code>return_as_model=False</code>: <code>GetMultiResponseDict</code> (<code>Dict[str, Union[List[Dict[str, Any]], int]]</code>)</li> </ul> <p>Raises:</p> Type Description <code>ValueError</code> <p>If either <code>limit</code> or <code>offset</code> are negative, or if <code>schema_to_select</code> is required but not provided or invalid.         Also if both <code>joins_config</code> and any of the single join parameters are provided or none of <code>joins_config</code> and <code>join_model</code> is provided.</p> <p>Examples:</p> <p>Fetching multiple <code>User</code> records joined with <code>Tier</code> records, using left join, returning raw data:</p> <pre><code>users = await user_crud.get_multi_joined(\n    db=session,\n    schema_to_select=ReadUserSchema,\n    join_model=Tier,\n    join_prefix=\"tier_\",\n    join_schema_to_select=ReadTierSchema,\n    offset=0,\n    limit=10,\n)\n</code></pre> <p>Fetch users joined with their tiers, sorted by username, where user's age is greater than 30:</p> <pre><code>users = await user_crud.get_multi_joined(\n    db,\n    schema_to_select=ReadUserSchema,\n    join_model=Tier,\n    join_schema_to_select=ReadTierSchema,\n    sort_columns='username',\n    sort_orders='asc',\n    age__gt=30,\n)\n</code></pre> <p>Fetch users joined with their tiers, excluding users with <code>admin</code> username, returning as model instances:</p> <pre><code>users = await user_crud.get_multi_joined(\n    db,\n    schema_to_select=ReadUserSchema,\n    join_model=Tier,\n    join_schema_to_select=ReadTierSchema,\n    return_as_model=True,\n    username__ne='admin',\n)\n</code></pre> <p>Fetching and sorting by username in descending order, returning as Pydantic model:</p> <pre><code>users = await user_crud.get_multi_joined(\n    db=session,\n    schema_to_select=ReadUserSchema,\n    join_model=Tier,\n    join_prefix=\"tier_\",\n    join_schema_to_select=ReadTierSchema,\n    offset=0,\n    limit=10,\n    sort_columns=['username'],\n    sort_orders=['desc'],\n    return_as_model=True,\n)\n</code></pre> <p>Fetching with complex conditions and custom join, returning as Pydantic model:</p> <pre><code>users = await user_crud.get_multi_joined(\n    db=session,\n    schema_to_select=ReadUserSchema,\n    join_model=Tier,\n    join_on=User.tier_id == Tier.id,\n    join_prefix=\"tier_\",\n    join_schema_to_select=ReadTierSchema,\n    offset=0,\n    limit=10,\n    return_as_model=True,\n    is_active=True,\n)\n</code></pre> <p>Example using <code>joins_config</code> for multiple joins:</p> <pre><code>from fastcrud import JoinConfig\n\nusers = await user_crud.get_multi_joined(\n    db=session,\n    schema_to_select=ReadUserSchema,\n    joins_config=[\n        JoinConfig(\n            model=Tier,\n            join_on=User.tier_id == Tier.id,\n            join_prefix=\"tier_\",\n            schema_to_select=ReadTierSchema,\n            join_type=\"left\",\n        ),\n        JoinConfig(\n            model=Department,\n            join_on=User.department_id == Department.id,\n            join_prefix=\"dept_\",\n            schema_to_select=ReadDepartmentSchema,\n            join_type=\"inner\",\n        ),\n    ],\n    offset=0,\n    limit=10,\n    sort_columns='username',\n    sort_orders='asc',\n)\n</code></pre> <p>Example using <code>alias</code> for multiple joins, with pagination, sorting, and model conversion: <pre><code>from fastcrud import JoinConfig, FastCRUD, aliased\n\n# Aliasing for self-joins or multiple joins on the same table\nowner_alias = aliased(ModelTest, name=\"owner\")\nuser_alias = aliased(ModelTest, name=\"user\")\n\n# Initialize your FastCRUD instance for BookingModel\ncrud = FastCRUD(BookingModel)\n\nresult = await crud.get_multi_joined(\n    db=session,\n    schema_to_select=BookingSchema,  # Primary model schema\n    joins_config=[\n        JoinConfig(\n            model=ModelTest,\n            join_on=BookingModel.owner_id == owner_alias.id,\n            join_prefix=\"owner_\",\n            schema_to_select=UserSchema,  # Schema for the joined model\n            alias=owner_alias,\n        ),\n        JoinConfig(\n            model=ModelTest,\n            join_on=BookingModel.user_id == user_alias.id,\n            join_prefix=\"user_\",\n            schema_to_select=UserSchema,\n            alias=user_alias,\n        )\n    ],\n    offset=10,  # Skip the first 10 records\n    limit=5,  # Fetch up to 5 records\n    sort_columns=['booking_date'],  # Sort by booking_date\n    sort_orders=['desc'],  # In descending order\n)\n</code></pre></p> <p>Fetching multiple project records and their associated participants where participants have a specific role:</p> <pre><code>joins_config = [\n    JoinConfig(\n        model=ProjectsParticipantsAssociation,\n        join_on=Project.id == ProjectsParticipantsAssociation.project_id,\n        join_type=\"inner\",\n    ),\n    JoinConfig(\n        model=Participant,\n        join_on=ProjectsParticipantsAssociation.participant_id == Participant.id,\n        join_type=\"inner\",\n        filters={'role': 'Developer'},\n    ),\n]\n\nproject_crud = FastCRUD(Project)\n\nprojects = await project_crud.get_multi_joined(\n    db=session,\n    schema_to_select=ReadProjectSchema,\n    limit=10,\n    joins_config=joins_config,\n)\n</code></pre> <p>Fetching a list of stories, each with nested details of associated tasks and task creators, using nested joins:</p> <pre><code>story_crud = FastCRUD(Story)\nstories = await story_crud.get_multi_joined(\n    db=session,\n    schema_to_select=ReadStorySchema,\n    joins_config=[\n        JoinConfig(\n            model=Task,\n            join_on=Story.id == Task.story_id,\n            join_prefix=\"task_\",\n            schema_to_select=ReadTaskSchema,\n            join_type=\"left\",\n        ),\n        JoinConfig(\n            model=User,\n            join_on=Task.creator_id == User.id,\n            join_prefix=\"creator_\",\n            schema_to_select=ReadUserSchema,\n            join_type=\"left\",\n            alias=aliased(User, name=\"task_creator\"),\n        ),\n    ],\n    nest_joins=True,\n    offset=0,\n    limit=5,\n    sort_columns='name',\n    sort_orders='asc',\n)\n</code></pre> <p>Example using one-to-one relationship:</p> <pre><code>author_crud = FastCRUD(Author)\nresults = await author_crud.get_multi_joined(\n    db=session,\n    schema_to_select=ReadAuthorSchema,\n    join_model=Profile,\n    join_on=Author.profile_id == Profile.id,\n    join_schema_to_select=ReadProfileSchema,\n    nest_joins=True,\n    offset=0,\n    limit=10,\n    relationship_type='one-to-one', # note that this is the default behavior\n)\n# Expect 'profile' to be nested as a dictionary under each user\n</code></pre> <p>Example using one-to-many relationship:</p> <pre><code>results = await author_crud.get_multi_joined(\n    db=session,\n    schema_to_select=ReadAuthorSchema,\n    join_model=Article,\n    join_on=Author.id == Article.author_id,\n    join_schema_to_select=ReadArticleSchema,\n    nest_joins=True,\n    offset=0,\n    limit=10,\n    relationship_type='one-to-many',\n)\n# Expect 'posts' to be nested as a list of dictionaries under each user\n</code></pre> <p>Example using counts_config to count related objects (e.g., many-to-many relationships):</p> <pre><code>from fastcrud import FastCRUD, CountConfig\n\nsearch_crud = FastCRUD(Search)\n\n# Count videos for each search through a many-to-many relationship\nresults = await search_crud.get_multi_joined(\n    db=session,\n    counts_config=[\n        CountConfig(\n            model=Video,\n            join_on=(Video.id == VideoSearchAssociation.video_id)\n                   &amp; (VideoSearchAssociation.search_id == Search.id),\n            alias='videos_count'\n        )\n    ],\n)\n# Results will include 'videos_count' field for each search\n# Example result:\n# {\n#     \"data\": [\n#         {\"id\": 1, \"term\": \"cats\", \"videos_count\": 5},\n#         {\"id\": 2, \"term\": \"dogs\", \"videos_count\": 3},\n#         {\"id\": 3, \"term\": \"birds\", \"videos_count\": 0}\n#     ],\n#     \"total_count\": 3\n# }\n</code></pre> Source code in <code>fastcrud/crud/fast_crud.py</code> <pre><code>async def get_multi_joined(\n    self,\n    db: AsyncSession,\n    schema_to_select: Optional[type[SelectSchemaType]] = None,\n    return_as_model: bool = False,\n    join_model: Optional[type[ModelType]] = None,\n    join_on: Optional[Any] = None,\n    join_prefix: Optional[str] = None,\n    join_schema_to_select: Optional[type[SelectSchemaType]] = None,\n    join_type: str = \"left\",\n    alias: Optional[AliasedClass[Any]] = None,\n    join_filters: Optional[dict] = None,\n    nest_joins: bool = False,\n    offset: int = 0,\n    limit: Optional[int] = 100,\n    sort_columns: Optional[Union[str, list[str]]] = None,\n    sort_orders: Optional[Union[str, list[str]]] = None,\n    joins_config: Optional[list[JoinConfig]] = None,\n    counts_config: Optional[list[CountConfig]] = None,\n    return_total_count: bool = True,\n    relationship_type: Optional[str] = None,\n    nested_schema_to_select: Optional[dict[str, type[SelectSchemaType]]] = None,\n    **kwargs: Any,\n) -&gt; Union[GetMultiResponseModel[SelectSchemaType], GetMultiResponseDict]:\n    \"\"\"\n    Fetch multiple records with a join on another model, allowing for pagination, optional sorting, and model conversion.\n\n    For filtering details see [the Advanced Filters documentation](../advanced/crud.md/#advanced-filters)\n\n    Args:\n        db: The SQLAlchemy async session.\n        schema_to_select: Pydantic schema for selecting specific columns from the primary model. Required if `return_as_model` is True.\n        join_model: The model to join with.\n        join_on: SQLAlchemy Join object for specifying the `ON` clause of the join. If `None`, the join condition is auto-detected based on foreign keys.\n        join_prefix: Optional prefix to be added to all columns of the joined model. If `None`, no prefix is added.\n        join_schema_to_select: Pydantic schema for selecting specific columns from the joined model.\n        join_type: Specifies the type of join operation to perform. Can be `\"left\"` for a left outer join or `\"inner\"` for an inner join.\n        alias: An instance of `AliasedClass` for the join model, useful for self-joins or multiple joins on the same model. Result of `aliased(join_model)`.\n        join_filters: Filters applied to the joined model, specified as a dictionary mapping column names to their expected values.\n        nest_joins: If `True`, nested data structures will be returned where joined model data are nested under the `join_prefix` as a dictionary.\n        offset: The offset (number of records to skip) for pagination.\n        limit: Maximum number of records to fetch in one call. Use `None` for \"no limit\", fetching all matching rows. Note that in order to use `limit=None`, you'll have to provide a custom endpoint to facilitate it, which you should only do if you really seriously want to allow the user to get all the data at once.\n        sort_columns: A single column name or a list of column names on which to apply sorting.\n        sort_orders: A single sort order (`\"asc\"` or `\"desc\"`) or a list of sort orders corresponding to the columns in `sort_columns`. If not provided, defaults to `\"asc\"` for each column.\n        return_as_model: If `True`, converts the fetched data to Pydantic models based on `schema_to_select`. Defaults to `False`.\n        joins_config: List of `JoinConfig` instances for specifying multiple joins. Each instance defines a model to join with, join condition, optional prefix for column names, schema for selecting specific columns, and join type.\n        counts_config: List of `CountConfig` instances for counting related objects. Each instance defines a model to count, join condition, and optional alias for the count column. Useful for many-to-many relationships.\n        return_total_count: If `True`, also returns the total count of rows with the selected filters. Useful for pagination.\n        relationship_type: Specifies the relationship type, such as `\"one-to-one\"` or `\"one-to-many\"`. Used to determine how to nest the joined data. If `None`, uses `\"one-to-one\"`.\n        nested_schema_to_select: A dictionary mapping join prefixes to their corresponding Pydantic schemas for nested data conversion. If not provided, schemas are auto-detected from `joins_config`.\n        **kwargs: Filters to apply to the primary query, including advanced comparison operators for refined searching.\n\n    Returns:\n        A dictionary containing the fetched rows under `\"data\"` key and total count under `\"total_count\"`:\n\n        - When `return_as_model=True` and `schema_to_select` is provided: `GetMultiResponseModel[SelectSchemaType]`\n          (`Dict[str, Union[List[SelectSchemaType], int]]`)\n        - When `return_as_model=False`: `GetMultiResponseDict`\n          (`Dict[str, Union[List[Dict[str, Any]], int]]`)\n\n    Raises:\n        ValueError: If either `limit` or `offset` are negative, or if `schema_to_select` is required but not provided or invalid.\n                    Also if both `joins_config` and any of the single join parameters are provided or none of `joins_config` and `join_model` is provided.\n\n    Examples:\n        Fetching multiple `User` records joined with `Tier` records, using left join, returning raw data:\n\n        ```python\n        users = await user_crud.get_multi_joined(\n            db=session,\n            schema_to_select=ReadUserSchema,\n            join_model=Tier,\n            join_prefix=\"tier_\",\n            join_schema_to_select=ReadTierSchema,\n            offset=0,\n            limit=10,\n        )\n        ```\n\n        Fetch users joined with their tiers, sorted by username, where user's age is greater than 30:\n\n        ```python\n        users = await user_crud.get_multi_joined(\n            db,\n            schema_to_select=ReadUserSchema,\n            join_model=Tier,\n            join_schema_to_select=ReadTierSchema,\n            sort_columns='username',\n            sort_orders='asc',\n            age__gt=30,\n        )\n        ```\n\n        Fetch users joined with their tiers, excluding users with `admin` username, returning as model instances:\n\n        ```python\n        users = await user_crud.get_multi_joined(\n            db,\n            schema_to_select=ReadUserSchema,\n            join_model=Tier,\n            join_schema_to_select=ReadTierSchema,\n            return_as_model=True,\n            username__ne='admin',\n        )\n        ```\n\n        Fetching and sorting by username in descending order, returning as Pydantic model:\n\n        ```python\n        users = await user_crud.get_multi_joined(\n            db=session,\n            schema_to_select=ReadUserSchema,\n            join_model=Tier,\n            join_prefix=\"tier_\",\n            join_schema_to_select=ReadTierSchema,\n            offset=0,\n            limit=10,\n            sort_columns=['username'],\n            sort_orders=['desc'],\n            return_as_model=True,\n        )\n        ```\n\n        Fetching with complex conditions and custom join, returning as Pydantic model:\n\n        ```python\n        users = await user_crud.get_multi_joined(\n            db=session,\n            schema_to_select=ReadUserSchema,\n            join_model=Tier,\n            join_on=User.tier_id == Tier.id,\n            join_prefix=\"tier_\",\n            join_schema_to_select=ReadTierSchema,\n            offset=0,\n            limit=10,\n            return_as_model=True,\n            is_active=True,\n        )\n        ```\n\n        Example using `joins_config` for multiple joins:\n\n        ```python\n        from fastcrud import JoinConfig\n\n        users = await user_crud.get_multi_joined(\n            db=session,\n            schema_to_select=ReadUserSchema,\n            joins_config=[\n                JoinConfig(\n                    model=Tier,\n                    join_on=User.tier_id == Tier.id,\n                    join_prefix=\"tier_\",\n                    schema_to_select=ReadTierSchema,\n                    join_type=\"left\",\n                ),\n                JoinConfig(\n                    model=Department,\n                    join_on=User.department_id == Department.id,\n                    join_prefix=\"dept_\",\n                    schema_to_select=ReadDepartmentSchema,\n                    join_type=\"inner\",\n                ),\n            ],\n            offset=0,\n            limit=10,\n            sort_columns='username',\n            sort_orders='asc',\n        )\n        ```\n\n        Example using `alias` for multiple joins, with pagination, sorting, and model conversion:\n        ```python\n        from fastcrud import JoinConfig, FastCRUD, aliased\n\n        # Aliasing for self-joins or multiple joins on the same table\n        owner_alias = aliased(ModelTest, name=\"owner\")\n        user_alias = aliased(ModelTest, name=\"user\")\n\n        # Initialize your FastCRUD instance for BookingModel\n        crud = FastCRUD(BookingModel)\n\n        result = await crud.get_multi_joined(\n            db=session,\n            schema_to_select=BookingSchema,  # Primary model schema\n            joins_config=[\n                JoinConfig(\n                    model=ModelTest,\n                    join_on=BookingModel.owner_id == owner_alias.id,\n                    join_prefix=\"owner_\",\n                    schema_to_select=UserSchema,  # Schema for the joined model\n                    alias=owner_alias,\n                ),\n                JoinConfig(\n                    model=ModelTest,\n                    join_on=BookingModel.user_id == user_alias.id,\n                    join_prefix=\"user_\",\n                    schema_to_select=UserSchema,\n                    alias=user_alias,\n                )\n            ],\n            offset=10,  # Skip the first 10 records\n            limit=5,  # Fetch up to 5 records\n            sort_columns=['booking_date'],  # Sort by booking_date\n            sort_orders=['desc'],  # In descending order\n        )\n        ```\n\n        Fetching multiple project records and their associated participants where participants have a specific role:\n\n        ```python\n        joins_config = [\n            JoinConfig(\n                model=ProjectsParticipantsAssociation,\n                join_on=Project.id == ProjectsParticipantsAssociation.project_id,\n                join_type=\"inner\",\n            ),\n            JoinConfig(\n                model=Participant,\n                join_on=ProjectsParticipantsAssociation.participant_id == Participant.id,\n                join_type=\"inner\",\n                filters={'role': 'Developer'},\n            ),\n        ]\n\n        project_crud = FastCRUD(Project)\n\n        projects = await project_crud.get_multi_joined(\n            db=session,\n            schema_to_select=ReadProjectSchema,\n            limit=10,\n            joins_config=joins_config,\n        )\n        ```\n\n        Fetching a list of stories, each with nested details of associated tasks and task creators, using nested joins:\n\n        ```python\n        story_crud = FastCRUD(Story)\n        stories = await story_crud.get_multi_joined(\n            db=session,\n            schema_to_select=ReadStorySchema,\n            joins_config=[\n                JoinConfig(\n                    model=Task,\n                    join_on=Story.id == Task.story_id,\n                    join_prefix=\"task_\",\n                    schema_to_select=ReadTaskSchema,\n                    join_type=\"left\",\n                ),\n                JoinConfig(\n                    model=User,\n                    join_on=Task.creator_id == User.id,\n                    join_prefix=\"creator_\",\n                    schema_to_select=ReadUserSchema,\n                    join_type=\"left\",\n                    alias=aliased(User, name=\"task_creator\"),\n                ),\n            ],\n            nest_joins=True,\n            offset=0,\n            limit=5,\n            sort_columns='name',\n            sort_orders='asc',\n        )\n        ```\n\n        Example using one-to-one relationship:\n\n        ```python\n        author_crud = FastCRUD(Author)\n        results = await author_crud.get_multi_joined(\n            db=session,\n            schema_to_select=ReadAuthorSchema,\n            join_model=Profile,\n            join_on=Author.profile_id == Profile.id,\n            join_schema_to_select=ReadProfileSchema,\n            nest_joins=True,\n            offset=0,\n            limit=10,\n            relationship_type='one-to-one', # note that this is the default behavior\n        )\n        # Expect 'profile' to be nested as a dictionary under each user\n        ```\n\n        Example using one-to-many relationship:\n\n        ```python\n        results = await author_crud.get_multi_joined(\n            db=session,\n            schema_to_select=ReadAuthorSchema,\n            join_model=Article,\n            join_on=Author.id == Article.author_id,\n            join_schema_to_select=ReadArticleSchema,\n            nest_joins=True,\n            offset=0,\n            limit=10,\n            relationship_type='one-to-many',\n        )\n        # Expect 'posts' to be nested as a list of dictionaries under each user\n        ```\n\n        Example using counts_config to count related objects (e.g., many-to-many relationships):\n\n        ```python\n        from fastcrud import FastCRUD, CountConfig\n\n        search_crud = FastCRUD(Search)\n\n        # Count videos for each search through a many-to-many relationship\n        results = await search_crud.get_multi_joined(\n            db=session,\n            counts_config=[\n                CountConfig(\n                    model=Video,\n                    join_on=(Video.id == VideoSearchAssociation.video_id)\n                           &amp; (VideoSearchAssociation.search_id == Search.id),\n                    alias='videos_count'\n                )\n            ],\n        )\n        # Results will include 'videos_count' field for each search\n        # Example result:\n        # {\n        #     \"data\": [\n        #         {\"id\": 1, \"term\": \"cats\", \"videos_count\": 5},\n        #         {\"id\": 2, \"term\": \"dogs\", \"videos_count\": 3},\n        #         {\"id\": 3, \"term\": \"birds\", \"videos_count\": 0}\n        #     ],\n        #     \"total_count\": 3\n        # }\n        ```\n    \"\"\"\n    config = validate_joined_query_params(\n        primary_model=self.model,\n        joins_config=joins_config,\n        join_model=join_model,\n        join_prefix=join_prefix,\n        join_on=join_on,\n        join_schema_to_select=join_schema_to_select,\n        alias=alias,\n        relationship_type=relationship_type,\n        join_type=join_type,\n        join_filters=join_filters,\n        counts_config=counts_config,\n        limit=limit,\n        offset=offset,\n    )\n\n    stmt = build_joined_query(\n        model=self.model,\n        query_builder=self._query_builder,\n        filter_processor=self._filter_processor,\n        config=config,\n        schema_to_select=schema_to_select,\n        nest_joins=nest_joins,\n        **kwargs,\n    )\n    raw_data = await execute_joined_query(\n        db=db,\n        stmt=stmt,\n        query_builder=self._query_builder,\n        limit=limit,\n        offset=offset,\n        sort_columns=sort_columns,\n        sort_orders=sort_orders,\n    )\n\n    return await format_joined_response(\n        primary_model=self.model,\n        raw_data=raw_data,\n        config=config,\n        schema_to_select=schema_to_select,\n        return_as_model=return_as_model,\n        nest_joins=nest_joins,\n        return_total_count=return_total_count,\n        db=db,\n        nested_schema_to_select=nested_schema_to_select,\n        count_func=self.count if return_total_count else None,\n        **kwargs,\n    )\n</code></pre>"},{"location":"api/fastcrud/#fastcrud.FastCRUD.select","title":"<code>select(schema_to_select=None, sort_columns=None, sort_orders=None, **kwargs)</code>  <code>async</code>","text":"<p>Constructs a SQL Alchemy <code>Select</code> statement with optional column selection, filtering, and sorting.</p> <p>This method allows for advanced filtering through comparison operators, enabling queries to be refined beyond simple equality checks.</p> <p>For filtering details see the Advanced Filters documentation</p> <p>Parameters:</p> Name Type Description Default <code>schema_to_select</code> <code>Optional[type[SelectSchemaType]]</code> <p>Pydantic schema to determine which columns to include in the selection. If not provided, selects all columns of the model.</p> <code>None</code> <code>sort_columns</code> <code>Optional[Union[str, list[str]]]</code> <p>A single column name or list of column names to sort the query results by. Must be used in conjunction with <code>sort_orders</code>.</p> <code>None</code> <code>sort_orders</code> <code>Optional[Union[str, list[str]]]</code> <p>A single sort order (<code>\"asc\"</code> or <code>\"desc\"</code>) or a list of sort orders, corresponding to each column in <code>sort_columns</code>. If not specified, defaults to ascending order for all <code>sort_columns</code>.</p> <code>None</code> <code>**kwargs</code> <code>Any</code> <p>Filters to apply to the query, including advanced comparison operators for more detailed querying.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Select</code> <p>An SQL Alchemy <code>Select</code> statement object that can be executed or further modified.</p> <p>Examples:</p> <p>Selecting specific columns with filtering and sorting:</p> <pre><code>stmt = await user_crud.select(\n    schema_to_select=ReadUserSchema,\n    sort_columns=['age', 'name'],\n    sort_orders=['asc', 'desc'],\n    age__gt=18,\n)\n</code></pre> <p>Creating a statement to select all users without any filters:</p> <pre><code>stmt = await user_crud.select()\n</code></pre> <p>Selecting users with a specific <code>role</code>, ordered by <code>name</code>:</p> <pre><code>stmt = await user_crud.select(\n    schema_to_select=UserReadSchema,\n    sort_columns='name',\n    role='admin',\n)\n</code></pre> Note <p>This method does not execute the generated SQL statement. Use <code>db.execute(stmt)</code> to run the query and fetch results.</p> Source code in <code>fastcrud/crud/fast_crud.py</code> <pre><code>async def select(\n    self,\n    schema_to_select: Optional[type[SelectSchemaType]] = None,\n    sort_columns: Optional[Union[str, list[str]]] = None,\n    sort_orders: Optional[Union[str, list[str]]] = None,\n    **kwargs: Any,\n) -&gt; Select:\n    \"\"\"\n    Constructs a SQL Alchemy `Select` statement with optional column selection, filtering, and sorting.\n\n    This method allows for advanced filtering through comparison operators, enabling queries to be refined beyond simple equality checks.\n\n    For filtering details see [the Advanced Filters documentation](../advanced/crud.md/#advanced-filters)\n\n    Args:\n        schema_to_select: Pydantic schema to determine which columns to include in the selection. If not provided, selects all columns of the model.\n        sort_columns: A single column name or list of column names to sort the query results by. Must be used in conjunction with `sort_orders`.\n        sort_orders: A single sort order (`\"asc\"` or `\"desc\"`) or a list of sort orders, corresponding to each column in `sort_columns`. If not specified, defaults to ascending order for all `sort_columns`.\n        **kwargs: Filters to apply to the query, including advanced comparison operators for more detailed querying.\n\n    Returns:\n        An SQL Alchemy `Select` statement object that can be executed or further modified.\n\n    Examples:\n        Selecting specific columns with filtering and sorting:\n\n        ```python\n        stmt = await user_crud.select(\n            schema_to_select=ReadUserSchema,\n            sort_columns=['age', 'name'],\n            sort_orders=['asc', 'desc'],\n            age__gt=18,\n        )\n        ```\n\n        Creating a statement to select all users without any filters:\n\n        ```python\n        stmt = await user_crud.select()\n        ```\n\n        Selecting users with a specific `role`, ordered by `name`:\n\n        ```python\n        stmt = await user_crud.select(\n            schema_to_select=UserReadSchema,\n            sort_columns='name',\n            role='admin',\n        )\n        ```\n\n    Note:\n        This method does not execute the generated SQL statement.\n        Use `db.execute(stmt)` to run the query and fetch results.\n    \"\"\"\n    to_select = extract_matching_columns_from_schema(\n        model=self.model, schema=schema_to_select\n    )\n    filters = self._filter_processor.parse_filters(**kwargs)\n    stmt = select(*to_select).filter(*filters)\n\n    if sort_columns:\n        stmt = self._query_builder.apply_sorting(stmt, sort_columns, sort_orders)\n    return stmt\n</code></pre>"},{"location":"api/fastcrud/#fastcrud.FastCRUD.update","title":"<code>update(db, object, allow_multiple=False, commit=True, return_columns=None, schema_to_select=None, return_as_model=False, one_or_none=False, **kwargs)</code>  <code>async</code>","text":"<pre><code>update(\n    db: AsyncSession,\n    object: Union[UpdateSchemaType, dict[str, Any]],\n    *,\n    allow_multiple: bool = False,\n    commit: bool = True,\n    return_columns: Optional[list[str]] = None,\n    schema_to_select: type[SelectSchemaType],\n    return_as_model: Literal[True],\n    one_or_none: bool = False,\n    **kwargs: Any,\n) -&gt; Optional[SelectSchemaType]\n</code></pre><pre><code>update(\n    db: AsyncSession,\n    object: Union[UpdateSchemaType, dict[str, Any]],\n    *,\n    allow_multiple: bool = False,\n    commit: bool = True,\n    return_columns: Optional[list[str]] = None,\n    schema_to_select: None = None,\n    return_as_model: Literal[False] = False,\n    one_or_none: bool = False,\n    **kwargs: Any,\n) -&gt; Optional[dict[str, Any]]\n</code></pre><pre><code>update(\n    db: AsyncSession,\n    object: Union[UpdateSchemaType, dict[str, Any]],\n    *,\n    allow_multiple: bool = False,\n    commit: bool = True,\n    return_columns: Optional[list[str]] = None,\n    schema_to_select: Optional[\n        type[SelectSchemaType]\n    ] = None,\n    return_as_model: bool = False,\n    one_or_none: bool = False,\n    **kwargs: Any,\n) -&gt; Optional[Union[dict[str, Any], SelectSchemaType]]\n</code></pre> <p>Updates an existing record or multiple records in the database based on specified filters. This method allows for precise targeting of records to update.</p> <p>For filtering details see the Advanced Filters documentation</p> <p>Parameters:</p> Name Type Description Default <code>db</code> <code>AsyncSession</code> <p>The database session to use for the operation.</p> required <code>object</code> <code>Union[UpdateSchemaType, dict[str, Any]]</code> <p>A Pydantic schema or dictionary containing the update data.</p> required <code>allow_multiple</code> <code>bool</code> <p>If <code>True</code>, allows updating multiple records that match the filters. If <code>False</code>, raises an error if more than one record matches the filters.</p> <code>False</code> <code>commit</code> <code>bool</code> <p>If <code>True</code>, commits the transaction immediately. Default is <code>True</code>.</p> <code>True</code> <code>return_columns</code> <code>Optional[list[str]]</code> <p>A list of column names to return after the update. If <code>return_as_model</code> is True, all columns are returned.</p> <code>None</code> <code>schema_to_select</code> <code>Optional[type[SelectSchemaType]]</code> <p>Pydantic schema for selecting specific columns from the updated record(s). Required if <code>return_as_model</code> is <code>True</code>.</p> <code>None</code> <code>return_as_model</code> <code>bool</code> <p>If <code>True</code>, returns the updated record(s) as Pydantic model instances based on <code>schema_to_select</code>. Default is False.</p> <code>False</code> <code>one_or_none</code> <code>bool</code> <p>If <code>True</code>, returns a single record if only one record matches the filters. Default is <code>False</code>.</p> <code>False</code> <code>**kwargs</code> <code>Any</code> <p>Filters to identify the record(s) to update, supporting advanced comparison operators for refined querying.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Optional[Union[dict, SelectSchemaType]]</code> <p>The updated record(s) as a dictionary or Pydantic model instance or <code>None</code>:</p> <code>Optional[Union[dict, SelectSchemaType]]</code> <ul> <li>When <code>return_as_model=True</code> and <code>schema_to_select</code> is provided: <code>Optional[SelectSchemaType]</code></li> </ul> <code>Optional[Union[dict, SelectSchemaType]]</code> <ul> <li>When <code>return_as_model=False</code>: <code>Optional[Dict[str, Any]]</code></li> </ul> <p>Raises:</p> Type Description <code>MultipleResultsFound</code> <p>If <code>allow_multiple</code> is <code>False</code> and more than one record matches the filters.</p> <code>NoResultFound</code> <p>If no record matches the filters. (on version 0.15.3)</p> <code>ValueError</code> <p>If extra fields not present in the model are provided in the update data.</p> <code>ValueError</code> <p>If <code>return_as_model</code> is <code>True</code> but <code>schema_to_select</code> is not provided.</p> <p>Examples:</p> <p>Update a user's email based on their ID:</p> <pre><code>await user_crud.update(db, {'email': 'new_email@example.com'}, id=1)\n</code></pre> <p>Update users to be inactive where age is greater than 30 and allow updates to multiple records:</p> <pre><code>await user_crud.update(\n    db,\n    {'is_active': False},\n    allow_multiple=True,\n    age__gt=30,\n)\n</code></pre> <p>Update a user's username excluding specific user ID and prevent multiple updates:</p> <pre><code>await user_crud.update(\n    db,\n    {'username': 'new_username'},\n    allow_multiple=False,\n    id__ne=1,\n)\n</code></pre> <p>Update a user's email and return the updated record as a Pydantic model instance:</p> <pre><code>user = await user_crud.update(\n    db,\n    {'email': 'new_email@example.com'},\n    schema_to_select=ReadUserSchema,\n    return_as_model=True,\n    id=1,\n)\n</code></pre> <p>Update a user's email and return the updated record as a dictionary: <pre><code>user = await user_crud.update(\n    db,\n    {'email': 'new_email@example.com'},\n    return_columns=['id', 'email'],\n    id=1,\n)\n</code></pre></p> Source code in <code>fastcrud/crud/fast_crud.py</code> <pre><code>async def update(\n    self,\n    db: AsyncSession,\n    object: Union[UpdateSchemaType, dict[str, Any]],\n    allow_multiple: bool = False,\n    commit: bool = True,\n    return_columns: Optional[list[str]] = None,\n    schema_to_select: Optional[type[SelectSchemaType]] = None,\n    return_as_model: bool = False,\n    one_or_none: bool = False,\n    **kwargs: Any,\n) -&gt; Optional[Union[dict, SelectSchemaType]]:\n    \"\"\"\n    Updates an existing record or multiple records in the database based on specified filters. This method allows for precise targeting of records to update.\n\n    For filtering details see [the Advanced Filters documentation](../advanced/crud.md/#advanced-filters)\n\n    Args:\n        db: The database session to use for the operation.\n        object: A Pydantic schema or dictionary containing the update data.\n        allow_multiple: If `True`, allows updating multiple records that match the filters. If `False`, raises an error if more than one record matches the filters.\n        commit: If `True`, commits the transaction immediately. Default is `True`.\n        return_columns: A list of column names to return after the update. If `return_as_model` is True, all columns are returned.\n        schema_to_select: Pydantic schema for selecting specific columns from the updated record(s). Required if `return_as_model` is `True`.\n        return_as_model: If `True`, returns the updated record(s) as Pydantic model instances based on `schema_to_select`. Default is False.\n        one_or_none: If `True`, returns a single record if only one record matches the filters. Default is `False`.\n        **kwargs: Filters to identify the record(s) to update, supporting advanced comparison operators for refined querying.\n\n    Returns:\n        The updated record(s) as a dictionary or Pydantic model instance or `None`:\n\n        - When `return_as_model=True` and `schema_to_select` is provided: `Optional[SelectSchemaType]`\n        - When `return_as_model=False`: `Optional[Dict[str, Any]]`\n\n    Raises:\n        MultipleResultsFound: If `allow_multiple` is `False` and more than one record matches the filters.\n        NoResultFound: If no record matches the filters. (on version 0.15.3)\n        ValueError: If extra fields not present in the model are provided in the update data.\n        ValueError: If `return_as_model` is `True` but `schema_to_select` is not provided.\n\n    Examples:\n        Update a user's email based on their ID:\n\n        ```python\n        await user_crud.update(db, {'email': 'new_email@example.com'}, id=1)\n        ```\n\n        Update users to be inactive where age is greater than 30 and allow updates to multiple records:\n\n        ```python\n        await user_crud.update(\n            db,\n            {'is_active': False},\n            allow_multiple=True,\n            age__gt=30,\n        )\n        ```\n\n        Update a user's username excluding specific user ID and prevent multiple updates:\n\n        ```python\n        await user_crud.update(\n            db,\n            {'username': 'new_username'},\n            allow_multiple=False,\n            id__ne=1,\n        )\n        ```\n\n        Update a user's email and return the updated record as a Pydantic model instance:\n\n        ```python\n        user = await user_crud.update(\n            db,\n            {'email': 'new_email@example.com'},\n            schema_to_select=ReadUserSchema,\n            return_as_model=True,\n            id=1,\n        )\n        ```\n\n        Update a user's email and return the updated record as a dictionary:\n        ```python\n        user = await user_crud.update(\n            db,\n            {'email': 'new_email@example.com'},\n            return_columns=['id', 'email'],\n            id=1,\n        )\n        ```\n    \"\"\"\n    await validate_update_delete_operation(\n        self.count, db, allow_multiple, \"update\", **kwargs\n    )\n    update_data = prepare_update_data(\n        object, self.model_col_names, self.updated_at_column, self.model\n    )\n\n    filters = self._filter_processor.parse_filters(**kwargs)\n    stmt = update(self.model).filter(*filters).values(update_data)\n\n    if return_as_model:\n        return_columns = self.model_col_names\n\n    return await execute_update_and_return_response(\n        db=db,\n        stmt=stmt,\n        commit=commit,\n        return_columns=return_columns,\n        schema_to_select=schema_to_select,\n        return_as_model=return_as_model,\n        allow_multiple=allow_multiple,\n        one_or_none=one_or_none,\n    )\n</code></pre>"},{"location":"api/fastcrud/#fastcrud.FastCRUD.upsert","title":"<code>upsert(db, instance, schema_to_select=None, return_as_model=False)</code>  <code>async</code>","text":"<pre><code>upsert(\n    db: AsyncSession,\n    instance: Union[UpdateSchemaType, CreateSchemaType],\n    *,\n    schema_to_select: type[SelectSchemaType],\n    return_as_model: Literal[True],\n) -&gt; Optional[SelectSchemaType]\n</code></pre><pre><code>upsert(\n    db: AsyncSession,\n    instance: Union[UpdateSchemaType, CreateSchemaType],\n    *,\n    schema_to_select: None = None,\n    return_as_model: Literal[False] = False,\n) -&gt; Optional[dict[str, Any]]\n</code></pre><pre><code>upsert(\n    db: AsyncSession,\n    instance: Union[UpdateSchemaType, CreateSchemaType],\n    *,\n    schema_to_select: Optional[\n        type[SelectSchemaType]\n    ] = None,\n    return_as_model: bool = False,\n) -&gt; Union[SelectSchemaType, dict[str, Any], None]\n</code></pre> <p>Update the instance or create it if it doesn't exists.</p> <p>Note: This method will perform two transactions to the database (get and create or update).</p> <p>Parameters:</p> Name Type Description Default <code>db</code> <code>AsyncSession</code> <p>The database session to use for the operation.</p> required <code>instance</code> <code>Union[UpdateSchemaType, CreateSchemaType]</code> <p>A Pydantic schema representing the instance.</p> required <code>schema_to_select</code> <code>Optional[type[SelectSchemaType]]</code> <p>Optional Pydantic schema for selecting specific columns. Defaults to <code>None</code>.</p> <code>None</code> <code>return_as_model</code> <code>bool</code> <p>If <code>True</code>, converts the fetched data to Pydantic models based on <code>schema_to_select</code>. Defaults to <code>False</code>.</p> <code>False</code> <p>Returns:</p> Type Description <code>Union[SelectSchemaType, dict[str, Any], None]</code> <p>The created or updated instance:</p> <code>Union[SelectSchemaType, dict[str, Any], None]</code> <ul> <li>When <code>return_as_model=True</code> and <code>schema_to_select</code> is provided: <code>SelectSchemaType</code></li> </ul> <code>Union[SelectSchemaType, dict[str, Any], None]</code> <ul> <li>When <code>return_as_model=False</code>: <code>Dict[str, Any]</code></li> </ul> Source code in <code>fastcrud/crud/fast_crud.py</code> <pre><code>async def upsert(\n    self,\n    db: AsyncSession,\n    instance: Union[UpdateSchemaType, CreateSchemaType],\n    schema_to_select: Optional[type[SelectSchemaType]] = None,\n    return_as_model: bool = False,\n) -&gt; Union[SelectSchemaType, dict[str, Any], None]:\n    \"\"\"Update the instance or create it if it doesn't exists.\n\n    Note: This method will perform two transactions to the database (get and create or update).\n\n    Args:\n        db: The database session to use for the operation.\n        instance: A Pydantic schema representing the instance.\n        schema_to_select: Optional Pydantic schema for selecting specific columns. Defaults to `None`.\n        return_as_model: If `True`, converts the fetched data to Pydantic models based on `schema_to_select`. Defaults to `False`.\n\n    Returns:\n        The created or updated instance:\n\n        - When `return_as_model=True` and `schema_to_select` is provided: `SelectSchemaType`\n        - When `return_as_model=False`: `Dict[str, Any]`\n    \"\"\"\n    _pks = self._get_pk_dict(instance)\n    schema_to_select = schema_to_select or type(instance)  # type: ignore\n    db_instance = await self.get(\n        db,\n        schema_to_select=schema_to_select,  # type: ignore\n        return_as_model=return_as_model,\n        **_pks,\n    )\n    if db_instance is None:\n        db_instance = await self.create(db, instance)  # type: ignore\n        db_instance = schema_to_select.model_validate(  # type: ignore\n            db_instance, from_attributes=True\n        )\n    else:\n        await self.update(db, instance)  # type: ignore\n        db_instance = await self.get(\n            db,\n            schema_to_select=schema_to_select,  # type: ignore\n            return_as_model=return_as_model,\n            **_pks,\n        )\n\n    return db_instance\n</code></pre>"},{"location":"api/fastcrud/#fastcrud.FastCRUD.upsert_multi","title":"<code>upsert_multi(db, instances, commit=False, return_columns=None, schema_to_select=None, return_as_model=False, update_override=None, **kwargs)</code>  <code>async</code>","text":"<pre><code>upsert_multi(\n    db: AsyncSession,\n    instances: list[\n        Union[UpdateSchemaType, CreateSchemaType]\n    ],\n    *,\n    commit: bool = False,\n    return_columns: Optional[list[str]] = None,\n    schema_to_select: type[SelectSchemaType],\n    return_as_model: Literal[True],\n    update_override: Optional[dict[str, Any]] = None,\n    **kwargs: Any,\n) -&gt; Optional[UpsertMultiResponseModel[SelectSchemaType]]\n</code></pre><pre><code>upsert_multi(\n    db: AsyncSession,\n    instances: list[\n        Union[UpdateSchemaType, CreateSchemaType]\n    ],\n    *,\n    commit: bool = False,\n    return_columns: Optional[list[str]] = None,\n    schema_to_select: None = None,\n    return_as_model: Literal[False] = False,\n    update_override: Optional[dict[str, Any]] = None,\n    **kwargs: Any,\n) -&gt; Optional[UpsertMultiResponseDict]\n</code></pre><pre><code>upsert_multi(\n    db: AsyncSession,\n    instances: list[\n        Union[UpdateSchemaType, CreateSchemaType]\n    ],\n    *,\n    commit: bool = False,\n    return_columns: Optional[list[str]] = None,\n    schema_to_select: Optional[\n        type[SelectSchemaType]\n    ] = None,\n    return_as_model: bool = False,\n    update_override: Optional[dict[str, Any]] = None,\n    **kwargs: Any,\n) -&gt; Optional[\n    Union[\n        UpsertMultiResponseDict,\n        UpsertMultiResponseModel[SelectSchemaType],\n    ]\n]\n</code></pre> <p>Upsert multiple records in the database. The underlying implementation varies based on the database dialect.</p> <p>Parameters:</p> Name Type Description Default <code>db</code> <code>AsyncSession</code> <p>The database session to use for the operation.</p> required <code>instances</code> <code>list[Union[UpdateSchemaType, CreateSchemaType]]</code> <p>A list of Pydantic schemas representing the instances to upsert.</p> required <code>commit</code> <code>bool</code> <p>If True, commits the transaction immediately. Default is False.</p> <code>False</code> <code>return_columns</code> <code>Optional[list[str]]</code> <p>Optional list of column names to return after the upsert operation.</p> <code>None</code> <code>schema_to_select</code> <code>Optional[type[SelectSchemaType]]</code> <p>Optional Pydantic schema for selecting specific columns. Required if return_as_model is True.</p> <code>None</code> <code>return_as_model</code> <code>bool</code> <p>If True, returns data as instances of the specified Pydantic model.</p> <code>False</code> <code>update_override</code> <code>Optional[dict[str, Any]]</code> <p>Optional dictionary to override the update values for the upsert operation.</p> <code>None</code> <code>**kwargs</code> <code>Any</code> <p>Filters to identify the record(s) to update on conflict, supporting advanced comparison operators for refined querying.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Optional[Union[UpsertMultiResponseDict, UpsertMultiResponseModel[SelectSchemaType]]]</code> <p>The upserted records as a dictionary containing the operation results:</p> <code>Optional[Union[UpsertMultiResponseDict, UpsertMultiResponseModel[SelectSchemaType]]]</code> <ul> <li>When <code>return_as_model=True</code> and <code>schema_to_select</code> is provided: <code>UpsertMultiResponseModel[SelectSchemaType]</code> (<code>Dict[str, List[SelectSchemaType]]</code>)</li> </ul> <code>Optional[Union[UpsertMultiResponseDict, UpsertMultiResponseModel[SelectSchemaType]]]</code> <ul> <li>When <code>return_as_model=False</code>: <code>UpsertMultiResponseDict</code> (<code>Dict[str, List[Dict[str, Any]]]</code>)</li> </ul> <code>Optional[Union[UpsertMultiResponseDict, UpsertMultiResponseModel[SelectSchemaType]]]</code> <p>The dictionary contains keys like \"updated\" and \"created\" with lists of corresponding records.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the MySQL dialect is used with filters, return_columns, schema_to_select, or return_as_model.</p> <code>NotImplementedError</code> <p>If the database dialect is not supported for upsert multi.</p> Source code in <code>fastcrud/crud/fast_crud.py</code> <pre><code>async def upsert_multi(\n    self,\n    db: AsyncSession,\n    instances: list[Union[UpdateSchemaType, CreateSchemaType]],\n    commit: bool = False,\n    return_columns: Optional[list[str]] = None,\n    schema_to_select: Optional[type[SelectSchemaType]] = None,\n    return_as_model: bool = False,\n    update_override: Optional[dict[str, Any]] = None,\n    **kwargs: Any,\n) -&gt; Optional[\n    Union[UpsertMultiResponseDict, UpsertMultiResponseModel[SelectSchemaType]]\n]:\n    \"\"\"\n    Upsert multiple records in the database. The underlying implementation varies based on the database dialect.\n\n    Args:\n        db: The database session to use for the operation.\n        instances: A list of Pydantic schemas representing the instances to upsert.\n        commit: If True, commits the transaction immediately. Default is False.\n        return_columns: Optional list of column names to return after the upsert operation.\n        schema_to_select: Optional Pydantic schema for selecting specific columns. Required if return_as_model is True.\n        return_as_model: If True, returns data as instances of the specified Pydantic model.\n        update_override: Optional dictionary to override the update values for the upsert operation.\n        **kwargs: Filters to identify the record(s) to update on conflict, supporting advanced comparison operators for refined querying.\n\n    Returns:\n        The upserted records as a dictionary containing the operation results:\n\n        - When `return_as_model=True` and `schema_to_select` is provided: `UpsertMultiResponseModel[SelectSchemaType]`\n          (`Dict[str, List[SelectSchemaType]]`)\n        - When `return_as_model=False`: `UpsertMultiResponseDict`\n          (`Dict[str, List[Dict[str, Any]]]`)\n\n        The dictionary contains keys like \"updated\" and \"created\" with lists of corresponding records.\n\n    Raises:\n        ValueError: If the MySQL dialect is used with filters, return_columns, schema_to_select, or return_as_model.\n        NotImplementedError: If the database dialect is not supported for upsert multi.\n    \"\"\"\n    if update_override is None:\n        update_override = {}\n    filters = self._filter_processor.parse_filters(**kwargs)\n\n    if db.bind.dialect.name == \"postgresql\":\n        statement, params = await upsert_multi_postgresql(\n            self.model,\n            [pk.name for pk in self._primary_keys],\n            instances,\n            filters,\n            update_override,\n        )\n    elif db.bind.dialect.name == \"sqlite\":\n        statement, params = await upsert_multi_sqlite(\n            self.model,\n            [pk.name for pk in self._primary_keys],\n            instances,\n            filters,\n            update_override,\n        )\n    elif db.bind.dialect.name in [\"mysql\", \"mariadb\"]:\n        if filters:\n            raise ValueError(\n                \"MySQL does not support filtering on insert operations.\"\n            )\n        if return_columns or schema_to_select or return_as_model:\n            raise ValueError(\n                \"MySQL does not support the returning clause for insert operations.\"\n            )\n        statement, params = await upsert_multi_mysql(\n            self.model,\n            instances,\n            update_override,\n            self.deleted_at_column,\n        )\n    else:  # pragma: no cover\n        raise NotImplementedError(\n            f\"Upsert multi is not implemented for {db.bind.dialect.name}\"\n        )\n\n    if return_as_model:\n        return_columns = self.model_col_names\n\n    if return_columns:\n        statement = statement.returning(*[column(name) for name in return_columns])\n        db_row = await db.execute(statement, params)\n        if commit:\n            await db.commit()\n        rows_data = [dict(row) for row in db_row.mappings()]\n        formatted_data = format_multi_response(\n            rows_data, schema_to_select, return_as_model\n        )\n        return {\"data\": formatted_data}\n\n    await db.execute(statement, params)\n    if commit:\n        await db.commit()\n    return None\n</code></pre>"},{"location":"api/overview/","title":"API Reference Overview","text":"<p>Welcome to the API Reference section of our documentation. This section provides detailed information about the various classes, functions, and modules that make up our application. Whether you are looking to extend the application, integrate with it, or simply explore its capabilities, this section will guide you through the intricacies of our codebase.</p>"},{"location":"api/overview/#key-components","title":"Key Components","text":"<p>Our application's API is comprised of several key components, each serving a specific purpose:</p> <ol> <li> <p>FastCRUD Class: This class is at the heart of our CRUD (Create, Read, Update, Delete) operations. It provides a convenient and efficient way to interact with our database models.</p> <ul> <li>FastCRUD Class Reference</li> </ul> </li> <li> <p>EndpointCreator Class: A utility class for creating and registering CRUD endpoints in a FastAPI application. It simplifies the addition of standard CRUD endpoints to your FastAPI router.</p> <ul> <li>EndpointCreator Class Reference</li> </ul> </li> <li> <p>crud_router Function: A function that creates and configures a FastAPI router with CRUD endpoints for a specific model. It's a quick way to add standard CRUD operations to your models.</p> <ul> <li>CRUD Router Function Reference</li> </ul> </li> <li> <p>paginated Module: A utility module for offset pagination related functions. </p> </li> </ol> <p>!!! note \"Module Restructured\"        As of version 0.18.0, pagination utilities have been moved to the core module for better organization. The <code>fastcrud.paginated</code> module is now deprecated but remains available for backward compatibility.</p> <pre><code>- [Pagination Module Reference](paginated.md)\n</code></pre>"},{"location":"api/overview/#usage","title":"Usage","text":"<p>Each component is documented with its own dedicated page, where you can find detailed information about its methods, parameters, return types, and usage examples. These pages are designed to provide you with all the information you need to understand and work with our API effectively.</p>"},{"location":"api/overview/#architecture","title":"Architecture","text":"<p>For a deeper understanding of how these components fit together, see our Architecture Documentation. This explains FastCRUD's six-level dependency hierarchy, design principles, and how the modules are organized.</p>"},{"location":"api/overview/#contribution","title":"Contribution","text":"<p>If you wish to contribute to the development of our API, please refer to our Contributing Guidelines. We welcome contributions of all forms, from bug fixes to feature development.</p>"},{"location":"api/overview/#feedback","title":"Feedback","text":"<p>Your feedback is crucial in helping us improve this documentation. If you have any suggestions, corrections, or queries, please reach out to us.</p> <p>Navigate through each section for detailed documentation of our API components.</p>"},{"location":"api/paginated/","title":"Paginated Module Reference","text":"<p>Deprecated</p> <p>The <code>fastcrud.paginated</code> module is deprecated as of version 0.18.0 and will be removed in the next major version. Please import pagination utilities directly from <code>fastcrud</code> instead:</p> <pre><code># Old (deprecated)\nfrom fastcrud.paginated import PaginatedListResponse, PaginatedRequestQuery\n\n# New (recommended)\nfrom fastcrud import PaginatedListResponse, PaginatedRequestQuery\n</code></pre> <p><code>paginated</code> is a utility module for offset pagination related functions. The functionality has been moved to the core module for better organization.</p>"},{"location":"api/paginated/#core-pagination-module","title":"Core Pagination Module","text":"<p>The pagination utilities are now consolidated in a single core module:</p>"},{"location":"api/paginated/#pagination-module","title":"Pagination Module","text":"<p>Pagination utilities for FastCRUD.</p> <p>This module consolidates all pagination-related functionality including: - Pagination parameter schemas - Pagination response formatting - Offset calculation helpers - Dynamic response model creation</p>"},{"location":"api/paginated/#fastcrud.core.pagination.CursorPaginatedRequestQuery","title":"<code>CursorPaginatedRequestQuery</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Pydantic model for cursor-based pagination query parameters.</p> <p>This model encapsulates all query parameters used for cursor-based pagination in endpoints. It can be used with FastAPI's Depends() to inject these parameters into endpoints, making it easy to reuse in custom endpoints.</p> <p>Cursor-based pagination is ideal for large datasets and infinite scrolling features, as it provides consistent results even when data is being modified.</p> <p>Attributes:</p> Name Type Description <code>cursor</code> <code>Optional[int]</code> <p>Cursor value for pagination (typically the ID of the last item from previous page)</p> <code>limit</code> <code>Optional[int]</code> <p>Maximum number of items to return per page</p> <code>sort_column</code> <code>Optional[str]</code> <p>Column name to sort by (defaults to 'id')</p> <code>sort_order</code> <code>Optional[str]</code> <p>Sort order, either 'asc' or 'desc' (defaults to 'asc')</p> Example <pre><code>from typing import Annotated\nfrom fastapi import Depends\nfrom fastcrud import CursorPaginatedRequestQuery\n\nasync def custom_cursor_endpoint(\n    query: Annotated[CursorPaginatedRequestQuery, Depends()]\n):\n    # Use query.cursor, query.limit, query.sort_column, query.sort_order\n    pass\n</code></pre> Source code in <code>fastcrud/core/pagination.py</code> <pre><code>class CursorPaginatedRequestQuery(BaseModel):\n    \"\"\"\n    Pydantic model for cursor-based pagination query parameters.\n\n    This model encapsulates all query parameters used for cursor-based pagination\n    in endpoints. It can be used with FastAPI's Depends() to inject these parameters\n    into endpoints, making it easy to reuse in custom endpoints.\n\n    Cursor-based pagination is ideal for large datasets and infinite scrolling\n    features, as it provides consistent results even when data is being modified.\n\n    Attributes:\n        cursor: Cursor value for pagination (typically the ID of the last item from previous page)\n        limit: Maximum number of items to return per page\n        sort_column: Column name to sort by (defaults to 'id')\n        sort_order: Sort order, either 'asc' or 'desc' (defaults to 'asc')\n\n    Example:\n        ```python\n        from typing import Annotated\n        from fastapi import Depends\n        from fastcrud import CursorPaginatedRequestQuery\n\n        async def custom_cursor_endpoint(\n            query: Annotated[CursorPaginatedRequestQuery, Depends()]\n        ):\n            # Use query.cursor, query.limit, query.sort_column, query.sort_order\n            pass\n        ```\n    \"\"\"\n\n    cursor: Optional[int] = Field(\n        None,\n        description=\"Cursor value for pagination (typically the ID of the last item from previous page)\",\n    )\n    limit: Optional[int] = Field(\n        100, description=\"Maximum number of items to return per page\", gt=0, le=1000\n    )\n    sort_column: Optional[str] = Field(\"id\", description=\"Column name to sort by\")\n    sort_order: Optional[str] = Field(\n        \"asc\",\n        description=\"Sort order: 'asc' for ascending, 'desc' for descending\",\n        pattern=\"^(asc|desc)$\",\n    )\n\n    model_config = {\"populate_by_name\": True}\n</code></pre>"},{"location":"api/paginated/#fastcrud.core.pagination.PaginatedRequestQuery","title":"<code>PaginatedRequestQuery</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Pydantic model for paginated query parameters.</p> <p>This model encapsulates all query parameters used for pagination and sorting in read_items endpoints. It can be used with FastAPI's Depends() to inject these parameters into endpoints, making it easy to reuse in custom endpoints.</p> <p>Supports two pagination modes: - Page-based: Using 'page' and 'items_per_page' (or 'itemsPerPage' alias) - Offset-based: Using 'offset' and 'limit'</p> <p>Attributes:</p> Name Type Description <code>offset</code> <code>Optional[int]</code> <p>Offset for unpaginated queries (used with limit)</p> <code>limit</code> <code>Optional[int]</code> <p>Limit for unpaginated queries (used with offset)</p> <code>page</code> <code>Optional[int]</code> <p>Page number for paginated queries</p> <code>items_per_page</code> <code>Optional[int]</code> <p>Number of items per page for paginated queries</p> <code>sort</code> <code>Optional[str]</code> <p>Sort results by one or more fields. Format: 'field1,-field2' where '-' prefix   indicates descending order. Example: 'name' (ascending), '-age' (descending),   'name,-age' (name ascending, then age descending).</p> Example <pre><code>from typing import Annotated\nfrom fastapi import Depends\nfrom fastcrud import PaginatedRequestQuery\n\nasync def custom_endpoint(\n    query: Annotated[PaginatedRequestQuery, Depends()]\n):\n    # Use query.page, query.items_per_page, query.sort, etc.\n    pass\n</code></pre> Source code in <code>fastcrud/core/pagination.py</code> <pre><code>class PaginatedRequestQuery(BaseModel):\n    \"\"\"\n    Pydantic model for paginated query parameters.\n\n    This model encapsulates all query parameters used for pagination and sorting\n    in read_items endpoints. It can be used with FastAPI's Depends() to inject\n    these parameters into endpoints, making it easy to reuse in custom endpoints.\n\n    Supports two pagination modes:\n    - Page-based: Using 'page' and 'items_per_page' (or 'itemsPerPage' alias)\n    - Offset-based: Using 'offset' and 'limit'\n\n    Attributes:\n        offset: Offset for unpaginated queries (used with limit)\n        limit: Limit for unpaginated queries (used with offset)\n        page: Page number for paginated queries\n        items_per_page: Number of items per page for paginated queries\n        sort: Sort results by one or more fields. Format: 'field1,-field2' where '-' prefix\n              indicates descending order. Example: 'name' (ascending), '-age' (descending),\n              'name,-age' (name ascending, then age descending).\n\n    Example:\n        ```python\n        from typing import Annotated\n        from fastapi import Depends\n        from fastcrud import PaginatedRequestQuery\n\n        async def custom_endpoint(\n            query: Annotated[PaginatedRequestQuery, Depends()]\n        ):\n            # Use query.page, query.items_per_page, query.sort, etc.\n            pass\n        ```\n    \"\"\"\n\n    offset: Optional[int] = Field(None, description=\"Offset for unpaginated queries\")\n    limit: Optional[int] = Field(None, description=\"Limit for unpaginated queries\")\n    page: Optional[int] = Field(None, alias=\"page\", description=\"Page number\")\n    items_per_page: Optional[int] = Field(\n        None, alias=\"itemsPerPage\", description=\"Number of items per page\"\n    )\n    sort: Optional[str] = Field(\n        None,\n        description=\"Sort results by one or more fields. Format: 'field1,-field2' where '-' prefix indicates descending order. Example: 'name' (ascending), '-age' (descending), 'name,-age' (name ascending, then age descending).\",\n    )\n\n    model_config = {\"populate_by_name\": True}\n</code></pre>"},{"location":"api/paginated/#fastcrud.core.pagination.compute_offset","title":"<code>compute_offset(page, items_per_page)</code>","text":"<p>Calculate the offset for pagination based on the given page number and items per page.</p> <p>The offset represents the starting point in a dataset for the items on a given page. For example, if each page displays 10 items and you want to display page 3, the offset will be 20, meaning the display should start with the 21st item.</p> <p>Parameters:</p> Name Type Description Default <code>page</code> <code>int</code> <p>The current page number. Page numbers should start from 1.</p> required <code>items_per_page</code> <code>int</code> <p>The number of items to be displayed on each page.</p> required <p>Returns:</p> Type Description <code>int</code> <p>The calculated offset.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; compute_offset(1, 10)\n0\n&gt;&gt;&gt; compute_offset(3, 10)\n20\n</code></pre> Source code in <code>fastcrud/core/pagination.py</code> <pre><code>def compute_offset(page: int, items_per_page: int) -&gt; int:\n    \"\"\"Calculate the offset for pagination based on the given page number and items per page.\n\n    The offset represents the starting point in a dataset for the items on a given page.\n    For example, if each page displays 10 items and you want to display page 3, the offset will be 20,\n    meaning the display should start with the 21st item.\n\n    Args:\n        page: The current page number. Page numbers should start from 1.\n        items_per_page: The number of items to be displayed on each page.\n\n    Returns:\n        The calculated offset.\n\n    Examples:\n        &gt;&gt;&gt; compute_offset(1, 10)\n        0\n        &gt;&gt;&gt; compute_offset(3, 10)\n        20\n    \"\"\"\n    return (page - 1) * items_per_page\n</code></pre>"},{"location":"api/paginated/#fastcrud.core.pagination.create_list_response","title":"<code>create_list_response(schema, response_key='data')</code>","text":"<p>Creates a dynamic ListResponse model with the specified response key.</p> Source code in <code>fastcrud/core/pagination.py</code> <pre><code>def create_list_response(\n    schema: Type[SchemaType], response_key: str = \"data\"\n) -&gt; Type[BaseModel]:\n    \"\"\"Creates a dynamic ListResponse model with the specified response key.\"\"\"\n    return create_model(\"DynamicListResponse\", **{response_key: (list[schema], ...)})  # type: ignore\n</code></pre>"},{"location":"api/paginated/#fastcrud.core.pagination.create_paginated_response","title":"<code>create_paginated_response(schema, response_key='data')</code>","text":"<p>Creates a dynamic PaginatedResponse model with the specified response key.</p> Source code in <code>fastcrud/core/pagination.py</code> <pre><code>def create_paginated_response(\n    schema: Type[SchemaType], response_key: str = \"data\"\n) -&gt; Type[BaseModel]:\n    \"\"\"Creates a dynamic PaginatedResponse model with the specified response key.\"\"\"\n    fields = {\n        response_key: (list[schema], ...),  # type: ignore\n        \"total_count\": (int, ...),\n        \"has_more\": (bool, ...),\n        \"page\": (Optional[int], None),\n        \"items_per_page\": (Optional[int], None),\n    }\n    return create_model(\"DynamicPaginatedResponse\", **fields)  # type: ignore\n</code></pre>"},{"location":"api/paginated/#fastcrud.core.pagination.paginated_response","title":"<code>paginated_response(crud_data, page, items_per_page, multi_response_key='data')</code>","text":"<p>Create a paginated response based on the provided data and pagination parameters.</p> <p>Parameters:</p> Name Type Description Default <code>crud_data</code> <code>dict</code> <p>Data to be paginated, including the list of items and total count.</p> required <code>page</code> <code>int</code> <p>Current page number.</p> required <code>items_per_page</code> <code>int</code> <p>Number of items per page.</p> required <code>multi_response_key</code> <code>str</code> <p>Key to use for the items list in the response (defaults to \"data\").</p> <code>'data'</code> <p>Returns:</p> Type Description <code>dict[str, Any]</code> <p>A structured paginated response dict containing the list of items, total count, pagination flags, and numbers.</p> Note <p>The function does not actually paginate the data but formats the response to indicate pagination metadata.</p> Source code in <code>fastcrud/core/pagination.py</code> <pre><code>def paginated_response(\n    crud_data: dict,\n    page: int,\n    items_per_page: int,\n    multi_response_key: str = \"data\",\n) -&gt; dict[str, Any]:\n    \"\"\"Create a paginated response based on the provided data and pagination parameters.\n\n    Args:\n        crud_data: Data to be paginated, including the list of items and total count.\n        page: Current page number.\n        items_per_page: Number of items per page.\n        multi_response_key: Key to use for the items list in the response (defaults to \"data\").\n\n    Returns:\n        A structured paginated response dict containing the list of items, total count, pagination flags, and numbers.\n\n    Note:\n        The function does not actually paginate the data but formats the response to indicate pagination metadata.\n    \"\"\"\n    items = crud_data.get(multi_response_key, [])\n    total_count = crud_data.get(\"total_count\", 0)\n\n    response = {\n        multi_response_key: items,\n        \"total_count\": total_count,\n        \"has_more\": (page * items_per_page) &lt; total_count,\n        \"page\": page,\n        \"items_per_page\": items_per_page,\n    }\n\n    return response\n</code></pre>"},{"location":"api/paginated/#backward-compatibility","title":"Backward Compatibility","text":"<p>For backward compatibility, the original imports still work but will issue deprecation warnings:</p> <p>Backward compatibility module for paginated utilities.</p> <p>.. deprecated:: 0.19.0    The <code>fastcrud.paginated</code> module is deprecated and will be removed in the next major version.    Please import pagination utilities directly from <code>fastcrud</code> instead:</p> <p>.. code-block:: python</p> <pre><code>   # Old (deprecated)\n   from fastcrud.paginated import PaginatedListResponse, PaginatedRequestQuery\n\n   # New (recommended)\n   from fastcrud import PaginatedListResponse, PaginatedRequestQuery\n</code></pre>"},{"location":"community/CODE_OF_CONDUCT/","title":"Contributor Covenant Code of Conduct","text":""},{"location":"community/CODE_OF_CONDUCT/#our-pledge","title":"Our Pledge","text":"<p>We as members, contributors, and leaders pledge to make participation in our community a harassment-free experience for everyone, regardless of age, body size, visible or invisible disability, ethnicity, sex characteristics, gender identity and expression, level of experience, education, socio-economic status, nationality, personal appearance, race, religion, or sexual identity and orientation.</p> <p>We pledge to act and interact in ways that contribute to an open, welcoming, diverse, inclusive, and healthy community.</p>"},{"location":"community/CODE_OF_CONDUCT/#our-standards","title":"Our Standards","text":"<p>Examples of behavior that contributes to a positive environment for our community include:</p> <ul> <li>Demonstrating empathy and kindness toward other people</li> <li>Being respectful of differing opinions, viewpoints, and experiences</li> <li>Giving and gracefully accepting constructive feedback</li> <li>Accepting responsibility and apologizing to those affected by our mistakes,   and learning from the experience</li> <li>Focusing on what is best not just for us as individuals, but for the   overall community</li> </ul> <p>Examples of unacceptable behavior include:</p> <ul> <li>The use of sexualized language or imagery, and sexual attention or   advances of any kind</li> <li>Trolling, insulting or derogatory comments, and personal or political attacks</li> <li>Public or private harassment</li> <li>Publishing others' private information, such as a physical or email   address, without their explicit permission</li> <li>Other conduct which could reasonably be considered inappropriate in a   professional setting</li> </ul>"},{"location":"community/CODE_OF_CONDUCT/#enforcement-responsibilities","title":"Enforcement Responsibilities","text":"<p>Community leaders are responsible for clarifying and enforcing our standards of acceptable behavior and will take appropriate and fair corrective action in response to any behavior that they deem inappropriate, threatening, offensive, or harmful.</p> <p>Community leaders have the right and responsibility to remove, edit, or reject comments, commits, code, wiki edits, issues, and other contributions that are not aligned to this Code of Conduct, and will communicate reasons for moderation decisions when appropriate.</p>"},{"location":"community/CODE_OF_CONDUCT/#scope","title":"Scope","text":"<p>This Code of Conduct applies within all community spaces, and also applies when an individual is officially representing the community in public spaces. Examples of representing our community include using an official e-mail address, posting via an official social media account, or acting as an appointed representative at an online or offline event.</p>"},{"location":"community/CODE_OF_CONDUCT/#enforcement","title":"Enforcement","text":"<p>Instances of abusive, harassing, or otherwise unacceptable behavior may be reported to the community leaders responsible for enforcement at igor.magalhaes.r@gmail.com. All complaints will be reviewed and investigated promptly and fairly.</p> <p>All community leaders are obligated to respect the privacy and security of the reporter of any incident.</p>"},{"location":"community/CODE_OF_CONDUCT/#enforcement-guidelines","title":"Enforcement Guidelines","text":"<p>Community leaders will follow these Community Impact Guidelines in determining the consequences for any action they deem in violation of this Code of Conduct:</p>"},{"location":"community/CODE_OF_CONDUCT/#1-correction","title":"1. Correction","text":"<p>Community Impact: Use of inappropriate language or other behavior deemed unprofessional or unwelcome in the community.</p> <p>Consequence: A private, written warning from community leaders, providing clarity around the nature of the violation and an explanation of why the behavior was inappropriate. A public apology may be requested.</p>"},{"location":"community/CODE_OF_CONDUCT/#2-warning","title":"2. Warning","text":"<p>Community Impact: A violation through a single incident or series of actions.</p> <p>Consequence: A warning with consequences for continued behavior. No interaction with the people involved, including unsolicited interaction with those enforcing the Code of Conduct, for a specified period of time. This includes avoiding interactions in community spaces as well as external channels like social media. Violating these terms may lead to a temporary or permanent ban.</p>"},{"location":"community/CODE_OF_CONDUCT/#3-temporary-ban","title":"3. Temporary Ban","text":"<p>Community Impact: A serious violation of community standards, including sustained inappropriate behavior.</p> <p>Consequence: A temporary ban from any sort of interaction or public communication with the community for a specified period of time. No public or private interaction with the people involved, including unsolicited interaction with those enforcing the Code of Conduct, is allowed during this period. Violating these terms may lead to a permanent ban.</p>"},{"location":"community/CODE_OF_CONDUCT/#4-permanent-ban","title":"4. Permanent Ban","text":"<p>Community Impact: Demonstrating a pattern of violation of community standards, including sustained inappropriate behavior,  harassment of an individual, or aggression toward or disparagement of classes of individuals.</p> <p>Consequence: A permanent ban from any sort of public interaction within the community.</p>"},{"location":"community/CODE_OF_CONDUCT/#attribution","title":"Attribution","text":"<p>This Code of Conduct is adapted from the Contributor Covenant, version 2.0, available at https://www.contributor-covenant.org/version/2/0/code_of_conduct.html.</p> <p>Community Impact Guidelines were inspired by Mozilla's code of conduct enforcement ladder.</p> <p>For answers to common questions about this code of conduct, see the FAQ at https://www.contributor-covenant.org/faq. Translations are available at https://www.contributor-covenant.org/translations.</p>"},{"location":"community/CONTRIBUTING/","title":"Contributing to FastCRUD","text":"<p>We're excited that you're interested in contributing to FastCRUD! This guide will help you understand our development process, architectural principles, and how to make meaningful contributions.</p>"},{"location":"community/CONTRIBUTING/#getting-started","title":"Getting Started","text":""},{"location":"community/CONTRIBUTING/#prerequisites","title":"Prerequisites","text":"<p>Before you begin, make sure you have:</p> <ul> <li>Python 3.9+ installed</li> <li>UV for dependency management (install UV)</li> <li>Git for version control</li> <li>A GitHub account for submitting pull requests</li> </ul>"},{"location":"community/CONTRIBUTING/#setting-up-your-development-environment","title":"Setting Up Your Development Environment","text":"<ol> <li> <p>Fork and Clone <pre><code>git clone https://github.com/your-username/fastcrud.git\ncd fastcrud\n</code></pre></p> </li> <li> <p>Install Dependencies <pre><code>uv sync\n</code></pre></p> </li> <li> <p>Verify Installation <pre><code>uv run pytest --version\nuv run mypy --version\n</code></pre></p> </li> </ol>"},{"location":"community/CONTRIBUTING/#understanding-the-architecture","title":"Understanding the Architecture","text":"<p>Architecture Overview</p> <p>FastCRUD follows a six-level dependency hierarchy designed to prevent circular dependencies and ensure clean separation of concerns. Understanding this architecture is crucial for effective contributions.</p>"},{"location":"community/CONTRIBUTING/#dependency-levels","title":"Dependency Levels","text":"<pre><code>graph TB\n    subgraph \"Level 6: Framework\"\n        A[fastapi_dependencies.py]\n        B[endpoint/]\n    end\n\n    subgraph \"Level 5: CRUD\"\n        C[crud/fast_crud.py]\n        D[crud/validation.py]\n    end\n\n    subgraph \"Level 4: Integration\"\n        E[core/data/formatting.py]\n        F[core/join_processing.py]\n    end\n\n    subgraph \"Level 3: Orchestration\"\n        G[core/query/]\n        H[core/data/nesting.py]\n    end\n\n    subgraph \"Level 2: Core Logic\"\n        I[core/config/]\n        J[core/data/transforms.py]\n    end\n\n    subgraph \"Level 1: Foundation\"\n        K[core/protocols.py]\n        L[core/introspection.py]\n    end\n\n    A --&gt; C\n    C --&gt; E\n    E --&gt; H\n    H --&gt; J\n    J --&gt; L</code></pre>"},{"location":"community/CONTRIBUTING/#key-principles","title":"Key Principles","text":"<p>Protocol-Based Design: We use Python protocols instead of concrete class dependencies to maintain loose coupling and enable better testing.</p> <p>Framework Separation: All FastAPI-specific code is isolated in dedicated modules, keeping the core business logic framework-agnostic.</p> <p>Pure Functions: Data transformation operations are implemented as pure functions wherever possible, making them easy to test and reason about.</p>"},{"location":"community/CONTRIBUTING/#making-your-first-contribution","title":"Making Your First Contribution","text":""},{"location":"community/CONTRIBUTING/#1-choose-your-contribution","title":"1. Choose Your Contribution","text":"<p>Good first contributions include:</p> <ul> <li>Bug fixes in existing functionality</li> <li>Documentation improvements and examples</li> <li>Test coverage enhancements</li> <li>Small feature additions that fit the existing patterns</li> </ul>"},{"location":"community/CONTRIBUTING/#2-plan-your-changes","title":"2. Plan Your Changes","text":"<p>Before coding:</p> <ol> <li>Read the relevant architecture section to understand where your changes should go</li> <li>Check existing patterns in similar code</li> <li>Consider the dependency hierarchy - ensure your changes don't create circular imports</li> <li>Write tests first when adding new functionality</li> </ol>"},{"location":"community/CONTRIBUTING/#3-code-standards","title":"3. Code Standards","text":""},{"location":"community/CONTRIBUTING/#import-organization","title":"Import Organization","text":"<pre><code># Standard library imports first\nfrom typing import Any, Optional, Union\n\n# Third-party imports\nfrom fastapi import FastAPI\nfrom sqlalchemy import select\n\n# Local imports - respect the dependency hierarchy\nfrom ..core import ModelInspector  # Lower level\nfrom .validation import validate_params  # Same level\n</code></pre>"},{"location":"community/CONTRIBUTING/#type-annotations","title":"Type Annotations","text":"<pre><code># Use protocols for interfaces\ndef process_data(processor: DataProcessor) -&gt; ProcessedResult:\n    \"\"\"Use protocols instead of concrete classes.\"\"\"\n    pass\n\n# Be explicit with return types\nasync def get_item(db: AsyncSession, item_id: int) -&gt; Optional[Item]:\n    \"\"\"Clear return type annotations.\"\"\"\n    pass\n</code></pre>"},{"location":"community/CONTRIBUTING/#function-design","title":"Function Design","text":"<pre><code># Pure functions when possible\ndef transform_data(data: dict[str, Any]) -&gt; dict[str, Any]:\n    \"\"\"No side effects, easy to test.\"\"\"\n    return processed_data\n\n# Clear single responsibility\nasync def validate_and_create_item(\n    db: AsyncSession, \n    item_data: CreateItemSchema\n) -&gt; Item:\n    \"\"\"One clear purpose per function.\"\"\"\n    validated_data = validate_item_data(item_data)\n    return await create_item(db, validated_data)\n</code></pre>"},{"location":"community/CONTRIBUTING/#development-workflow","title":"Development Workflow","text":""},{"location":"community/CONTRIBUTING/#running-tests","title":"Running Tests","text":"<pre><code># Run all tests\nuv run pytest\n\n# Run with coverage\nuv run pytest --cov=fastcrud\n\n# Run specific test file\nuv run pytest tests/test_crud.py\n\n# Run with verbose output\nuv run pytest -v\n</code></pre>"},{"location":"community/CONTRIBUTING/#code-quality-checks","title":"Code Quality Checks","text":"<pre><code># Type checking\nuv run mypy fastcrud\n\n# Linting and formatting\nuv run ruff check --fix\nuv run ruff format\n\n# Run all checks\nuv run pytest &amp;&amp; uv run mypy fastcrud &amp;&amp; uv run ruff check\n</code></pre>"},{"location":"community/CONTRIBUTING/#testing-your-changes","title":"Testing Your Changes","text":"<ol> <li>Unit tests for individual functions</li> <li>Integration tests for component interactions  </li> <li>End-to-end tests for complete workflows</li> <li>Manual testing with the documentation examples</li> </ol>"},{"location":"community/CONTRIBUTING/#contribution-guidelines","title":"Contribution Guidelines","text":""},{"location":"community/CONTRIBUTING/#pull-request-process","title":"Pull Request Process","text":"<ol> <li> <p>Create a feature branch <pre><code>git checkout -b feature/your-feature-name\n</code></pre></p> </li> <li> <p>Make your changes following the architecture principles</p> </li> <li> <p>Add tests for new functionality</p> </li> <li> <p>Update documentation if needed</p> </li> <li> <p>Run the full test suite <pre><code>uv run pytest &amp;&amp; uv run mypy fastcrud &amp;&amp; uv run ruff check\n</code></pre></p> </li> <li> <p>Submit your pull request with a clear description</p> </li> </ol>"},{"location":"community/CONTRIBUTING/#pull-request-template","title":"Pull Request Template","text":"<p>When submitting a PR, include:</p> <ul> <li>What you changed and why</li> <li>How to test your changes</li> <li>Screenshots for UI changes (if applicable)</li> <li>Breaking changes (if any)</li> <li>Related issues (if applicable)</li> </ul>"},{"location":"community/CONTRIBUTING/#common-contribution-scenarios","title":"Common Contribution Scenarios","text":""},{"location":"community/CONTRIBUTING/#adding-a-new-crud-method","title":"Adding a New CRUD Method","text":"<ol> <li>Add the method to <code>FastCRUD</code> class in <code>crud/fast_crud.py</code></li> <li>Add validation in <code>crud/validation.py</code> if needed</li> <li>Add tests in <code>tests/test_crud.py</code></li> <li>Update type hints and ensure protocol compliance</li> </ol>"},{"location":"community/CONTRIBUTING/#adding-a-new-filter-operator","title":"Adding a New Filter Operator","text":"<ol> <li>Add the operator in <code>core/filtering/operators.py</code></li> <li>Update the processor in <code>core/filtering/processor.py</code></li> <li>Add validation in <code>core/filtering/validators.py</code></li> <li>Add tests and documentation examples</li> </ol>"},{"location":"community/CONTRIBUTING/#adding-framework-support","title":"Adding Framework Support","text":"<ol> <li>Create adapter module in the framework layer (Level 6)</li> <li>Keep core logic unchanged - only add framework-specific bindings</li> <li>Follow the protocol interfaces for consistency</li> <li>Add comprehensive tests for the new framework</li> </ol>"},{"location":"community/CONTRIBUTING/#getting-help","title":"Getting Help","text":"<ul> <li>Documentation: Check our Architecture page for detailed design information</li> <li>Discussions: Use GitHub Discussions for questions</li> <li>Issues: Create an issue for bugs or feature requests</li> <li>Discord: Join our community for real-time help</li> </ul>"},{"location":"community/CONTRIBUTING/#recognition","title":"Recognition","text":"<p>All contributors are recognized in our changelog and contributor list. We appreciate every contribution, no matter how small!</p> <p>Thank you for contributing to FastCRUD! \ud83d\ude80</p>"},{"location":"community/LICENSE/","title":"License","text":"<p>MIT License</p> <p>Copyright (c) 2023 Igor Magalh\u00e3es</p> <p>Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:</p> <p>The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.</p> <p>THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.</p>"},{"location":"community/architecture/","title":"Understanding FastCRUD","text":"<p>The architecture, design decisions, and structure that keep your CRUD operations sane.</p> <p>You have FastCRUD running. Now you need to understand how it's built and why. This is a technical discussion about the architecture, the tradeoffs we made, and how the pieces fit together.</p>"},{"location":"community/architecture/#six-layer-architecture","title":"Six-Layer Architecture","text":"<p>FastCRUD follows a strict six-level dependency hierarchy because it solves real problems in maintaining and scaling CRUD applications.</p> <pre><code>fastcrud/\n\u251c\u2500\u2500 fastapi_dependencies.py    # Level 6: Framework\n\u251c\u2500\u2500 crud/                      # Level 5: CRUD Operations\n\u251c\u2500\u2500 core/data/formatting.py    # Level 4: Integration\n\u251c\u2500\u2500 core/query/               # Level 3: Orchestration\n\u251c\u2500\u2500 core/data/transforms.py   # Level 2: Core Logic\n\u2514\u2500\u2500 core/protocols.py         # Level 1: Foundation\n</code></pre> <p>The separation is strict. Framework never imports from CRUD. CRUD never imports from core orchestration. Dependencies flow in one direction: Framework \u2192 CRUD \u2192 Integration \u2192 Orchestration \u2192 Core \u2192 Foundation.</p> <p>When debugging, if join operations break, you know it's in the Integration layer. If filter parsing is wrong, start in Orchestration. If data transformation fails, check Core Logic. You don't hunt through the codebase - you know exactly where each piece of logic lives.</p> <pre><code>graph TB\n    subgraph \"Level 6: Framework Layer\"\n        FastAPI[fastapi_dependencies.py]\n        Endpoints[endpoint/]\n    end\n\n    subgraph \"Level 5: CRUD Layer\"\n        FastCRUD[crud/fast_crud.py]\n        Validation[crud/validation.py]\n        Execution[crud/execution.py]\n        DataPrep[crud/data_preparation.py]\n        DBSpecific[crud/database_specific.py]\n    end\n\n    subgraph \"Level 4: Integration Layer\"\n        DataFormat[core/data/formatting.py]\n        JoinProc[core/join_processing.py]\n    end\n\n    subgraph \"Level 3: Orchestration Layer\"\n        Query[core/query/]\n        FieldMgmt[core/field_management.py]\n        DataNest[core/data/nesting.py]\n    end\n\n    subgraph \"Level 2: Core Logic Layer\"\n        Config[core/config/]\n        Filtering[core/filtering/]\n        DataTrans[core/data/transforms.py]\n        Pagination[core/pagination.py]\n    end\n\n    subgraph \"Level 1: Foundation Layer\"\n        Protocols[core/protocols.py]\n        Introspection[core/introspection.py]\n        Types[types.py]\n    end\n\n    FastAPI --&gt; FastCRUD\n    Endpoints --&gt; FastAPI\n    FastCRUD --&gt; DataFormat\n    FastCRUD --&gt; JoinProc\n    DataFormat --&gt; DataNest\n    JoinProc --&gt; DataTrans\n    DataNest --&gt; DataTrans\n    Query --&gt; Config\n    FieldMgmt --&gt; DataTrans\n    DataTrans --&gt; Types\n    Config --&gt; Protocols\n    Filtering --&gt; Introspection\n    DataFormat --&gt; Introspection</code></pre>"},{"location":"community/architecture/#foundation-layer-level-1","title":"Foundation Layer (Level 1)","text":"<p>The foundation layer contains the building blocks that everything else depends on. Database introspection, type definitions, and the Protocol interfaces that prevent circular dependencies.</p> <pre><code>core/\n\u251c\u2500\u2500 protocols.py        # Protocol definitions for loose coupling\n\u251c\u2500\u2500 introspection.py   # SQLAlchemy model inspection utilities\n\u2514\u2500\u2500 types.py          # Type definitions and aliases\n</code></pre> <p>protocols.py - This is where we break circular dependencies. Instead of importing concrete classes and creating import loops, we define Protocol interfaces:</p> <pre><code>class CRUDInstance(Protocol):\n    model: Any\n    async def get_multi_joined(self, db: Any, **kwargs: Any) -&gt; Union[Dict[str, Any], Any]: ...\n</code></pre> <p>The execution layer can depend on this protocol without knowing about the actual FastCRUD class. Clean separation, no circular imports.</p> <p>introspection.py - Figure out primary keys, relationships, column types - all the stuff you need to build dynamic queries without hardcoding model details.</p> <p>This foundation is boring by design. It doesn't change often, which means everything built on top stays stable.</p>"},{"location":"community/architecture/#core-logic-layer-level-2","title":"Core Logic Layer (Level 2)","text":"<p>Pure business logic. No database connections, no FastAPI dependencies, no external service calls. Just the rules for how CRUD operations should work.</p> <pre><code>core/\n\u251c\u2500\u2500 config/              # Configuration and settings\n\u251c\u2500\u2500 filtering/           # Filter processing and validation\n\u251c\u2500\u2500 data/transforms.py   # Pure data transformation functions\n\u2514\u2500\u2500 pagination.py       # Pagination logic and utilities\n</code></pre> <p>data/transforms.py - Pure functions that transform data structures. Take a list of join results, reshape them into nested objects. Take query results, format them for API responses. No side effects, easy to test:</p> <pre><code>def handle_one_to_many(data: List[Dict], nested_key: str) -&gt; List[Dict]:\n    \"\"\"Transform flat join results into nested structures.\"\"\"\n    # Pure function - same input always produces same output\n    pass\n</code></pre> <p>filtering/ - All the logic for parsing filter expressions like <code>name__icontains</code> or <code>age__gte</code>. Validation, operator mapping, SQL generation - but no actual database calls. That happens higher up.</p> <p>pagination.py - Offset calculations, limit validation, cursor generation. The math and logic of pagination without any database specifics.</p> <p>This layer is where the business rules live. How should pagination work? What filter operators make sense? How do you nest joined data? Pure logic, no infrastructure concerns.</p>"},{"location":"community/architecture/#orchestration-layer-level-3","title":"Orchestration Layer (Level 3)","text":"<p>This is where simple operations get combined into complex workflows. Query building, field management, data nesting - operations that coordinate multiple core logic functions.</p> <pre><code>core/\n\u251c\u2500\u2500 query/               # SQL query building and composition\n\u251c\u2500\u2500 field_management.py  # Field selection and projection logic\n\u2514\u2500\u2500 data/nesting.py     # Data nesting with introspection\n</code></pre> <p>query/ - Builds SQLAlchemy queries from filter parameters, sort orders, join configurations. Takes the pure logic from filtering and pagination and turns it into actual SQL:</p> <pre><code># Takes filter config from core logic\nfilters = {\"name__icontains\": \"admin\", \"status\": \"active\"}\n\n# Builds actual SQLAlchemy query\nquery = select(User).where(\n    User.name.ilike(\"%admin%\"),\n    User.status == \"active\"\n)\n</code></pre> <p>data/nesting.py - Combines data transformation with model introspection. Knows how to take flat join results and reconstruct the object relationships based on SQLAlchemy model definitions.</p> <p>This layer knows about SQLAlchemy but not about FastAPI or your specific database setup. It orchestrates operations but doesn't execute them.</p>"},{"location":"community/architecture/#integration-layer-level-4","title":"Integration Layer (Level 4)","text":"<p>Where everything comes together. Complex join processing, response formatting, coordinating between different subsystems.</p> <pre><code>core/\n\u251c\u2500\u2500 data/formatting.py    # Response formatting with join processing\n\u2514\u2500\u2500 join_processing.py   # SQL join coordination and execution\n</code></pre> <p>join_processing.py - The complexity of SQL joins made manageable. Handles join condition detection, nested loading, avoiding N+1 queries:</p> <pre><code># Automatically detects that User.tier_id == Tier.id\n# Builds efficient joins instead of separate queries\nusers_with_tiers = await get_multi_joined(\n    db,\n    joins_config=[JoinConfig(model=Tier, join_prefix=\"tier_\")]\n)\n</code></pre> <p>data/formatting.py - Takes query results and formats them for API responses. Handles nested data, field selection, type conversion. The bridge between your database results and what your API sends to clients.</p> <p>This layer knows about your specific use cases but stays framework-agnostic. It could work with FastAPI, Flask, or any other web framework.</p>"},{"location":"community/architecture/#crud-layer-level-5","title":"CRUD Layer (Level 5)","text":"<p>The main FastCRUD functionality. This is what you interact with directly - the methods that create, read, update, and delete your data.</p> <pre><code>crud/\n\u251c\u2500\u2500 fast_crud.py          # Main CRUD class and public interface\n\u251c\u2500\u2500 validation.py         # Input validation and sanitization\n\u251c\u2500\u2500 execution.py         # Query execution coordination\n\u251c\u2500\u2500 data_preparation.py   # Data preparation for database operations\n\u2514\u2500\u2500 database_specific.py  # Database-specific optimizations\n</code></pre> <p>fast_crud.py - The public interface. When you call <code>crud.get_multi()</code> or <code>crud.create()</code>, this is what you're calling. Clean, simple methods that hide the complexity underneath.</p> <p>execution.py - Coordinates the actual database operations. Takes queries from the orchestration layer and executes them. Handles transactions, error recovery, result processing.</p> <p>validation.py - Validates your inputs before they hit the database. Type checking, constraint validation, security checks. Better to catch problems here than in a failed database transaction.</p> <p>The CRUD layer is opinionated about how CRUD operations should work, but flexible about how you use them.</p>"},{"location":"community/architecture/#framework-layer-level-6","title":"Framework Layer (Level 6)","text":"<p>FastAPI-specific code. Dependency injection, endpoint creation, HTTP request/response handling.</p> <pre><code>\u251c\u2500\u2500 fastapi_dependencies.py  # FastAPI dependency providers\n\u2514\u2500\u2500 endpoint/               # Automatic endpoint generation\n</code></pre> <p>fastapi_dependencies.py - All the FastAPI-specific stuff. Session management, dependency injection, request parsing. Keeps framework concerns separate from business logic.</p> <p>endpoint/ - Automatic CRUD endpoint generation. Point it at a model and schema, get full CRUD endpoints with pagination, filtering, and validation.</p> <p>This layer could be replaced with Flask, Django, or any other framework without touching the layers below. That's the point.</p>"},{"location":"community/architecture/#design-decisions","title":"Design Decisions","text":""},{"location":"community/architecture/#why-protocol-based-architecture","title":"Why Protocol-Based Architecture?","text":"<p>You've probably seen codebases where everything imports everything else. Change one file, break three others. Import errors that make no sense. Circular dependency hell.</p> <p>We use Python protocols instead of concrete class dependencies:</p> <pre><code># Instead of this (creates circular imports)\nfrom ..crud.fast_crud import FastCRUD\n\ndef some_function(crud: FastCRUD):\n    pass\n\n# We do this (clean, no circular imports)\nfrom ..core.protocols import CRUDInstance\n\ndef some_function(crud: CRUDInstance):\n    pass\n</code></pre> <p>Protocols define interfaces without implementation. The execution layer knows what methods a CRUD instance should have, but it doesn't need to import the actual FastCRUD class. Duck typing made explicit.</p> <p>You can test components in isolation. You can swap implementations without changing dependent code. You can understand one layer without knowing about all the others.</p>"},{"location":"community/architecture/#why-six-levels-instead-of-three","title":"Why Six Levels Instead of Three?","text":"<p>Most architectures have three layers - presentation, business, data. We have six. Why the complexity?</p> <p>Because three layers don't stay three layers. Your \"business logic\" layer grows. Soon you have database queries mixed with validation mixed with data transformation mixed with API formatting. Everything becomes interdependent.</p> <p>Six levels force separation:</p> <ul> <li>Data transformation (pure functions) stays separate from validation (which might hit the database)</li> <li>Query building stays separate from query execution</li> <li>Framework concerns stay separate from business logic</li> </ul> <p>When something breaks, you know which level to check. When you need to change how filtering works, you know it's in the Core Logic layer, not scattered across three giant files.</p>"},{"location":"community/architecture/#framework-separation-strategy","title":"Framework Separation Strategy","text":"<p>All FastAPI-specific code lives in Level 6. Everything below that could work with any web framework.</p> <p>If you need to add a GraphQL endpoint, or build a CLI tool, you don't rewrite your CRUD logic. You just build a new Level 6.</p> <pre><code># This works with FastAPI\nfrom fastcrud import crud_router\n\n# This would work with Flask\nfrom fastcrud.flask import crud_blueprint\n\n# This would work with Django\nfrom fastcrud.django import CRUDViewSet\n</code></pre> <p>(We don't ship Flask or Django adapters yet, but the architecture supports it.)</p>"},{"location":"community/architecture/#pure-functions-where-possible","title":"Pure Functions Where Possible","text":"<p>Data transformation operations are pure functions:</p> <pre><code>def handle_one_to_many(data: List[Dict], nested_key: str) -&gt; List[Dict]:\n    \"\"\"No side effects. Same input = same output. Easy to test.\"\"\"\n    pass\n</code></pre> <p>Pure functions are easier to test, easier to debug, and easier to reason about. When you call this function, you know it won't modify your input data, make database calls, or send emails. It just transforms data.</p> <p>Not everything can be pure - database operations have side effects by definition. But when we can make something pure, we do.</p>"},{"location":"community/architecture/#understanding-the-data-flow","title":"Understanding the Data Flow","text":"<p>Let's trace what happens when you call <code>await crud.get_multi_joined()</code>. This shows how the layers actually work together:</p> <p>Request starts at Level 5 (CRUD): <pre><code># crud/fast_crud.py\nasync def get_multi_joined(self, db, joins_config=None, **kwargs):\n    # Delegates to execution layer for filter handling\n    return await handle_joined_filters_delegation(self, db, joins_config, **kwargs)\n</code></pre></p> <p>Execution coordination at Level 5 (CRUD): <pre><code># crud/execution.py\nasync def handle_joined_filters_delegation(crud_instance, db, joins_config, **kwargs):\n    # Uses validation to clean inputs\n    validated_params = validate_joined_query_params(joins_config, **kwargs)\n\n    # Delegates to join processing\n    return await execute_joined_query(db, crud_instance.model, validated_params)\n</code></pre></p> <p>Join processing at Level 4 (Integration): <pre><code># core/join_processing.py\nasync def process_joined_query(db, model, params):\n    # Uses query building to construct SQL\n    query = build_joined_query(model, params.joins, params.filters)\n\n    # Executes query\n    result = await db.execute(query)\n\n    # Uses formatting to structure response\n    return format_joined_response(result, params.joins)\n</code></pre></p> <p>Query building at Level 3 (Orchestration): <pre><code># core/query/builder.py\ndef build_joined_query(model, joins, filters):\n    # Uses filtering logic to parse conditions\n    where_clause = build_filter_conditions(filters)\n\n    # Uses join configuration to build joins\n    join_clause = build_join_conditions(model, joins)\n\n    return select(model).where(where_clause).outerjoin(join_clause)\n</code></pre></p> <p>Data formatting at Level 4 (Integration): <pre><code># core/data/formatting.py\ndef format_joined_response(raw_results, joins_config):\n    # Uses pure transformation functions\n    nested_data = nest_join_data(raw_results, joins_config)\n\n    # Uses more pure functions\n    return transform_to_response_format(nested_data)\n</code></pre></p> <p>Each layer has one job. CRUD orchestrates. Execution coordinates. Integration formats. Orchestration builds queries. Core Logic processes data. Foundation provides utilities.</p> <p>When you need to debug, you know exactly where each operation happens. Query too slow? Check Orchestration. Wrong data format? Check Integration. Validation failing? Check CRUD validation.</p> <p>The Payoff of Layer Separation</p> <p>When you need to add cursor pagination, you change one function in Core Logic. The CRUD layer doesn't care how pagination works.</p> <p>When you need to support MongoDB, you swap out the Orchestration layer. The Core Logic stays the same.</p> <p>When you need to add GraphQL endpoints, you build a new Framework layer. Everything below stays unchanged.</p> <p>This is why debugging is straightforward. Each layer has clear responsibilities, so failures tell you exactly where to look.</p>"},{"location":"community/architecture/#protocol-implementation-pattern","title":"Protocol Implementation Pattern","text":"<p>Here's how we actually use protocols to avoid circular dependencies:</p> <p>Step 1: Define the interface (Level 1 - Foundation) <pre><code># core/protocols.py\nclass CRUDInstance(Protocol):\n    model: Any\n    async def get_multi_joined(self, db: Any, **kwargs: Any) -&gt; Union[Dict[str, Any], Any]: ...\n</code></pre></p> <p>Step 2: Use the protocol (Level 5 - CRUD) <pre><code># crud/execution.py\nfrom ..core.protocols import CRUDInstance\n\nasync def handle_joined_filters_delegation(crud_instance: CRUDInstance, ...):\n    # Type checker knows what methods are available\n    # No circular import with actual FastCRUD class\n    pass\n</code></pre></p> <p>Step 3: Implement the protocol (Level 5 - CRUD) <pre><code># crud/fast_crud.py\nclass FastCRUD:\n    # Automatically satisfies CRUDInstance protocol\n    async def get_multi_joined(self, db, **kwargs):\n        # Delegates to execution layer, which uses the protocol\n        return await handle_joined_filters_delegation(self, db, **kwargs)\n</code></pre></p> <p>This creates a clean dependency flow. Lower levels define interfaces. Higher levels implement them. No circular imports, no runtime dependency resolution, no magic.</p>"},{"location":"community/architecture/#performance-considerations","title":"Performance Considerations","text":"<p>Performance isn't about making everything fast - it's about making the right things fast and accepting tradeoffs elsewhere.</p> <p>Lazy loading is disabled completely. SQLAlchemy's lazy loading creates N+1 queries:</p> <pre><code># This would create N+1 queries with lazy loading\nusers = await crud.get_multi(db, limit=100)\nfor user in users:\n    print(user.tier.name)  # Separate query for each user!\n\n# Instead, use explicit joins\nusers = await crud.get_multi_joined(\n    db,\n    joins_config=[JoinConfig(model=Tier, join_prefix=\"tier_\")],\n    limit=100\n)\n</code></pre> <p>More typing upfront, but predictable query patterns. You always know exactly what SQL gets generated.</p> <p>Protocol dispatch is fast. Python protocols compile to regular method calls. No performance overhead compared to duck typing, but with type safety.</p> <p>Query building is cached. Complex filter parsing gets memoized. Build the same query twice, get the same SQL without re-parsing.</p> <p>Data transformation is optimized for the common case. Simple operations (no joins, basic pagination) take the fast path. Complex operations (multiple joins, nested data) take the comprehensive path.</p> <p>The pattern is: optimize for the common case, make the complex case possible but not necessarily fast.</p>"},{"location":"community/architecture/#error-handling-strategy","title":"Error Handling Strategy","text":"<p>Errors happen. The question is how gracefully you handle them and how quickly you can debug them.</p> <p>Layer-specific exceptions. Each layer raises exceptions that make sense for that layer:</p> <pre><code># Foundation layer - low-level issues\nclass ModelIntrospectionError(Exception): pass\n\n# Core Logic layer - business rule violations\nclass InvalidFilterError(Exception): pass\n\n# CRUD layer - operation-specific problems\nclass JoinConfigurationError(Exception): pass\n</code></pre> <p>When something fails, the exception type tells you which layer to investigate.</p> <p>Fail fast principle. Validate inputs as early as possible:</p> <pre><code># Validate join configuration before building queries\nif not joins_config:\n    raise ValueError(\"joins_config cannot be empty\")\n\n# Much better than failing deep in SQL generation\n</code></pre> <p>Better to catch problems in validation than in a failed database transaction.</p> <p>Preserve error context. When re-raising exceptions, preserve the original context:</p> <pre><code>try:\n    result = await complex_operation()\nexcept SQLAlchemyError as e:\n    raise CRUDOperationError(f\"Failed to execute joined query: {e}\") from e\n</code></pre> <p>You get both the high-level context (what operation failed) and the low-level details (why it failed).</p>"},{"location":"community/architecture/#testing-strategy","title":"Testing Strategy","text":"<p>Each layer can be tested in isolation, which makes testing faster and more focused.</p> <p>Foundation layer tests are pure unit tests: <pre><code>def test_handle_one_to_many():\n    input_data = [{\"id\": 1, \"name\": \"user\", \"posts\": []}]\n    result = handle_one_to_many(input_data, \"posts\")\n    assert result == expected_structure\n</code></pre></p> <p>Core Logic layer tests are still unit tests but might use more complex fixtures: <pre><code>def test_filter_parsing():\n    filters = {\"name__icontains\": \"admin\", \"age__gte\": 18}\n    parsed = parse_filters(filters, User)\n    assert len(parsed.conditions) == 2\n</code></pre></p> <p>CRUD layer tests use database fixtures: <pre><code>async def test_get_multi_joined(db_session, sample_users):\n    crud = FastCRUD(User)\n    result = await crud.get_multi_joined(\n        db_session,\n        joins_config=[JoinConfig(model=Tier)]\n    )\n    assert len(result) == len(sample_users)\n</code></pre></p> <p>The layer separation makes it easy to test components without setting up the entire system.</p>"},{"location":"community/architecture/#migration-and-versioning-strategy","title":"Migration and Versioning Strategy","text":"<p>FastCRUD's architecture makes it easy to evolve without breaking existing code.</p> <p>Protocols enable interface versioning: <pre><code>class CRUDInstanceV2(Protocol):\n    # Extended interface\n    async def get_multi_joined(self, db: Any, **kwargs: Any) -&gt; Union[Dict[str, Any], Any]: ...\n    async def get_multi_with_count(self, db: Any, **kwargs: Any) -&gt; Dict[str, Any]: ...\n</code></pre></p> <p>Old code keeps working with <code>CRUDInstance</code>. New code can use <code>CRUDInstanceV2</code>.</p> <p>Layer isolation limits change impact: - Change query building logic? Only affects Level 3 and above - Change data transformation? Only affects Level 2 and above - Change FastAPI integration? Only affects Level 6</p> <p>Backward compatibility by design: <pre><code># Old way still works\nresult = await crud.get_multi(db, name=\"admin\")\n\n# New way adds features\nresult = await crud.get_multi(\n    db,\n    name=\"admin\",\n    advanced_filters={\"created_at__gte\": yesterday}\n)\n</code></pre></p> <p>The architecture doesn't force you to rewrite existing code when new features get added.</p>"},{"location":"community/architecture/#common-patterns-and-idioms","title":"Common Patterns and Idioms","text":"<p>Here are the patterns you'll see throughout FastCRUD:</p> <p>Delegation pattern - Higher levels delegate to lower levels: <pre><code># FastCRUD delegates to execution\nasync def get_multi_joined(self, db, **kwargs):\n    return await handle_joined_operations(self, db, **kwargs)\n</code></pre></p> <p>Protocol injection - Use protocols instead of concrete dependencies: <pre><code>def process_data(crud: CRUDInstance, processor: DataProcessor):\n    # Works with any implementation of these protocols\n    pass\n</code></pre></p> <p>Pure function composition - Build complex operations from simple functions: <pre><code>def format_response(data):\n    return apply_field_selection(\n        apply_sorting(\n            apply_pagination(data)\n        )\n    )\n</code></pre></p> <p>Early validation - Check inputs before doing expensive work: <pre><code>async def complex_operation(params):\n    validate_params(params)  # Fast\n    result = await expensive_database_operation(params)  # Slow\n    return result\n</code></pre></p> <p>These patterns create consistency across the codebase. Once you learn them, you can predict how any part of FastCRUD works.</p>"},{"location":"community/architecture/#next-steps","title":"Next Steps","text":"<p>Now that you understand the architecture:</p> <ol> <li>Explore the layers - Pick one layer and trace through how it works</li> <li>Follow a request - Use the debugger to step through a complete CRUD operation</li> <li>Understand the tradeoffs - Each design decision has pros and cons. What are they?</li> </ol> <p>The architecture exists to solve real problems. It's not perfect, but it's predictable. When something breaks at 3 AM, you'll know exactly where to look.</p> <p>Ready to contribute? Check out our contributing guide for the practical details of working with this architecture.</p> <p>The architecture serves the code, not the other way around. Every decision was made to solve real problems we encountered while building CRUD applications. Use what works, understand what doesn't, and help us make it better.</p>"},{"location":"community/overview/","title":"Community Overview","text":"<p>Welcome to the FastCRUD community hub! Here, you'll find essential resources and guidelines that are crucial for contributing to and participating in the project. Please take the time to familiarize yourself with the following documents:</p>"},{"location":"community/overview/#table-of-contents","title":"Table of Contents","text":"<ul> <li>Architecture</li> <li>Contributing</li> <li>Code of Conduct</li> <li>License</li> </ul>"},{"location":"community/overview/#architecture","title":"Architecture","text":"<p>View the Architecture Guide</p> <p>Understanding FastCRUD's architecture is essential for effective contributions. The architecture guide explains our six-level dependency hierarchy, protocol-based design, and framework separation principles that keep the codebase maintainable and extensible.</p>"},{"location":"community/overview/#contributing","title":"Contributing","text":"<p>View the Contributing Guidelines</p> <p>Interested in contributing to the project? Great! The contributing guidelines will provide you with all the information you need to get started. This includes how to submit issues, propose changes, the process for submitting pull requests, and detailed explanations of our architectural principles and coding standards.</p>"},{"location":"community/overview/#code-of-conduct","title":"Code of Conduct","text":"<p>View the Code of Conduct</p> <p>The Code of Conduct outlines the standards and behaviors expected of our community members. It's crucial to ensure a welcoming and inclusive environment for everyone. Please take the time to read and adhere to these guidelines.</p>"},{"location":"community/overview/#discord-community","title":"Discord Community","text":"<p>Join our Discord Server</p> <p>Connect with other FastCRUD users and maintainers in real-time! Get help, share your projects, discuss feature ideas, and stay updated with the latest developments. Our Discord community is the best place for quick questions and community support.</p>"},{"location":"community/overview/#license","title":"License","text":"<p>View the License</p> <p>The license document outlines the terms under which our project can be used, modified, and distributed. Understanding the licensing is important for both users and contributors of the project.</p> <p>Thank you for being a part of our community and for contributing to our project's success!</p>"},{"location":"community/showcase_submission/","title":"Submit Your Project","text":"<p>Share Your Work</p> <p>Have you built something with FastCRUD? We'd love to feature it in our showcase!</p>"},{"location":"community/showcase_submission/#project-categories","title":"Project Categories","text":"<p>What You Can Submit</p> <ul> <li>Tutorials: Step-by-step guides teaching others how to build with FastCRUD</li> <li>Open Source Projects: Libraries, tools, or applications others can use and learn from</li> <li>Applications: Web apps, desktop tools, or services built with FastCRUD</li> <li>Commercial Services: Products or services powered by FastCRUD</li> </ul>"},{"location":"community/showcase_submission/#how-to-submit","title":"How to Submit","text":"<p>Submission Steps</p> <ol> <li>Create a new issue using our Showcase Submission Template</li> <li>Fill in the relevant information for your project type</li> <li>We'll review your submission and add it to the showcase!</li> </ol>"},{"location":"community/showcase_submission/#requirements-by-category","title":"Requirements by Category","text":"<p>What We Look For</p> <p>For Tutorials:</p> <ul> <li>Clear step-by-step instructions</li> <li>Working code examples</li> <li>Explanation of concepts used</li> </ul> <p>For Open Source Projects:</p> <ul> <li>Public repository</li> <li>Basic documentation</li> <li>Installation/usage instructions</li> </ul> <p>For Applications/Services:</p> <ul> <li>Public demo or screenshots</li> <li>Description of FastCRUD features used</li> <li>Link to live service (if applicable)</li> </ul>"},{"location":"community/showcase_submission/#need-help","title":"Need Help?","text":"<p>Questions?</p> <p>Need help with your submission? We're here to help!</p> <ul> <li>Open a discussion on GitHub</li> </ul>"},{"location":"usage/crud/","title":"Using FastCRUD for Enhanced CRUD Operations","text":"<p>FastCRUD is a versatile tool for handling CRUD (Create, Read, Update, Delete) operations in FastAPI applications with SQLAlchemy models. It leverages Pydantic schemas for data validation and serialization, offering a streamlined approach to database interactions.</p>"},{"location":"usage/crud/#key-features","title":"Key Features","text":"<ul> <li>Simplified CRUD operations with SQLAlchemy models.</li> <li>Data validation and serialization using Pydantic.</li> <li>Support for complex queries including joins and pagination.</li> </ul>"},{"location":"usage/crud/#getting-started","title":"Getting Started","text":""},{"location":"usage/crud/#step-1-define-models-and-schemas","title":"Step 1: Define Models and Schemas","text":"<p>Define your SQLAlchemy models and Pydantic schemas for data representation.</p> Models and Schemas Used Below <code>item/model.py</code> <pre><code>from sqlalchemy import Column, DateTime, Integer, Numeric, String, func\nfrom sqlalchemy.orm import DeclarativeBase\n\n\nclass Base(DeclarativeBase):\n    pass\n\n\nclass Item(Base):\n    __tablename__ = \"items\"\n    id = Column(Integer, primary_key=True)\n    name = Column(String)\n    description = Column(String)\n    category = Column(String)\n    price = Column(Numeric)\n    last_sold = Column(DateTime)\n    created_at = Column(DateTime, default=func.now())\n</code></pre> <code>item/schemas.py</code> <pre><code>import datetime\n\nfrom pydantic import BaseModel\n\n\nclass CreateItemSchema(BaseModel):\n    name: str | None = None\n    description: str | None = None\n    category: str | None = None\n    price: float | None = None\n    last_sold: datetime.datetime | None = None\n\n\nclass UpdateItemSchema(BaseModel):\n    name: str | None = None\n    description: str | None = None\n    category: str | None = None\n    price: float | None = None\n    last_sold: datetime.datetime | None = None\n</code></pre> <code>customer/model.py</code> <pre><code>from sqlalchemy import Column, Integer, String\nfrom sqlalchemy.orm import DeclarativeBase\n\n\nclass Base(DeclarativeBase):\n    pass\n\n\nclass Customer(Base):\n    __tablename__ = \"customer\"\n    id = Column(Integer, primary_key=True)\n    name = Column(String)\n</code></pre> <code>customer/schemas.py</code> <pre><code>from pydantic import BaseModel\n\n\nclass ReadCustomerSchema(BaseModel):\n    id: int\n    name: str | None = None\n</code></pre> <code>product/model.py</code> <pre><code>from sqlalchemy import Column, Integer, Numeric, String\nfrom sqlalchemy.orm import DeclarativeBase\n\n\nclass Base(DeclarativeBase):\n    pass\n\n\nclass Product(Base):\n    __tablename__ = \"product\"\n    id = Column(Integer, primary_key=True)\n    name = Column(String)\n    price = Column(Numeric)\n</code></pre> <code>order/model.py</code> <pre><code>from sqlalchemy import Column, ForeignKey, Integer\nfrom sqlalchemy.orm import DeclarativeBase\n\n\nclass Base(DeclarativeBase):\n    pass\n\n\nclass Order(Base):\n    __tablename__ = \"order\"\n    id = Column(Integer, primary_key=True)\n    customer_id = Column(Integer, ForeignKey(\"customer.id\"))\n    product_id = Column(Integer, ForeignKey(\"product.id\"))\n    quantity = Column(Integer)\n</code></pre> <code>order/schemas.py</code> <pre><code>from pydantic import BaseModel\n\n\nclass ReadOrderSchema(BaseModel):\n    id: int\n    customer_id: int | None = None\n    product_id: int | None = None\n    quantity: int | None = None\n</code></pre>"},{"location":"usage/crud/#step-2-initialize-fastcrud","title":"Step 2: Initialize FastCRUD","text":"<p>Create a <code>FastCRUD</code> instance for your model to handle CRUD operations.</p> <pre><code>from fastcrud import FastCRUD\n\n# Creating a FastCRUD instance\nitem_crud = FastCRUD(Item)\norder_crud = FastCRUD(Order)\n</code></pre>"},{"location":"usage/crud/#step-3-pick-your-method","title":"Step 3: Pick your Method","text":"<p>Then you just pick the method you need and use it like this:</p> <pre><code># Creating a new record\nnew_record = await item_crud.create(db_session, create_schema_instance)\n</code></pre> <p>More on available methods below.</p>"},{"location":"usage/crud/#understanding-fastcrud-methods","title":"Understanding FastCRUD Methods","text":"<p>FastCRUD offers a comprehensive suite of methods for CRUD operations, each designed to handle different aspects of database interactions efficiently.</p>"},{"location":"usage/crud/#1-create","title":"1. Create","text":"<pre><code>create(\n    db: AsyncSession,\n    object: CreateSchemaType,\n    commit: bool = True,\n) -&gt; ModelType\n</code></pre> <p>Purpose: To create a new record in the database. Usage Example: Creates an item with name <code>\"New Item\"</code>.</p> <pre><code>new_item = await item_crud.create(db, CreateItemSchema(name=\"New Item\"))\n</code></pre> <p>Warning</p> <p>Note that naive <code>datetime</code> such as <code>datetime.utcnow</code> is not supported by <code>FastCRUD</code> as it was deprecated.</p> <p>Use timezone aware <code>datetime</code>, such as <code>datetime.now(UTC)</code> instead.</p>"},{"location":"usage/crud/#2-get","title":"2. Get","text":"<pre><code>get(\n    db: AsyncSession,\n    schema_to_select: Optional[type[BaseModel]] = None,\n    return_as_model: bool = False,\n    one_or_none: bool = False,\n    **kwargs: Any,\n) -&gt; Optional[Union[dict, BaseModel]]\n</code></pre> <p>Purpose: To fetch a single record based on filters, with an option to select specific columns using a Pydantic schema. Return Types: - When <code>return_as_model=True</code> and <code>schema_to_select</code> is provided: <code>Optional[SelectSchemaType]</code> - When <code>return_as_model=False</code>: <code>Optional[Dict[str, Any]]</code></p> <p>Usage Examples: </p> <p>Fetch item as dictionary: <pre><code>item = await item_crud.get(db, id=item_id)\n# Returns: Optional[Dict[str, Any]]\n</code></pre></p> <p>Fetch item as typed Pydantic model: <pre><code>from .schemas import ReadItemSchema\n\nitem = await item_crud.get(\n    db, \n    schema_to_select=ReadItemSchema,\n    return_as_model=True,\n    id=item_id\n)\n# Returns: Optional[ReadItemSchema]\n</code></pre></p>"},{"location":"usage/crud/#3-exists","title":"3. Exists","text":"<pre><code>exists(\n    db: AsyncSession,\n    **kwargs: Any,\n) -&gt; bool\n</code></pre> <p>Purpose: To check if a record exists based on provided filters. Usage Example: Checks whether an item with name <code>\"Existing Item\"</code> exists.</p> <pre><code>exists = await item_crud.exists(db, name=\"Existing Item\")\n</code></pre>"},{"location":"usage/crud/#4-count","title":"4. Count","text":"<pre><code>count(\n    db: AsyncSession,\n    joins_config: Optional[list[JoinConfig]] = None,\n    **kwargs: Any,\n) -&gt; int\n</code></pre> <p>Purpose: To count the number of records matching provided filters. Usage Example: Counts the number of items with the <code>\"Books\"</code> category.</p> <pre><code>count = await item_crud.count(db, category=\"Books\")\n</code></pre>"},{"location":"usage/crud/#5-get-multi","title":"5. Get Multi","text":"<pre><code>get_multi(\n    db: AsyncSession,\n    offset: int = 0,\n    limit: Optional[int] = 100,\n    schema_to_select: Optional[type[BaseModel]] = None,\n    sort_columns: Optional[Union[str, list[str]]] = None,\n    sort_orders: Optional[Union[str, list[str]]] = None,\n    return_as_model: bool = False,\n    return_total_count: bool = True,\n    **kwargs: Any,\n) -&gt; dict[str, Any]\n</code></pre> <p>Purpose: To fetch multiple records with optional sorting, pagination, and model conversion. Return Types: - When <code>return_as_model=True</code> and <code>schema_to_select</code> is provided: <code>GetMultiResponseModel[SelectSchemaType]</code> (i.e., <code>Dict[str, Union[List[SelectSchemaType], int]]</code>) - When <code>return_as_model=False</code>: <code>GetMultiResponseDict</code> (i.e., <code>Dict[str, Union[List[Dict[str, Any]], int]]</code>)</p> <p>Usage Examples: </p> <p>Fetch items as dictionaries: <pre><code>items = await item_crud.get_multi(db, offset=10, limit=5)\n# Returns: {\"data\": [Dict[str, Any], ...], \"total_count\": int}\n</code></pre></p> <p>Fetch items as typed Pydantic models: <pre><code>from .schemas import ReadItemSchema\n\nitems = await item_crud.get_multi(\n    db, \n    offset=10, \n    limit=5,\n    schema_to_select=ReadItemSchema,\n    return_as_model=True\n)\n# Returns: {\"data\": [ReadItemSchema, ...], \"total_count\": int}\n</code></pre></p>"},{"location":"usage/crud/#6-update","title":"6. Update","text":"<pre><code>update(\n    db: AsyncSession, \n    object: Union[UpdateSchemaType, dict[str, Any]], \n    allow_multiple: bool = False,\n    commit: bool = True,\n    return_columns: Optional[list[str]] = None,\n    schema_to_select: Optional[type[BaseModel]] = None,\n    return_as_model: bool = False,\n    one_or_none: bool = False,\n    **kwargs: Any,\n) -&gt; Optional[Union[dict, BaseModel]]\n</code></pre> <p>Purpose: To update an existing record in the database. Return Types: - When <code>return_as_model=True</code> and <code>schema_to_select</code> is provided: <code>Optional[SelectSchemaType]</code> - When <code>return_as_model=False</code>: <code>Optional[Dict[str, Any]]</code></p> <p>Usage Examples: </p> <p>Update and return as dictionary: <pre><code>updated_item = await item_crud.update(\n    db,\n    UpdateItemSchema(description=\"Updated\"),\n    id=item_id,\n)\n# Returns: Optional[Dict[str, Any]]\n</code></pre></p> <p>Update and return as typed Pydantic model: <pre><code>from .schemas import ReadItemSchema, UpdateItemSchema\n\nupdated_item = await item_crud.update(\n    db,\n    UpdateItemSchema(description=\"Updated\"),\n    schema_to_select=ReadItemSchema,\n    return_as_model=True,\n    id=item_id,\n)\n# Returns: Optional[ReadItemSchema]\n</code></pre></p>"},{"location":"usage/crud/#7-delete","title":"7. Delete","text":"<pre><code>delete(\n    db: AsyncSession, \n    db_row: Optional[Row] = None, \n    allow_multiple: bool = False,\n    commit: bool = True,\n    **kwargs: Any,\n) -&gt; None\n</code></pre> <p>Purpose: To delete a record from the database, with support for soft delete. Usage Example: Deletes the item with <code>item_id</code> as its <code>id</code>, performs a soft delete if the model has the <code>is_deleted</code> column.</p> <pre><code>await item_crud.delete(db, id=item_id)\n</code></pre>"},{"location":"usage/crud/#8-hard-delete","title":"8. Hard Delete","text":"<pre><code>db_delete(\n    db: AsyncSession, \n    allow_multiple: bool = False,\n    commit: bool = True,\n    **kwargs: Any,\n) -&gt; None\n</code></pre> <p>Purpose: To hard delete a record from the database. Usage Example: Hard deletes the item with <code>item_id</code> as its <code>id</code>.</p> <pre><code>await item_crud.db_delete(db, id=item_id)\n</code></pre>"},{"location":"usage/crud/#advanced-methods-for-complex-queries-and-joins","title":"Advanced Methods for Complex Queries and Joins","text":"<p>FastCRUD extends its functionality with advanced methods tailored for complex query operations and handling joins. These methods cater to specific use cases where more sophisticated data retrieval and manipulation are required.</p>"},{"location":"usage/crud/#1-get-multi","title":"1. Get Multi","text":"<pre><code>get_multi(\n    db: AsyncSession,\n    offset: int = 0,\n    limit: Optional[int] = 100,\n    schema_to_select: Optional[type[BaseModel]] = None,\n    sort_columns: Optional[Union[str, list[str]]] = None,\n    sort_orders: Optional[Union[str, list[str]]] = None,\n    return_as_model: bool = False,\n    return_total_count: bool = True,\n    **kwargs: Any,\n) -&gt; dict[str, Any]\n</code></pre> <p>Purpose: To fetch multiple records based on specified filters, with options for sorting and pagination. Usage Example: Gets the first 10 items sorted by <code>name</code> in ascending order.</p> <pre><code>items = await item_crud.get_multi(\n    db,\n    offset=0,\n    limit=10,\n    sort_columns=['name'],\n    sort_orders=['asc'],\n)\n</code></pre>"},{"location":"usage/crud/#2-get-joined","title":"2. Get Joined","text":"<pre><code>get_joined(\n    db: AsyncSession,\n    schema_to_select: Optional[type[BaseModel]] = None,\n    join_model: Optional[ModelType] = None,\n    join_on: Optional[Union[Join, BinaryExpression]] = None,\n    join_prefix: Optional[str] = None,\n    join_schema_to_select: Optional[type[BaseModel]] = None,\n    join_type: str = \"left\",\n    alias: Optional[AliasedClass] = None,\n    join_filters: Optional[dict] = None,\n    joins_config: Optional[list[JoinConfig]] = None,\n    nest_joins: bool = False,\n    relationship_type: Optional[str] = None,\n    **kwargs: Any,\n) -&gt; Optional[dict[str, Any]]\n</code></pre> <p>Purpose: To fetch a single record with one or multiple joins on other models. Usage Example: Fetches order details for a specific order by joining with the <code>Customer</code> table, selecting specific columns as defined in <code>ReadOrderSchema</code> and <code>ReadCustomerSchema</code>.</p> <pre><code>order_details = await order_crud.get_joined(\n    db,\n    schema_to_select=ReadOrderSchema,\n    join_model=Customer,\n    join_schema_to_select=ReadCustomerSchema,\n    id=order_id,\n)\n</code></pre>"},{"location":"usage/crud/#3-get-multi-joined","title":"3. Get Multi Joined","text":"<pre><code>get_multi_joined(\n    db: AsyncSession,\n    schema_to_select: Optional[type[BaseModel]] = None,\n    join_model: Optional[type[ModelType]] = None,\n    join_on: Optional[Any] = None,\n    join_prefix: Optional[str] = None,\n    join_schema_to_select: Optional[type[BaseModel]] = None,\n    join_type: str = \"left\",\n    alias: Optional[AliasedClass[Any]] = None,\n    join_filters: Optional[dict] = None,\n    nest_joins: bool = False,\n    offset: int = 0,\n    limit: Optional[int] = 100,\n    sort_columns: Optional[Union[str, list[str]]] = None,\n    sort_orders: Optional[Union[str, list[str]]] = None,\n    return_as_model: bool = False,\n    joins_config: Optional[list[JoinConfig]] = None,\n    return_total_count: bool = True,\n    relationship_type: Optional[str] = None,\n    **kwargs: Any,\n) -&gt; dict[str, Any]\n</code></pre> <p>Purpose: Similar to <code>get_joined</code>, but for fetching multiple records. Return Types: - When <code>return_as_model=True</code> and <code>schema_to_select</code> is provided: <code>GetMultiResponseModel[SelectSchemaType]</code> (i.e., <code>Dict[str, Union[List[SelectSchemaType], int]]</code>) - When <code>return_as_model=False</code>: <code>GetMultiResponseDict</code> (i.e., <code>Dict[str, Union[List[Dict[str, Any]], int]]</code>)</p> <p>Usage Examples: </p> <p>Fetch joined records as dictionaries: <pre><code>orders = await order_crud.get_multi_joined(\n    db,\n    schema_to_select=ReadOrderSchema,\n    join_model=Customer,\n    join_schema_to_select=ReadCustomerSchema,\n    offset=0,\n    limit=5,\n)\n# Returns: {\"data\": [Dict[str, Any], ...], \"total_count\": int}\n</code></pre></p> <p>Fetch joined records as typed Pydantic models: <pre><code>orders = await order_crud.get_multi_joined(\n    db,\n    schema_to_select=ReadOrderSchema,\n    join_model=Customer,\n    join_schema_to_select=ReadCustomerSchema,\n    return_as_model=True,\n    offset=0,\n    limit=5,\n)\n# Returns: {\"data\": [ReadOrderSchema, ...], \"total_count\": int}\n</code></pre></p>"},{"location":"usage/crud/#4-get-multi-by-cursor","title":"4. Get Multi By Cursor","text":"<pre><code>get_multi_by_cursor(\n    db: AsyncSession,\n    cursor: Any = None,\n    limit: int = 100,\n    schema_to_select: Optional[type[BaseModel]] = None,\n    sort_column: str = \"id\",\n    sort_order: str = \"asc\",\n    return_as_model: bool = False,\n    **kwargs: Any,\n) -&gt; dict[str, Any]\n</code></pre> <p>Purpose: Implements cursor-based pagination for efficient data retrieval in large datasets. Return Types: - When <code>return_as_model=True</code> and <code>schema_to_select</code> is provided: <code>Dict[str, Union[List[SelectSchemaType], Any]]</code> - When <code>return_as_model=False</code>: <code>Dict[str, Union[List[Dict[str, Any]], Any]]</code></p> <p>Usage Examples: </p> <p>Cursor pagination with dictionaries: <pre><code>paginated_items = await item_crud.get_multi_by_cursor(\n    db,\n    cursor=last_cursor,\n    limit=10,\n    sort_column='created_at',\n    sort_order='desc',\n)\n# Returns: {\"data\": [Dict[str, Any], ...], \"next_cursor\": Any}\n</code></pre></p> <p>Cursor pagination with typed Pydantic models: <pre><code>from .schemas import ReadItemSchema\n\npaginated_items = await item_crud.get_multi_by_cursor(\n    db,\n    cursor=last_cursor,\n    limit=10,\n    schema_to_select=ReadItemSchema,\n    return_as_model=True,\n    sort_column='created_at',\n    sort_order='desc',\n)\n# Returns: {\"data\": [ReadItemSchema, ...], \"next_cursor\": Any}\n</code></pre></p>"},{"location":"usage/crud/#5-select","title":"5. Select","text":"<pre><code>async def select(\n    db: AsyncSession,\n    schema_to_select: Optional[type[BaseModel]] = None,\n    sort_columns: Optional[Union[str, list[str]]] = None,\n    sort_orders: Optional[Union[str, list[str]]] = None,\n    **kwargs: Any,\n) -&gt; Select\n</code></pre> <p>Purpose: Constructs a SQL Alchemy <code>Select</code> statement with optional column selection, filtering, and sorting. Usage Example: Selects all items, filtering by <code>name</code> and sorting by <code>id</code>. Returns the <code>Select</code> statement.</p> <pre><code>stmt = await item_crud.select(\n    schema_to_select=ItemSchema,\n    sort_columns='id',\n    name='John',\n)\n# Note: This method returns a SQL Alchemy Select object, not the actual query result.\n</code></pre>"},{"location":"usage/crud/#6-count-for-joined-models","title":"6. Count for Joined Models","text":"<pre><code>count(\n    db: AsyncSession,\n    joins_config: Optional[list[JoinConfig]] = None,\n    **kwargs: Any,\n) -&gt; int\n</code></pre> <p>Purpose: To count records that match specified filters, especially useful in scenarios involving joins between models. This method supports counting unique entities across relationships, a common requirement in many-to-many or complex relationships. Usage Example: Count the number of unique projects a participant is involved in, considering a many-to-many relationship between <code>Project</code> and <code>Participant</code> models.</p> Models <pre><code>class Project(Base):\n    __tablename__ = \"projects\"\n    id = Column(Integer, primary_key=True)\n    name = Column(String(32), nullable=False)\n    description = Column(String(32))\n    participants = relationship(\n        \"Participant\",\n        secondary=\"projects_participants_association\",\n        back_populates=\"projects\",\n    )\n\n\nclass Participant(Base):\n    __tablename__ = \"participants\"\n    id = Column(Integer, primary_key=True)\n    name = Column(String(32), nullable=False)\n    role = Column(String(32))\n    projects = relationship(\n        \"Project\",\n        secondary=\"projects_participants_association\",\n        back_populates=\"participants\",\n    )\n\n\nclass ProjectsParticipantsAssociation(Base):\n    __tablename__ = \"projects_participants_association\"\n    project_id = Column(Integer, ForeignKey(\"projects.id\"), primary_key=True)\n    participant_id = Column(Integer, ForeignKey(\"participants.id\"), primary_key=True)\n</code></pre> <pre><code>project_crud = FastCRUD(Project)\nprojects_count = await project_crud.count(\n    db=session,\n    joins_config=[\n        JoinConfig(\n            model=Participant,\n            join_on=ProjectsParticipantsAssociation.project_id == Project.id,\n            join_type=\"inner\",\n        ),\n    ],\n    participant_id=specific_participant_id,\n)\n</code></pre>"},{"location":"usage/crud/#error-handling","title":"Error Handling","text":"<p>FastCRUD provides mechanisms to handle common database errors, ensuring robust API behavior.</p>"},{"location":"usage/endpoint/","title":"Automatic Endpoint Creation with <code>crud_router</code>","text":"<p>This section of the documentation explains how to use the <code>crud_router</code> utility function from the FastCRUD package for automatic endpoint creation in a FastAPI application. The <code>crud_router</code> simplifies the process of creating standard CRUD (Create, Read, Update, Delete) endpoints for your models.</p>"},{"location":"usage/endpoint/#prerequisites","title":"Prerequisites","text":"<p>Before proceeding, ensure you have FastAPI and FastCRUD installed in your environment. FastCRUD streamlines interactions with the database using SQLAlchemy models and Pydantic schemas.</p>"},{"location":"usage/endpoint/#using-crud_router","title":"Using <code>crud_router</code>","text":""},{"location":"usage/endpoint/#step-1-define-your-model-and-schema","title":"Step 1: Define Your Model and Schema","text":"<p>First, define your SQLAlchemy model and corresponding Pydantic schemas for creating and updating data.</p> <code>item/model.py</code> <pre><code>from sqlalchemy import Column, DateTime, Integer, Numeric, String, func\nfrom sqlalchemy.orm import DeclarativeBase\n\n\nclass Base(DeclarativeBase):\n    pass\n\n\nclass Item(Base):\n    __tablename__ = \"items\"\n    id = Column(Integer, primary_key=True)\n    name = Column(String)\n    description = Column(String)\n    category = Column(String)\n    price = Column(Numeric)\n    last_sold = Column(DateTime)\n    created_at = Column(DateTime, default=func.now())\n</code></pre> <code>item/schemas.py</code> <pre><code>import datetime\n\nfrom pydantic import BaseModel\n\n\nclass CreateItemSchema(BaseModel):\n    name: str | None = None\n    description: str | None = None\n    category: str | None = None\n    price: float | None = None\n    last_sold: datetime.datetime | None = None\n\n\nclass UpdateItemSchema(BaseModel):\n    name: str | None = None\n    description: str | None = None\n    category: str | None = None\n    price: float | None = None\n    last_sold: datetime.datetime | None = None\n</code></pre>"},{"location":"usage/endpoint/#step-2-set-up-fastapi-and-fastcrud","title":"Step 2: Set Up FastAPI and FastCRUD","text":"<p>Next, set up your FastAPI application, you can optionally set up a custom FastCRUD instance as well. This involves configuring the database connection.</p> <pre><code>from typing import AsyncGenerator\n\nfrom fastapi import FastAPI\nfrom fastcrud import FastCRUD, crud_router\nfrom sqlalchemy.ext.asyncio import AsyncSession, create_async_engine\nfrom sqlalchemy.orm import sessionmaker\n\n# Database setup (Async SQLAlchemy)\nDATABASE_URL = \"sqlite+aiosqlite:///./test.db\"\nengine = create_async_engine(DATABASE_URL, echo=True)\nasync_session = sessionmaker(engine, class_=AsyncSession, expire_on_commit=False)\n\n# Database session dependency\nasync def get_session() -&gt; AsyncGenerator[AsyncSession, None]:\n    async with async_session() as session:\n        yield session\n\n# Create tables before the app start\nasync def lifespan(app: FastAPI):\n    async with engine.begin() as conn:\n        await conn.run_sync(Base.metadata.create_all)\n    yield\n\n# FastAPI app\napp = FastAPI(lifespan=lifespan)\n</code></pre>"},{"location":"usage/endpoint/#step-3-use-crud_router-to-create-endpoints","title":"Step 3: Use <code>crud_router</code> to Create Endpoints","text":"<pre><code># CRUD router setup\nitem_router = crud_router(\n    session=get_session,\n    model=Item,\n    create_schema=CreateItemSchema,\n    update_schema=UpdateItemSchema,\n    path=\"/items\",\n    tags=[\"Items\"],\n)\n\napp.include_router(item_router)\n</code></pre>"},{"location":"usage/endpoint/#available-endpoints","title":"Available Endpoints","text":"<p>For a comprehensive list of all available endpoints, read the advanced section.</p> <p>Sorting Support</p> <p>The automatically created endpoints include built-in sorting functionality. You can sort results using the <code>sort</code> query parameter:</p> <ul> <li><code>GET /items?sort=name</code> - Sort by name (ascending)</li> <li><code>GET /items?sort=-price</code> - Sort by price (descending) </li> <li><code>GET /items?sort=category,-price</code> - Sort by category ascending, then price descending</li> </ul> <p>For detailed sorting documentation, see Sorting Results.</p>"},{"location":"usage/endpoint/#usage-and-testing","title":"Usage and Testing","text":"<p>Once the application is running, you can test the automatically created endpoints using tools like Swagger UI, which FastAPI provides by default. The endpoints for creating, reading, updating, and deleting Item instances are now accessible at <code>/items</code>.</p>"},{"location":"usage/endpoint/#using-endpointcreator-directly","title":"Using <code>EndpointCreator</code> Directly","text":"<p>Using the <code>EndpointCreator</code> class in FastCRUD is a more flexible way to add CRUD endpoints to a FastAPI application.</p>"},{"location":"usage/endpoint/#step-1-define-your-model-and-schema_1","title":"Step 1: Define Your Model and Schema","text":"<p>Define your SQLAlchemy models and corresponding Pydantic schemas for data validation.</p> <code>item/model.py</code> <pre><code>from sqlalchemy import Column, DateTime, Integer, Numeric, String, func\nfrom sqlalchemy.orm import DeclarativeBase\n\n\nclass Base(DeclarativeBase):\n    pass\n\n\nclass Item(Base):\n    __tablename__ = \"items\"\n    id = Column(Integer, primary_key=True)\n    name = Column(String)\n    description = Column(String)\n    category = Column(String)\n    price = Column(Numeric)\n    last_sold = Column(DateTime)\n    created_at = Column(DateTime, default=func.now())\n</code></pre> <code>item/schemas.py</code> <pre><code>import datetime\n\nfrom pydantic import BaseModel\n\n\nclass CreateItemSchema(BaseModel):\n    name: str | None = None\n    description: str | None = None\n    category: str | None = None\n    price: float | None = None\n    last_sold: datetime.datetime | None = None\n\n\nclass UpdateItemSchema(BaseModel):\n    name: str | None = None\n    description: str | None = None\n    category: str | None = None\n    price: float | None = None\n    last_sold: datetime.datetime | None = None\n\n\nclass DeleteItemSchema(BaseModel):\n    pass\n</code></pre>"},{"location":"usage/endpoint/#step-2-set-up-fastapi-and-fastcrud_1","title":"Step 2: Set Up FastAPI and FastCRUD","text":"<p>Next, set up your FastAPI application and FastCRUD instances. This involves configuring the database connection and creating a CRUD instance for your model.</p> <pre><code>from typing import AsyncGenerator\n\nfrom fastapi import FastAPI\nfrom fastcrud import FastCRUD, crud_router\nfrom sqlalchemy.ext.asyncio import AsyncSession, create_async_engine\nfrom sqlalchemy.orm import sessionmaker\n\n# Database setup (Async SQLAlchemy)\nDATABASE_URL = \"sqlite+aiosqlite:///./test.db\"\nengine = create_async_engine(DATABASE_URL, echo=True)\nasync_session = sessionmaker(engine, class_=AsyncSession, expire_on_commit=False)\n\n# Database session dependency\nasync def get_session() -&gt; AsyncGenerator[AsyncSession, None]:\n    async with async_session() as session:\n        yield session\n\n# Create tables before the app start\nasync def lifespan(app: FastAPI):\n    async with engine.begin() as conn:\n        await conn.run_sync(Base.metadata.create_all)\n    yield\n\n# FastAPI app\napp = FastAPI(lifespan=lifespan)\n\n# CRUD operations setup\nitem_crud = FastCRUD(Item)\n</code></pre>"},{"location":"usage/endpoint/#step-3-initialize-endpointcreator","title":"Step 3: Initialize <code>EndpointCreator</code>","text":"<p>Create an instance of <code>EndpointCreator</code> by passing the necessary parameters, including your model, session, CRUD instance, and schemas.</p> <pre><code>from fastcrud import EndpointCreator\n\n# Initialize EndpointCreator\nendpoint_creator = EndpointCreator(\n    session=get_session,\n    model=Item,\n    create_schema=CreateItemSchema,\n    update_schema=UpdateItemSchema,\n    crud=item_crud,\n    delete_schema=DeleteItemSchema,\n    path=\"/itempath\",\n    tags=[\"ItemTag\"]\n)\n</code></pre>"},{"location":"usage/endpoint/#step-4-add-custom-endpoints","title":"Step 4: Add Custom Endpoints","text":"<p>Add custom endpoints using <code>EndpointCreator</code>. You can inject dependencies as needed.</p> <pre><code># Example of adding custom dependencies\nendpoint_creator.add_routes_to_router(\n    read_deps=[custom_dependency],\n    update_deps=[another_custom_dependency],\n)\n</code></pre>"},{"location":"usage/endpoint/#step-5-include-the-router-in-your-application","title":"Step 5: Include the Router in Your Application","text":"<p>Finally, include the router from the <code>EndpointCreator</code> in your FastAPI application.</p> <pre><code>app.include_router(endpoint_creator.router)\n</code></pre>"},{"location":"usage/endpoint/#advanced-customization","title":"Advanced Customization","text":"<p>You can override the default methods in <code>EndpointCreator</code> for more control over the CRUD operations. You can also specify the operations you want to include. Read more in the advanced section.</p>"},{"location":"usage/endpoint/#conclusion","title":"Conclusion","text":"<p>By following these steps, you can quickly set up CRUD endpoints for your models in a FastAPI application using <code>crud_router</code> or <code>EndpointCreator</code>. This utility function reduces boilerplate code and increases development efficiency by automating the creation of standard API endpoints.</p>"},{"location":"usage/overview/","title":"Usage Overview","text":"<p>The Usage section of our documentation provides comprehensive guides on how to effectively use key features of our application. This section is divided into various topics, each focusing on a specific aspect of usage, ensuring that you have all the information you need to leverage the full potential of our tools and functionalities.</p>"},{"location":"usage/overview/#key-topics","title":"Key Topics","text":""},{"location":"usage/overview/#1-automatic-endpoint-creation-with-crud_router","title":"1. Automatic Endpoint Creation with <code>crud_router</code>","text":"<p>This guide covers the use of <code>crud_router</code> for automatic endpoint creation in FastAPI applications. It provides a step-by-step approach to streamline the creation of standard CRUD endpoints.</p> <ul> <li>Automatic Endpoint Creation Guide</li> </ul>"},{"location":"usage/overview/#2-enhanced-crud-operations-with-fastcrud","title":"2. Enhanced CRUD Operations with FastCRUD","text":"<p>Learn how to use the <code>FastCRUD</code> class for enhanced CRUD operations. This guide delves into the functionalities offered by <code>FastCRUD</code>, including advanced query capabilities, pagination, and error handling.</p> <ul> <li>FastCRUD Usage Guide</li> </ul>"},{"location":"usage/overview/#getting-started","title":"Getting Started","text":"<p>To make the most out of these guides, we recommend familiarizing yourself with FastAPI and SQLAlchemy basics, as our application leverages these frameworks extensively.</p>"},{"location":"usage/overview/#contribution","title":"Contribution","text":"<p>If you have suggestions or contributions to these guides, please refer to our Contributing Guidelines. We appreciate your input in improving our documentation.</p>"}]}